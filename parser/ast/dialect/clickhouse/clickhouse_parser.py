# Generated from ClickHouse.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u00f5")
        buf.write("\u0393\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\3\2\3\2\3\3\3\3")
        buf.write("\3\3\3\3\7\3\u0089\n\3\f\3\16\3\u008c\13\3\3\4\3\4\3\4")
        buf.write("\3\4\3\4\5\4\u0093\n\4\3\5\3\5\3\5\3\5\3\5\5\5\u009a\n")
        buf.write("\5\3\6\5\6\u009d\n\6\3\6\3\6\5\6\u00a1\n\6\3\6\5\6\u00a4")
        buf.write("\n\6\3\6\5\6\u00a7\n\6\3\6\5\6\u00aa\n\6\3\6\5\6\u00ad")
        buf.write("\n\6\3\6\5\6\u00b0\n\6\3\6\5\6\u00b3\n\6\3\6\5\6\u00b6")
        buf.write("\n\6\3\6\5\6\u00b9\n\6\3\6\5\6\u00bc\n\6\3\6\5\6\u00bf")
        buf.write("\n\6\3\6\5\6\u00c2\n\6\3\7\3\7\3\7\3\b\3\b\5\b\u00c9\n")
        buf.write("\b\3\b\5\b\u00cc\n\b\3\b\3\b\3\t\3\t\3\t\3\n\3\n\3\n\3")
        buf.write("\n\5\n\u00d7\n\n\3\13\3\13\3\13\3\f\5\f\u00dd\n\f\3\f")
        buf.write("\3\f\3\f\3\f\3\r\3\r\3\r\3\16\3\16\3\16\3\17\3\17\3\17")
        buf.write("\3\17\3\17\3\17\3\17\5\17\u00f0\n\17\3\17\3\17\3\17\3")
        buf.write("\17\5\17\u00f6\n\17\5\17\u00f8\n\17\3\20\3\20\3\20\3\21")
        buf.write("\3\21\3\21\3\21\3\22\3\22\3\22\3\22\3\22\3\23\3\23\3\23")
        buf.write("\3\23\5\23\u010a\n\23\3\24\3\24\3\24\3\24\3\24\3\24\3")
        buf.write("\24\5\24\u0113\n\24\3\25\3\25\3\25\3\26\3\26\3\26\3\26")
        buf.write("\3\26\3\26\5\26\u011e\n\26\3\27\3\27\3\27\5\27\u0123\n")
        buf.write("\27\3\27\5\27\u0126\n\27\3\27\3\27\3\27\3\27\5\27\u012c")
        buf.write("\n\27\3\27\3\27\3\27\3\27\3\27\3\27\5\27\u0134\n\27\3")
        buf.write("\27\5\27\u0137\n\27\3\27\3\27\3\27\3\27\7\27\u013d\n\27")
        buf.write("\f\27\16\27\u0140\13\27\3\30\5\30\u0143\n\30\3\30\3\30")
        buf.write("\3\30\5\30\u0148\n\30\3\30\3\30\5\30\u014c\n\30\3\30\3")
        buf.write("\30\5\30\u0150\n\30\3\30\3\30\5\30\u0154\n\30\3\30\5\30")
        buf.write("\u0157\n\30\3\30\5\30\u015a\n\30\3\30\3\30\5\30\u015e")
        buf.write("\n\30\3\30\3\30\5\30\u0162\n\30\3\30\5\30\u0165\n\30\5")
        buf.write("\30\u0167\n\30\3\31\5\31\u016a\n\31\3\31\3\31\3\31\5\31")
        buf.write("\u016f\n\31\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3")
        buf.write("\32\5\32\u017a\n\32\3\33\3\33\3\33\3\33\5\33\u0180\n\33")
        buf.write("\3\34\3\34\3\34\5\34\u0185\n\34\3\35\3\35\3\35\7\35\u018a")
        buf.write("\n\35\f\35\16\35\u018d\13\35\3\36\3\36\5\36\u0191\n\36")
        buf.write("\3\36\3\36\5\36\u0195\n\36\3\36\3\36\5\36\u0199\n\36\3")
        buf.write("\37\3\37\3\37\5\37\u019e\n\37\3 \3 \3 \7 \u01a3\n \f ")
        buf.write("\16 \u01a6\13 \3!\3!\3!\3!\3\"\3\"\3\"\3\"\3\"\3\"\3\"")
        buf.write("\7\"\u01b3\n\"\f\"\16\"\u01b6\13\"\3\"\3\"\3\"\3\"\3\"")
        buf.write("\3\"\3\"\7\"\u01bf\n\"\f\"\16\"\u01c2\13\"\3\"\3\"\3\"")
        buf.write("\3\"\3\"\5\"\u01c9\n\"\3\"\3\"\3\"\3\"\3\"\5\"\u01d0\n")
        buf.write("\"\3\"\3\"\3\"\3\"\3\"\5\"\u01d7\n\"\3\"\3\"\5\"\u01db")
        buf.write("\n\"\3#\3#\3#\3$\3$\3$\7$\u01e3\n$\f$\16$\u01e6\13$\3")
        buf.write("%\3%\3%\3%\3%\3&\3&\3&\5&\u01f0\n&\3&\3&\3&\3&\3&\3&\5")
        buf.write("&\u01f8\n&\3\'\3\'\5\'\u01fc\n\'\3\'\6\'\u01ff\n\'\r\'")
        buf.write("\16\'\u0200\3\'\3\'\5\'\u0205\n\'\3\'\3\'\3(\3(\3(\3(")
        buf.write("\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\3(\3(\3(\5(\u0226\n(\3(\3(\3(\3(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\5(\u023c\n(\3")
        buf.write("(\5(\u023f\n(\3(\5(\u0242\n(\3(\3(\3(\3(\3(\3(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\5(\u025a\n(\3")
        buf.write("(\3(\3(\3(\3(\5(\u0261\n(\3(\5(\u0264\n(\3(\3(\5(\u0268")
        buf.write("\n(\3(\5(\u026b\n(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\5(\u027d\n(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\3(\5(\u028e\n(\3(\3(\5(\u0292\n(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\5(\u02a3\n(\3(\5")
        buf.write("(\u02a6\n(\3(\3(\5(\u02aa\n(\3(\5(\u02ad\n(\3(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\3(\5(\u02b8\n(\3(\3(\3(\3(\3(\3(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\5")
        buf.write("(\u02d4\n(\3(\3(\3(\3(\3(\5(\u02db\n(\3(\3(\3(\7(\u02e0")
        buf.write("\n(\f(\16(\u02e3\13(\3)\3)\3)\7)\u02e8\n)\f)\16)\u02eb")
        buf.write("\13)\3*\3*\5*\u02ef\n*\3+\3+\3+\3+\7+\u02f5\n+\f+\16+")
        buf.write("\u02f8\13+\3+\3+\3+\3+\3+\7+\u02ff\n+\f+\16+\u0302\13")
        buf.write("+\5+\u0304\n+\3+\3+\3+\3,\3,\3,\5,\u030c\n,\3,\3,\3-\3")
        buf.write("-\3-\5-\u0313\n-\3.\3.\3.\3.\3.\3.\3.\3.\5.\u031d\n.\3")
        buf.write(".\3.\3.\3.\5.\u0323\n.\7.\u0325\n.\f.\16.\u0328\13.\3")
        buf.write("/\3/\3/\3/\3/\3/\3/\3/\3/\3/\3/\3/\3/\3/\3/\3/\3/\3/\3")
        buf.write("/\5/\u033d\n/\3\60\3\60\3\60\5\60\u0342\n\60\3\60\3\60")
        buf.write("\3\61\3\61\3\61\5\61\u0349\n\61\3\61\3\61\3\62\3\62\3")
        buf.write("\62\7\62\u0350\n\62\f\62\16\62\u0353\13\62\3\63\3\63\3")
        buf.write("\63\5\63\u0358\n\63\3\64\3\64\3\65\3\65\3\65\3\65\3\65")
        buf.write("\3\65\5\65\u0362\n\65\5\65\u0364\n\65\3\66\5\66\u0367")
        buf.write("\n\66\3\66\3\66\3\66\3\66\3\66\3\66\5\66\u036f\n\66\3")
        buf.write("\67\3\67\3\67\5\67\u0374\n\67\38\38\39\39\3:\3:\3;\3;")
        buf.write("\3<\3<\3=\3=\3>\3>\5>\u0384\n>\3?\3?\3?\5?\u0389\n?\3")
        buf.write("@\3@\5@\u038d\n@\3A\3A\3A\3A\3A\2\5,NZB\2\4\6\b\n\f\16")
        buf.write("\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDF")
        buf.write("HJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\2\33\4\2[[gg\4\2\'")
        buf.write("\'\u0095\u0095\4\2\22\22\60\60\4\2MMll\5\2\13\13\17\17")
        buf.write("\23\23\6\2\13\13\16\17\23\23\u0099\u0099\4\2gg\u0094\u0094")
        buf.write("\4\2\13\13\17\17\4\2}}\u00da\u00da\4\2\22\22\60\61\4\2")
        buf.write("DDdd\5\2\30\30ff\u00b5\u00b5\3\2TU\3\2\u0088\u0089\5\2")
        buf.write("\u00d5\u00d5\u00e8\u00e8\u00f1\u00f1\4\2\u00db\u00dc\u00e9")
        buf.write("\u00e9\4\2VVii\3\2\u00d0\u00d1\4\2\u00dc\u00dc\u00e9\u00e9")
        buf.write("\n\2++RRrrtt\u008c\u008c\u0097\u0097\u00c4\u00c4\u00cb")
        buf.write("\u00cb\n\2\26\26$$ooqq\u0085\u0086\u00a0\u00a2\u00a5\u00a5")
        buf.write("\u00c5\u00c7\3\2\3\7\4\2\20\20\u00b9\u00b9\30\2\t\25\27")
        buf.write("#%*,KMQSTVXZqssuvyz|\u0084\u0087\u0087\u008a\u008b\u008d")
        buf.write("\u0096\u0098\u009f\u00a3\u00a4\u00a6\u00aa\u00ac\u00b8")
        buf.write("\u00ba\u00c3\u00c8\u00ca\u00cc\u00cd\6\2**DDSSbb\2\u0401")
        buf.write("\2\u0082\3\2\2\2\4\u0084\3\2\2\2\6\u0092\3\2\2\2\b\u0099")
        buf.write("\3\2\2\2\n\u009c\3\2\2\2\f\u00c3\3\2\2\2\16\u00c6\3\2")
        buf.write("\2\2\20\u00cf\3\2\2\2\22\u00d2\3\2\2\2\24\u00d8\3\2\2")
        buf.write("\2\26\u00dc\3\2\2\2\30\u00e2\3\2\2\2\32\u00e5\3\2\2\2")
        buf.write("\34\u00f7\3\2\2\2\36\u00f9\3\2\2\2 \u00fc\3\2\2\2\"\u0100")
        buf.write("\3\2\2\2$\u0105\3\2\2\2&\u010b\3\2\2\2(\u0114\3\2\2\2")
        buf.write("*\u011d\3\2\2\2,\u012b\3\2\2\2.\u0166\3\2\2\2\60\u016e")
        buf.write("\3\2\2\2\62\u0179\3\2\2\2\64\u017b\3\2\2\2\66\u0181\3")
        buf.write("\2\2\28\u0186\3\2\2\2:\u018e\3\2\2\2<\u019a\3\2\2\2>\u019f")
        buf.write("\3\2\2\2@\u01a7\3\2\2\2B\u01da\3\2\2\2D\u01dc\3\2\2\2")
        buf.write("F\u01df\3\2\2\2H\u01e7\3\2\2\2J\u01f7\3\2\2\2L\u01f9\3")
        buf.write("\2\2\2N\u0291\3\2\2\2P\u02e4\3\2\2\2R\u02ee\3\2\2\2T\u0303")
        buf.write("\3\2\2\2V\u030b\3\2\2\2X\u030f\3\2\2\2Z\u031c\3\2\2\2")
        buf.write("\\\u0329\3\2\2\2^\u033e\3\2\2\2`\u0348\3\2\2\2b\u034c")
        buf.write("\3\2\2\2d\u0357\3\2\2\2f\u0359\3\2\2\2h\u0363\3\2\2\2")
        buf.write("j\u0366\3\2\2\2l\u0373\3\2\2\2n\u0375\3\2\2\2p\u0377\3")
        buf.write("\2\2\2r\u0379\3\2\2\2t\u037b\3\2\2\2v\u037d\3\2\2\2x\u037f")
        buf.write("\3\2\2\2z\u0383\3\2\2\2|\u0388\3\2\2\2~\u038c\3\2\2\2")
        buf.write("\u0080\u038e\3\2\2\2\u0082\u0083\5\4\3\2\u0083\3\3\2\2")
        buf.write("\2\u0084\u008a\5\b\5\2\u0085\u0086\5\6\4\2\u0086\u0087")
        buf.write("\5\b\5\2\u0087\u0089\3\2\2\2\u0088\u0085\3\2\2\2\u0089")
        buf.write("\u008c\3\2\2\2\u008a\u0088\3\2\2\2\u008a\u008b\3\2\2\2")
        buf.write("\u008b\5\3\2\2\2\u008c\u008a\3\2\2\2\u008d\u008e\7\u00bb")
        buf.write("\2\2\u008e\u0093\7\13\2\2\u008f\u0090\7\u00bb\2\2\u0090")
        buf.write("\u0093\7\67\2\2\u0091\u0093\7\u00bb\2\2\u0092\u008d\3")
        buf.write("\2\2\2\u0092\u008f\3\2\2\2\u0092\u0091\3\2\2\2\u0093\7")
        buf.write("\3\2\2\2\u0094\u009a\5\n\6\2\u0095\u0096\7\u00e5\2\2\u0096")
        buf.write("\u0097\5\4\3\2\u0097\u0098\7\u00ef\2\2\u0098\u009a\3\2")
        buf.write("\2\2\u0099\u0094\3\2\2\2\u0099\u0095\3\2\2\2\u009a\t\3")
        buf.write("\2\2\2\u009b\u009d\5\20\t\2\u009c\u009b\3\2\2\2\u009c")
        buf.write("\u009d\3\2\2\2\u009d\u009e\3\2\2\2\u009e\u00a0\5\16\b")
        buf.write("\2\u009f\u00a1\5\24\13\2\u00a0\u009f\3\2\2\2\u00a0\u00a1")
        buf.write("\3\2\2\2\u00a1\u00a3\3\2\2\2\u00a2\u00a4\5\26\f\2\u00a3")
        buf.write("\u00a2\3\2\2\2\u00a3\u00a4\3\2\2\2\u00a4\u00a6\3\2\2\2")
        buf.write("\u00a5\u00a7\5\30\r\2\u00a6\u00a5\3\2\2\2\u00a6\u00a7")
        buf.write("\3\2\2\2\u00a7\u00a9\3\2\2\2\u00a8\u00aa\5\32\16\2\u00a9")
        buf.write("\u00a8\3\2\2\2\u00a9\u00aa\3\2\2\2\u00aa\u00ac\3\2\2\2")
        buf.write("\u00ab\u00ad\5\34\17\2\u00ac\u00ab\3\2\2\2\u00ac\u00ad")
        buf.write("\3\2\2\2\u00ad\u00af\3\2\2\2\u00ae\u00b0\5\36\20\2\u00af")
        buf.write("\u00ae\3\2\2\2\u00af\u00b0\3\2\2\2\u00b0\u00b2\3\2\2\2")
        buf.write("\u00b1\u00b3\5 \21\2\u00b2\u00b1\3\2\2\2\u00b2\u00b3\3")
        buf.write("\2\2\2\u00b3\u00b5\3\2\2\2\u00b4\u00b6\5\"\22\2\u00b5")
        buf.write("\u00b4\3\2\2\2\u00b5\u00b6\3\2\2\2\u00b6\u00b8\3\2\2\2")
        buf.write("\u00b7\u00b9\5$\23\2\u00b8\u00b7\3\2\2\2\u00b8\u00b9\3")
        buf.write("\2\2\2\u00b9\u00bb\3\2\2\2\u00ba\u00bc\5&\24\2\u00bb\u00ba")
        buf.write("\3\2\2\2\u00bb\u00bc\3\2\2\2\u00bc\u00be\3\2\2\2\u00bd")
        buf.write("\u00bf\5(\25\2\u00be\u00bd\3\2\2\2\u00be\u00bf\3\2\2\2")
        buf.write("\u00bf\u00c1\3\2\2\2\u00c0\u00c2\5\f\7\2\u00c1\u00c0\3")
        buf.write("\2\2\2\u00c1\u00c2\3\2\2\2\u00c2\13\3\2\2\2\u00c3\u00c4")
        buf.write("\7G\2\2\u00c4\u00c5\5|?\2\u00c5\r\3\2\2\2\u00c6\u00c8")
        buf.write("\7\u0098\2\2\u00c7\u00c9\7\67\2\2\u00c8\u00c7\3\2\2\2")
        buf.write("\u00c8\u00c9\3\2\2\2\u00c9\u00cb\3\2\2\2\u00ca\u00cc\5")
        buf.write("\22\n\2\u00cb\u00ca\3\2\2\2\u00cb\u00cc\3\2\2\2\u00cc")
        buf.write("\u00cd\3\2\2\2\u00cd\u00ce\5F$\2\u00ce\17\3\2\2\2\u00cf")
        buf.write("\u00d0\7\u00ca\2\2\u00d0\u00d1\5F$\2\u00d1\21\3\2\2\2")
        buf.write("\u00d2\u00d3\7\u00b3\2\2\u00d3\u00d6\7\u00d1\2\2\u00d4")
        buf.write("\u00d5\7\u00ca\2\2\u00d5\u00d7\7\u00af\2\2\u00d6\u00d4")
        buf.write("\3\2\2\2\u00d6\u00d7\3\2\2\2\u00d7\23\3\2\2\2\u00d8\u00d9")
        buf.write("\7I\2\2\u00d9\u00da\5,\27\2\u00da\25\3\2\2\2\u00db\u00dd")
        buf.write("\t\2\2\2\u00dc\u00db\3\2\2\2\u00dc\u00dd\3\2\2\2\u00dd")
        buf.write("\u00de\3\2\2\2\u00de\u00df\7\20\2\2\u00df\u00e0\7a\2\2")
        buf.write("\u00e0\u00e1\5F$\2\u00e1\27\3\2\2\2\u00e2\u00e3\7\u008a")
        buf.write("\2\2\u00e3\u00e4\5N(\2\u00e4\31\3\2\2\2\u00e5\u00e6\7")
        buf.write("\u00c9\2\2\u00e6\u00e7\5N(\2\u00e7\33\3\2\2\2\u00e8\u00e9")
        buf.write("\7O\2\2\u00e9\u00ea\7\31\2\2\u00ea\u00eb\t\3\2\2\u00eb")
        buf.write("\u00ec\7\u00e5\2\2\u00ec\u00ed\5F$\2\u00ed\u00ef\7\u00ef")
        buf.write("\2\2\u00ee\u00f0\5*\26\2\u00ef\u00ee\3\2\2\2\u00ef\u00f0")
        buf.write("\3\2\2\2\u00f0\u00f8\3\2\2\2\u00f1\u00f2\7O\2\2\u00f2")
        buf.write("\u00f3\7\31\2\2\u00f3\u00f5\5F$\2\u00f4\u00f6\5*\26\2")
        buf.write("\u00f5\u00f4\3\2\2\2\u00f5\u00f6\3\2\2\2\u00f6\u00f8\3")
        buf.write("\2\2\2\u00f7\u00e8\3\2\2\2\u00f7\u00f1\3\2\2\2\u00f8\35")
        buf.write("\3\2\2\2\u00f9\u00fa\7P\2\2\u00fa\u00fb\5N(\2\u00fb\37")
        buf.write("\3\2\2\2\u00fc\u00fd\7\u0081\2\2\u00fd\u00fe\7\31\2\2")
        buf.write("\u00fe\u00ff\58\35\2\u00ff!\3\2\2\2\u0100\u0101\7j\2\2")
        buf.write("\u0101\u0102\5\66\34\2\u0102\u0103\7\31\2\2\u0103\u0104")
        buf.write("\5F$\2\u0104#\3\2\2\2\u0105\u0106\7j\2\2\u0106\u0109\5")
        buf.write("\66\34\2\u0107\u0108\7\u00ca\2\2\u0108\u010a\7\u00af\2")
        buf.write("\2\u0109\u0107\3\2\2\2\u0109\u010a\3\2\2\2\u010a%\3\2")
        buf.write("\2\2\u010b\u010c\7\u00ab\2\2\u010c\u010d\5j\66\2\u010d")
        buf.write("\u010e\7O\2\2\u010e\u010f\5F$\2\u010f\u0110\7\u0081\2")
        buf.write("\2\u0110\u0112\5F$\2\u0111\u0113\t\4\2\2\u0112\u0111\3")
        buf.write("\2\2\2\u0112\u0113\3\2\2\2\u0113\'\3\2\2\2\u0114\u0115")
        buf.write("\7\u009c\2\2\u0115\u0116\5> \2\u0116)\3\2\2\2\u0117\u0118")
        buf.write("\7\u00ca\2\2\u0118\u011e\7\'\2\2\u0119\u011a\7\u00ca\2")
        buf.write("\2\u011a\u011e\7\u0095\2\2\u011b\u011c\7\u00ca\2\2\u011c")
        buf.write("\u011e\7\u00b4\2\2\u011d\u0117\3\2\2\2\u011d\u0119\3\2")
        buf.write("\2\2\u011d\u011b\3\2\2\2\u011e+\3\2\2\2\u011f\u0120\b")
        buf.write("\27\1\2\u0120\u0122\5Z.\2\u0121\u0123\7C\2\2\u0122\u0121")
        buf.write("\3\2\2\2\u0122\u0123\3\2\2\2\u0123\u0125\3\2\2\2\u0124")
        buf.write("\u0126\5\64\33\2\u0125\u0124\3\2\2\2\u0125\u0126\3\2\2")
        buf.write("\2\u0126\u012c\3\2\2\2\u0127\u0128\7\u00e5\2\2\u0128\u0129")
        buf.write("\5,\27\2\u0129\u012a\7\u00ef\2\2\u012a\u012c\3\2\2\2\u012b")
        buf.write("\u011f\3\2\2\2\u012b\u0127\3\2\2\2\u012c\u013e\3\2\2\2")
        buf.write("\u012d\u012e\f\5\2\2\u012e\u012f\5\60\31\2\u012f\u0130")
        buf.write("\5,\27\6\u0130\u013d\3\2\2\2\u0131\u0133\f\6\2\2\u0132")
        buf.write("\u0134\t\5\2\2\u0133\u0132\3\2\2\2\u0133\u0134\3\2\2\2")
        buf.write("\u0134\u0136\3\2\2\2\u0135\u0137\5.\30\2\u0136\u0135\3")
        buf.write("\2\2\2\u0136\u0137\3\2\2\2\u0137\u0138\3\2\2\2\u0138\u0139")
        buf.write("\7a\2\2\u0139\u013a\5,\27\2\u013a\u013b\5\62\32\2\u013b")
        buf.write("\u013d\3\2\2\2\u013c\u012d\3\2\2\2\u013c\u0131\3\2\2\2")
        buf.write("\u013d\u0140\3\2\2\2\u013e\u013c\3\2\2\2\u013e\u013f\3")
        buf.write("\2\2\2\u013f-\3\2\2\2\u0140\u013e\3\2\2\2\u0141\u0143")
        buf.write("\t\6\2\2\u0142\u0141\3\2\2\2\u0142\u0143\3\2\2\2\u0143")
        buf.write("\u0144\3\2\2\2\u0144\u0167\7[\2\2\u0145\u0147\7[\2\2\u0146")
        buf.write("\u0148\t\6\2\2\u0147\u0146\3\2\2\2\u0147\u0148\3\2\2\2")
        buf.write("\u0148\u0167\3\2\2\2\u0149\u0167\t\6\2\2\u014a\u014c\t")
        buf.write("\7\2\2\u014b\u014a\3\2\2\2\u014b\u014c\3\2\2\2\u014c\u014d")
        buf.write("\3\2\2\2\u014d\u014f\t\b\2\2\u014e\u0150\7\u0082\2\2\u014f")
        buf.write("\u014e\3\2\2\2\u014f\u0150\3\2\2\2\u0150\u0167\3\2\2\2")
        buf.write("\u0151\u0153\t\b\2\2\u0152\u0154\7\u0082\2\2\u0153\u0152")
        buf.write("\3\2\2\2\u0153\u0154\3\2\2\2\u0154\u0156\3\2\2\2\u0155")
        buf.write("\u0157\t\7\2\2\u0156\u0155\3\2\2\2\u0156\u0157\3\2\2\2")
        buf.write("\u0157\u0167\3\2\2\2\u0158\u015a\t\t\2\2\u0159\u0158\3")
        buf.write("\2\2\2\u0159\u015a\3\2\2\2\u015a\u015b\3\2\2\2\u015b\u015d")
        buf.write("\7J\2\2\u015c\u015e\7\u0082\2\2\u015d\u015c\3\2\2\2\u015d")
        buf.write("\u015e\3\2\2\2\u015e\u0167\3\2\2\2\u015f\u0161\7J\2\2")
        buf.write("\u0160\u0162\7\u0082\2\2\u0161\u0160\3\2\2\2\u0161\u0162")
        buf.write("\3\2\2\2\u0162\u0164\3\2\2\2\u0163\u0165\t\t\2\2\u0164")
        buf.write("\u0163\3\2\2\2\u0164\u0165\3\2\2\2\u0165\u0167\3\2\2\2")
        buf.write("\u0166\u0142\3\2\2\2\u0166\u0145\3\2\2\2\u0166\u0149\3")
        buf.write("\2\2\2\u0166\u014b\3\2\2\2\u0166\u0151\3\2\2\2\u0166\u0159")
        buf.write("\3\2\2\2\u0166\u015f\3\2\2\2\u0167/\3\2\2\2\u0168\u016a")
        buf.write("\t\5\2\2\u0169\u0168\3\2\2\2\u0169\u016a\3\2\2\2\u016a")
        buf.write("\u016b\3\2\2\2\u016b\u016c\7&\2\2\u016c\u016f\7a\2\2\u016d")
        buf.write("\u016f\7\u00da\2\2\u016e\u0169\3\2\2\2\u016e\u016d\3\2")
        buf.write("\2\2\u016f\61\3\2\2\2\u0170\u0171\7~\2\2\u0171\u017a\5")
        buf.write("F$\2\u0172\u0173\7\u00be\2\2\u0173\u0174\7\u00e5\2\2\u0174")
        buf.write("\u0175\5F$\2\u0175\u0176\7\u00ef\2\2\u0176\u017a\3\2\2")
        buf.write("\2\u0177\u0178\7\u00be\2\2\u0178\u017a\5F$\2\u0179\u0170")
        buf.write("\3\2\2\2\u0179\u0172\3\2\2\2\u0179\u0177\3\2\2\2\u017a")
        buf.write("\63\3\2\2\2\u017b\u017c\7\u0096\2\2\u017c\u017f\5<\37")
        buf.write("\2\u017d\u017e\7}\2\2\u017e\u0180\5<\37\2\u017f\u017d")
        buf.write("\3\2\2\2\u017f\u0180\3\2\2\2\u0180\65\3\2\2\2\u0181\u0184")
        buf.write("\5N(\2\u0182\u0183\t\n\2\2\u0183\u0185\5N(\2\u0184\u0182")
        buf.write("\3\2\2\2\u0184\u0185\3\2\2\2\u0185\67\3\2\2\2\u0186\u018b")
        buf.write("\5:\36\2\u0187\u0188\7\u00da\2\2\u0188\u018a\5:\36\2\u0189")
        buf.write("\u0187\3\2\2\2\u018a\u018d\3\2\2\2\u018b\u0189\3\2\2\2")
        buf.write("\u018b\u018c\3\2\2\2\u018c9\3\2\2\2\u018d\u018b\3\2\2")
        buf.write("\2\u018e\u0190\5N(\2\u018f\u0191\t\13\2\2\u0190\u018f")
        buf.write("\3\2\2\2\u0190\u0191\3\2\2\2\u0191\u0194\3\2\2\2\u0192")
        buf.write("\u0193\7|\2\2\u0193\u0195\t\f\2\2\u0194\u0192\3\2\2\2")
        buf.write("\u0194\u0195\3\2\2\2\u0195\u0198\3\2\2\2\u0196\u0197\7")
        buf.write(" \2\2\u0197\u0199\7\u00d3\2\2\u0198\u0196\3\2\2\2\u0198")
        buf.write("\u0199\3\2\2\2\u0199;\3\2\2\2\u019a\u019d\5j\66\2\u019b")
        buf.write("\u019c\7\u00f1\2\2\u019c\u019e\5j\66\2\u019d\u019b\3\2")
        buf.write("\2\2\u019d\u019e\3\2\2\2\u019e=\3\2\2\2\u019f\u01a4\5")
        buf.write("@!\2\u01a0\u01a1\7\u00da\2\2\u01a1\u01a3\5@!\2\u01a2\u01a0")
        buf.write("\3\2\2\2\u01a3\u01a6\3\2\2\2\u01a4\u01a2\3\2\2\2\u01a4")
        buf.write("\u01a5\3\2\2\2\u01a5?\3\2\2\2\u01a6\u01a4\3\2\2\2\u01a7")
        buf.write("\u01a8\5|?\2\u01a8\u01a9\7\u00df\2\2\u01a9\u01aa\5l\67")
        buf.write("\2\u01aaA\3\2\2\2\u01ab\u01db\5|?\2\u01ac\u01ad\5|?\2")
        buf.write("\u01ad\u01ae\7\u00e5\2\2\u01ae\u01af\5|?\2\u01af\u01b4")
        buf.write("\5B\"\2\u01b0\u01b1\7\u00da\2\2\u01b1\u01b3\5D#\2\u01b2")
        buf.write("\u01b0\3\2\2\2\u01b3\u01b6\3\2\2\2\u01b4\u01b2\3\2\2\2")
        buf.write("\u01b4\u01b5\3\2\2\2\u01b5\u01b7\3\2\2\2\u01b6\u01b4\3")
        buf.write("\2\2\2\u01b7\u01b8\7\u00ef\2\2\u01b8\u01db\3\2\2\2\u01b9")
        buf.write("\u01ba\5|?\2\u01ba\u01bb\7\u00e5\2\2\u01bb\u01c0\5\u0080")
        buf.write("A\2\u01bc\u01bd\7\u00da\2\2\u01bd\u01bf\5\u0080A\2\u01be")
        buf.write("\u01bc\3\2\2\2\u01bf\u01c2\3\2\2\2\u01c0\u01be\3\2\2\2")
        buf.write("\u01c0\u01c1\3\2\2\2\u01c1\u01c3\3\2\2\2\u01c2\u01c0\3")
        buf.write("\2\2\2\u01c3\u01c4\7\u00ef\2\2\u01c4\u01db\3\2\2\2\u01c5")
        buf.write("\u01c6\5t;\2\u01c6\u01c8\7\u00e5\2\2\u01c7\u01c9\5F$\2")
        buf.write("\u01c8\u01c7\3\2\2\2\u01c8\u01c9\3\2\2\2\u01c9\u01ca\3")
        buf.write("\2\2\2\u01ca\u01cb\7\u00ef\2\2\u01cb\u01db\3\2\2\2\u01cc")
        buf.write("\u01cd\5r:\2\u01cd\u01cf\7\u00e5\2\2\u01ce\u01d0\5F$\2")
        buf.write("\u01cf\u01ce\3\2\2\2\u01cf\u01d0\3\2\2\2\u01d0\u01d1\3")
        buf.write("\2\2\2\u01d1\u01d2\7\u00ef\2\2\u01d2\u01db\3\2\2\2\u01d3")
        buf.write("\u01d4\5|?\2\u01d4\u01d6\7\u00e5\2\2\u01d5\u01d7\5F$\2")
        buf.write("\u01d6\u01d5\3\2\2\2\u01d6\u01d7\3\2\2\2\u01d7\u01d8\3")
        buf.write("\2\2\2\u01d8\u01d9\7\u00ef\2\2\u01d9\u01db\3\2\2\2\u01da")
        buf.write("\u01ab\3\2\2\2\u01da\u01ac\3\2\2\2\u01da\u01b9\3\2\2\2")
        buf.write("\u01da\u01c5\3\2\2\2\u01da\u01cc\3\2\2\2\u01da\u01d3\3")
        buf.write("\2\2\2\u01dbC\3\2\2\2\u01dc\u01dd\5|?\2\u01dd\u01de\5")
        buf.write("B\"\2\u01deE\3\2\2\2\u01df\u01e4\5J&\2\u01e0\u01e1\7\u00da")
        buf.write("\2\2\u01e1\u01e3\5J&\2\u01e2\u01e0\3\2\2\2\u01e3\u01e6")
        buf.write("\3\2\2\2\u01e4\u01e2\3\2\2\2\u01e4\u01e5\3\2\2\2\u01e5")
        buf.write("G\3\2\2\2\u01e6\u01e4\3\2\2\2\u01e7\u01e8\7\u00c8\2\2")
        buf.write("\u01e8\u01e9\5N(\2\u01e9\u01ea\7\u00ae\2\2\u01ea\u01eb")
        buf.write("\5N(\2\u01ebI\3\2\2\2\u01ec\u01ed\5`\61\2\u01ed\u01ee")
        buf.write("\7\u00dd\2\2\u01ee\u01f0\3\2\2\2\u01ef\u01ec\3\2\2\2\u01ef")
        buf.write("\u01f0\3\2\2\2\u01f0\u01f1\3\2\2\2\u01f1\u01f8\7\u00d5")
        buf.write("\2\2\u01f2\u01f3\7\u00e5\2\2\u01f3\u01f4\5\4\3\2\u01f4")
        buf.write("\u01f5\7\u00ef\2\2\u01f5\u01f8\3\2\2\2\u01f6\u01f8\5N")
        buf.write("(\2\u01f7\u01ef\3\2\2\2\u01f7\u01f2\3\2\2\2\u01f7\u01f6")
        buf.write("\3\2\2\2\u01f8K\3\2\2\2\u01f9\u01fb\7\32\2\2\u01fa\u01fc")
        buf.write("\5N(\2\u01fb\u01fa\3\2\2\2\u01fb\u01fc\3\2\2\2\u01fc\u01fe")
        buf.write("\3\2\2\2\u01fd\u01ff\5H%\2\u01fe\u01fd\3\2\2\2\u01ff\u0200")
        buf.write("\3\2\2\2\u0200\u01fe\3\2\2\2\u0200\u0201\3\2\2\2\u0201")
        buf.write("\u0204\3\2\2\2\u0202\u0203\7:\2\2\u0203\u0205\5N(\2\u0204")
        buf.write("\u0202\3\2\2\2\u0204\u0205\3\2\2\2\u0205\u0206\3\2\2\2")
        buf.write("\u0206\u0207\7;\2\2\u0207M\3\2\2\2\u0208\u0209\b(\1\2")
        buf.write("\u0209\u0292\5L\'\2\u020a\u020b\7\33\2\2\u020b\u020c\7")
        buf.write("\u00e5\2\2\u020c\u020d\5N(\2\u020d\u020e\7\21\2\2\u020e")
        buf.write("\u020f\5B\"\2\u020f\u0210\7\u00ef\2\2\u0210\u0292\3\2")
        buf.write("\2\2\u0211\u0212\7*\2\2\u0212\u0292\7\u00d3\2\2\u0213")
        buf.write("\u0214\7A\2\2\u0214\u0215\7\u00e5\2\2\u0215\u0216\5n8")
        buf.write("\2\u0216\u0217\7I\2\2\u0217\u0218\5N(\2\u0218\u0219\7")
        buf.write("\u00ef\2\2\u0219\u0292\3\2\2\2\u021a\u021b\7]\2\2\u021b")
        buf.write("\u021c\5N(\2\u021c\u021d\5n8\2\u021d\u0292\3\2\2\2\u021e")
        buf.write("\u021f\7\u00a4\2\2\u021f\u0220\7\u00e5\2\2\u0220\u0221")
        buf.write("\5N(\2\u0221\u0222\7I\2\2\u0222\u0225\5N(\2\u0223\u0224")
        buf.write("\7F\2\2\u0224\u0226\5N(\2\u0225\u0223\3\2\2\2\u0225\u0226")
        buf.write("\3\2\2\2\u0226\u0227\3\2\2\2\u0227\u0228\7\u00ef\2\2\u0228")
        buf.write("\u0292\3\2\2\2\u0229\u022a\7\u00b1\2\2\u022a\u0292\7\u00d3")
        buf.write("\2\2\u022b\u022c\7\u00b6\2\2\u022c\u022d\7\u00e5\2\2\u022d")
        buf.write("\u022e\t\r\2\2\u022e\u022f\7\u00d3\2\2\u022f\u0230\7I")
        buf.write("\2\2\u0230\u0231\5N(\2\u0231\u0232\7\u00ef\2\2\u0232\u0292")
        buf.write("\3\2\2\2\u0233\u0234\7\u00a5\2\2\u0234\u0235\7\u00e5\2")
        buf.write("\2\u0235\u0236\5L\'\2\u0236\u0237\7\u00ef\2\2\u0237\u0292")
        buf.write("\3\2\2\2\u0238\u0239\5p9\2\u0239\u023b\7\u00e5\2\2\u023a")
        buf.write("\u023c\7\67\2\2\u023b\u023a\3\2\2\2\u023b\u023c\3\2\2")
        buf.write("\2\u023c\u023e\3\2\2\2\u023d\u023f\7\13\2\2\u023e\u023d")
        buf.write("\3\2\2\2\u023e\u023f\3\2\2\2\u023f\u0241\3\2\2\2\u0240")
        buf.write("\u0242\5P)\2\u0241\u0240\3\2\2\2\u0241\u0242\3\2\2\2\u0242")
        buf.write("\u0243\3\2\2\2\u0243\u0244\7\u00ef\2\2\u0244\u0292\3\2")
        buf.write("\2\2\u0245\u0246\t\16\2\2\u0246\u0247\7\u00e5\2\2\u0247")
        buf.write("\u0248\5N(\2\u0248\u0249\7\u00da\2\2\u0249\u024a\5N(\2")
        buf.write("\u024a\u024b\7\u00da\2\2\u024b\u024c\5N(\2\u024c\u024d")
        buf.write("\7\u00ef\2\2\u024d\u0292\3\2\2\2\u024e\u024f\7w\2\2\u024f")
        buf.write("\u0250\7\u00e5\2\2\u0250\u0251\5P)\2\u0251\u0252\7\u00ef")
        buf.write("\2\2\u0252\u0292\3\2\2\2\u0253\u0254\t\17\2\2\u0254\u0255")
        buf.write("\7\u00e5\2\2\u0255\u0256\5N(\2\u0256\u0259\7\u00da\2\2")
        buf.write("\u0257\u025a\5j\66\2\u0258\u025a\7{\2\2\u0259\u0257\3")
        buf.write("\2\2\2\u0259\u0258\3\2\2\2\u025a\u025b\3\2\2\2\u025b\u025c")
        buf.write("\7\u00ef\2\2\u025c\u0292\3\2\2\2\u025d\u0263\5|?\2\u025e")
        buf.write("\u0260\7\u00e5\2\2\u025f\u0261\5F$\2\u0260\u025f\3\2\2")
        buf.write("\2\u0260\u0261\3\2\2\2\u0261\u0262\3\2\2\2\u0262\u0264")
        buf.write("\7\u00ef\2\2\u0263\u025e\3\2\2\2\u0263\u0264\3\2\2\2\u0264")
        buf.write("\u0265\3\2\2\2\u0265\u0267\7\u00e5\2\2\u0266\u0268\7\67")
        buf.write("\2\2\u0267\u0266\3\2\2\2\u0267\u0268\3\2\2\2\u0268\u026a")
        buf.write("\3\2\2\2\u0269\u026b\5P)\2\u026a\u0269\3\2\2\2\u026a\u026b")
        buf.write("\3\2\2\2\u026b\u026c\3\2\2\2\u026c\u026d\7\u00ef\2\2\u026d")
        buf.write("\u0292\3\2\2\2\u026e\u0292\5l\67\2\u026f\u0270\7\u00dc")
        buf.write("\2\2\u0270\u0292\5N(\25\u0271\u0272\7z\2\2\u0272\u0292")
        buf.write("\5N(\20\u0273\u0274\5|?\2\u0274\u0275\7\21\2\2\u0275\u0276")
        buf.write("\7\u00e5\2\2\u0276\u0277\5\4\3\2\u0277\u0278\7\u00ef\2")
        buf.write("\2\u0278\u0292\3\2\2\2\u0279\u027a\5`\61\2\u027a\u027b")
        buf.write("\7\u00dd\2\2\u027b\u027d\3\2\2\2\u027c\u0279\3\2\2\2\u027c")
        buf.write("\u027d\3\2\2\2\u027d\u027e\3\2\2\2\u027e\u0292\7\u00d5")
        buf.write("\2\2\u027f\u0280\7\u00e5\2\2\u0280\u0281\5\4\3\2\u0281")
        buf.write("\u0282\7\u00ef\2\2\u0282\u0292\3\2\2\2\u0283\u0284\7\u00e5")
        buf.write("\2\2\u0284\u0285\5N(\2\u0285\u0286\7\u00ef\2\2\u0286\u0292")
        buf.write("\3\2\2\2\u0287\u0288\7\u00e5\2\2\u0288\u0289\5F$\2\u0289")
        buf.write("\u028a\7\u00ef\2\2\u028a\u0292\3\2\2\2\u028b\u028d\7\u00e3")
        buf.write("\2\2\u028c\u028e\5F$\2\u028d\u028c\3\2\2\2\u028d\u028e")
        buf.write("\3\2\2\2\u028e\u028f\3\2\2\2\u028f\u0292\7\u00ee\2\2\u0290")
        buf.write("\u0292\5V,\2\u0291\u0208\3\2\2\2\u0291\u020a\3\2\2\2\u0291")
        buf.write("\u0211\3\2\2\2\u0291\u0213\3\2\2\2\u0291\u021a\3\2\2\2")
        buf.write("\u0291\u021e\3\2\2\2\u0291\u0229\3\2\2\2\u0291\u022b\3")
        buf.write("\2\2\2\u0291\u0233\3\2\2\2\u0291\u0238\3\2\2\2\u0291\u0245")
        buf.write("\3\2\2\2\u0291\u024e\3\2\2\2\u0291\u0253\3\2\2\2\u0291")
        buf.write("\u025d\3\2\2\2\u0291\u026e\3\2\2\2\u0291\u026f\3\2\2\2")
        buf.write("\u0291\u0271\3\2\2\2\u0291\u0273\3\2\2\2\u0291\u027c\3")
        buf.write("\2\2\2\u0291\u027f\3\2\2\2\u0291\u0283\3\2\2\2\u0291\u0287")
        buf.write("\3\2\2\2\u0291\u028b\3\2\2\2\u0291\u0290\3\2\2\2\u0292")
        buf.write("\u02e1\3\2\2\2\u0293\u0294\f\24\2\2\u0294\u0295\t\20\2")
        buf.write("\2\u0295\u02e0\5N(\25\u0296\u0297\f\23\2\2\u0297\u0298")
        buf.write("\t\21\2\2\u0298\u02e0\5N(\24\u0299\u02ac\f\22\2\2\u029a")
        buf.write("\u02ad\7\u00de\2\2\u029b\u02ad\7\u00df\2\2\u029c\u02ad")
        buf.write("\7\u00e7\2\2\u029d\u02ad\7\u00e4\2\2\u029e\u02ad\7\u00e0")
        buf.write("\2\2\u029f\u02ad\7\u00e6\2\2\u02a0\u02ad\7\u00e1\2\2\u02a1")
        buf.write("\u02a3\7M\2\2\u02a2\u02a1\3\2\2\2\u02a2\u02a3\3\2\2\2")
        buf.write("\u02a3\u02a5\3\2\2\2\u02a4\u02a6\7z\2\2\u02a5\u02a4\3")
        buf.write("\2\2\2\u02a5\u02a6\3\2\2\2\u02a6\u02a7\3\2\2\2\u02a7\u02ad")
        buf.write("\7W\2\2\u02a8\u02aa\7z\2\2\u02a9\u02a8\3\2\2\2\u02a9\u02aa")
        buf.write("\3\2\2\2\u02aa\u02ab\3\2\2\2\u02ab\u02ad\t\22\2\2\u02ac")
        buf.write("\u029a\3\2\2\2\u02ac\u029b\3\2\2\2\u02ac\u029c\3\2\2\2")
        buf.write("\u02ac\u029d\3\2\2\2\u02ac\u029e\3\2\2\2\u02ac\u029f\3")
        buf.write("\2\2\2\u02ac\u02a0\3\2\2\2\u02ac\u02a2\3\2\2\2\u02ac\u02a9")
        buf.write("\3\2\2\2\u02ad\u02ae\3\2\2\2\u02ae\u02e0\5N(\23\u02af")
        buf.write("\u02b0\f\17\2\2\u02b0\u02b1\7\r\2\2\u02b1\u02e0\5N(\20")
        buf.write("\u02b2\u02b3\f\16\2\2\u02b3\u02b4\7\u0080\2\2\u02b4\u02e0")
        buf.write("\5N(\17\u02b5\u02b7\f\r\2\2\u02b6\u02b8\7z\2\2\u02b7\u02b6")
        buf.write("\3\2\2\2\u02b7\u02b8\3\2\2\2\u02b8\u02b9\3\2\2\2\u02b9")
        buf.write("\u02ba\7\27\2\2\u02ba\u02bb\5N(\2\u02bb\u02bc\7\r\2\2")
        buf.write("\u02bc\u02bd\5N(\16\u02bd\u02e0\3\2\2\2\u02be\u02bf\f")
        buf.write("\f\2\2\u02bf\u02c0\7\u00ea\2\2\u02c0\u02c1\5N(\2\u02c1")
        buf.write("\u02c2\7\u00d8\2\2\u02c2\u02c3\5N(\f\u02c3\u02e0\3\2\2")
        buf.write("\2\u02c4\u02c5\f\31\2\2\u02c5\u02c6\7\u00e2\2\2\u02c6")
        buf.write("\u02c7\7\u00d3\2\2\u02c7\u02e0\7\u00ed\2\2\u02c8\u02c9")
        buf.write("\f\27\2\2\u02c9\u02ca\7\u00e3\2\2\u02ca\u02cb\5N(\2\u02cb")
        buf.write("\u02cc\7\u00ee\2\2\u02cc\u02e0\3\2\2\2\u02cd\u02ce\f\26")
        buf.write("\2\2\u02ce\u02cf\7\u00dd\2\2\u02cf\u02e0\7\u00d1\2\2\u02d0")
        buf.write("\u02d1\f\21\2\2\u02d1\u02d3\7_\2\2\u02d2\u02d4\7z\2\2")
        buf.write("\u02d3\u02d2\3\2\2\2\u02d3\u02d4\3\2\2\2\u02d4\u02d5\3")
        buf.write("\2\2\2\u02d5\u02e0\7{\2\2\u02d6\u02da\f\13\2\2\u02d7\u02db")
        buf.write("\5z>\2\u02d8\u02d9\7\21\2\2\u02d9\u02db\5|?\2\u02da\u02d7")
        buf.write("\3\2\2\2\u02da\u02d8\3\2\2\2\u02db\u02e0\3\2\2\2\u02dc")
        buf.write("\u02dd\f\3\2\2\u02dd\u02de\7\u00d9\2\2\u02de\u02e0\5B")
        buf.write("\"\2\u02df\u0293\3\2\2\2\u02df\u0296\3\2\2\2\u02df\u0299")
        buf.write("\3\2\2\2\u02df\u02af\3\2\2\2\u02df\u02b2\3\2\2\2\u02df")
        buf.write("\u02b5\3\2\2\2\u02df\u02be\3\2\2\2\u02df\u02c4\3\2\2\2")
        buf.write("\u02df\u02c8\3\2\2\2\u02df\u02cd\3\2\2\2\u02df\u02d0\3")
        buf.write("\2\2\2\u02df\u02d6\3\2\2\2\u02df\u02dc\3\2\2\2\u02e0\u02e3")
        buf.write("\3\2\2\2\u02e1\u02df\3\2\2\2\u02e1\u02e2\3\2\2\2\u02e2")
        buf.write("O\3\2\2\2\u02e3\u02e1\3\2\2\2\u02e4\u02e9\5R*\2\u02e5")
        buf.write("\u02e6\7\u00da\2\2\u02e6\u02e8\5R*\2\u02e7\u02e5\3\2\2")
        buf.write("\2\u02e8\u02eb\3\2\2\2\u02e9\u02e7\3\2\2\2\u02e9\u02ea")
        buf.write("\3\2\2\2\u02eaQ\3\2\2\2\u02eb\u02e9\3\2\2\2\u02ec\u02ef")
        buf.write("\5T+\2\u02ed\u02ef\5N(\2\u02ee\u02ec\3\2\2\2\u02ee\u02ed")
        buf.write("\3\2\2\2\u02efS\3\2\2\2\u02f0\u02f1\7\u00e5\2\2\u02f1")
        buf.write("\u02f6\5|?\2\u02f2\u02f3\7\u00da\2\2\u02f3\u02f5\5|?\2")
        buf.write("\u02f4\u02f2\3\2\2\2\u02f5\u02f8\3\2\2\2\u02f6\u02f4\3")
        buf.write("\2\2\2\u02f6\u02f7\3\2\2\2\u02f7\u02f9\3\2\2\2\u02f8\u02f6")
        buf.write("\3\2\2\2\u02f9\u02fa\7\u00ef\2\2\u02fa\u0304\3\2\2\2\u02fb")
        buf.write("\u0300\5|?\2\u02fc\u02fd\7\u00da\2\2\u02fd\u02ff\5|?\2")
        buf.write("\u02fe\u02fc\3\2\2\2\u02ff\u0302\3\2\2\2\u0300\u02fe\3")
        buf.write("\2\2\2\u0300\u0301\3\2\2\2\u0301\u0304\3\2\2\2\u0302\u0300")
        buf.write("\3\2\2\2\u0303\u02f0\3\2\2\2\u0303\u02fb\3\2\2\2\u0304")
        buf.write("\u0305\3\2\2\2\u0305\u0306\7\u00d4\2\2\u0306\u0307\5N")
        buf.write("(\2\u0307U\3\2\2\2\u0308\u0309\5`\61\2\u0309\u030a\7\u00dd")
        buf.write("\2\2\u030a\u030c\3\2\2\2\u030b\u0308\3\2\2\2\u030b\u030c")
        buf.write("\3\2\2\2\u030c\u030d\3\2\2\2\u030d\u030e\5X-\2\u030eW")
        buf.write("\3\2\2\2\u030f\u0312\5|?\2\u0310\u0311\7\u00dd\2\2\u0311")
        buf.write("\u0313\5|?\2\u0312\u0310\3\2\2\2\u0312\u0313\3\2\2\2\u0313")
        buf.write("Y\3\2\2\2\u0314\u0315\b.\1\2\u0315\u031d\5`\61\2\u0316")
        buf.write("\u031d\5^\60\2\u0317\u0318\7\u00e5\2\2\u0318\u0319\5\4")
        buf.write("\3\2\u0319\u031a\7\u00ef\2\2\u031a\u031d\3\2\2\2\u031b")
        buf.write("\u031d\5\\/\2\u031c\u0314\3\2\2\2\u031c\u0316\3\2\2\2")
        buf.write("\u031c\u0317\3\2\2\2\u031c\u031b\3\2\2\2\u031d\u0326\3")
        buf.write("\2\2\2\u031e\u0322\f\4\2\2\u031f\u0323\5z>\2\u0320\u0321")
        buf.write("\7\21\2\2\u0321\u0323\5|?\2\u0322\u031f\3\2\2\2\u0322")
        buf.write("\u0320\3\2\2\2\u0323\u0325\3\2\2\2\u0324\u031e\3\2\2\2")
        buf.write("\u0325\u0328\3\2\2\2\u0326\u0324\3\2\2\2\u0326\u0327\3")
        buf.write("\2\2\2\u0327[\3\2\2\2\u0328\u0326\3\2\2\2\u0329\u032a")
        buf.write("\7L\2\2\u032a\u032b\7\u00e5\2\2\u032b\u032c\5f\64\2\u032c")
        buf.write("\u032d\7\u00da\2\2\u032d\u032e\5`\61\2\u032e\u032f\7\u00da")
        buf.write("\2\2\u032f\u0330\5`\61\2\u0330\u0331\7\u00da\2\2\u0331")
        buf.write("\u0332\5N(\2\u0332\u0333\7\u00da\2\2\u0333\u0334\5N(\2")
        buf.write("\u0334\u0335\7\u00da\2\2\u0335\u0336\5N(\2\u0336\u0337")
        buf.write("\7\u00da\2\2\u0337\u0338\5N(\2\u0338\u033c\7\u00ef\2\2")
        buf.write("\u0339\u033d\5z>\2\u033a\u033b\7\21\2\2\u033b\u033d\5")
        buf.write("|?\2\u033c\u0339\3\2\2\2\u033c\u033a\3\2\2\2\u033c\u033d")
        buf.write("\3\2\2\2\u033d]\3\2\2\2\u033e\u033f\5|?\2\u033f\u0341")
        buf.write("\7\u00e5\2\2\u0340\u0342\5b\62\2\u0341\u0340\3\2\2\2\u0341")
        buf.write("\u0342\3\2\2\2\u0342\u0343\3\2\2\2\u0343\u0344\7\u00ef")
        buf.write("\2\2\u0344_\3\2\2\2\u0345\u0346\5f\64\2\u0346\u0347\7")
        buf.write("\u00dd\2\2\u0347\u0349\3\2\2\2\u0348\u0345\3\2\2\2\u0348")
        buf.write("\u0349\3\2\2\2\u0349\u034a\3\2\2\2\u034a\u034b\5|?\2\u034b")
        buf.write("a\3\2\2\2\u034c\u0351\5d\63\2\u034d\u034e\7\u00da\2\2")
        buf.write("\u034e\u0350\5d\63\2\u034f\u034d\3\2\2\2\u0350\u0353\3")
        buf.write("\2\2\2\u0351\u034f\3\2\2\2\u0351\u0352\3\2\2\2\u0352c")
        buf.write("\3\2\2\2\u0353\u0351\3\2\2\2\u0354\u0358\5`\61\2\u0355")
        buf.write("\u0358\5^\60\2\u0356\u0358\5l\67\2\u0357\u0354\3\2\2\2")
        buf.write("\u0357\u0355\3\2\2\2\u0357\u0356\3\2\2\2\u0358e\3\2\2")
        buf.write("\2\u0359\u035a\5|?\2\u035ag\3\2\2\2\u035b\u0364\7\u00cf")
        buf.write("\2\2\u035c\u035d\7\u00dd\2\2\u035d\u0364\t\23\2\2\u035e")
        buf.write("\u035f\7\u00d1\2\2\u035f\u0361\7\u00dd\2\2\u0360\u0362")
        buf.write("\t\23\2\2\u0361\u0360\3\2\2\2\u0361\u0362\3\2\2\2\u0362")
        buf.write("\u0364\3\2\2\2\u0363\u035b\3\2\2\2\u0363\u035c\3\2\2\2")
        buf.write("\u0363\u035e\3\2\2\2\u0364i\3\2\2\2\u0365\u0367\t\24\2")
        buf.write("\2\u0366\u0365\3\2\2\2\u0366\u0367\3\2\2\2\u0367\u036e")
        buf.write("\3\2\2\2\u0368\u036f\5h\65\2\u0369\u036f\7\u00d0\2\2\u036a")
        buf.write("\u036f\7\u00d1\2\2\u036b\u036f\7\u00d2\2\2\u036c\u036f")
        buf.write("\7Y\2\2\u036d\u036f\7x\2\2\u036e\u0368\3\2\2\2\u036e\u0369")
        buf.write("\3\2\2\2\u036e\u036a\3\2\2\2\u036e\u036b\3\2\2\2\u036e")
        buf.write("\u036c\3\2\2\2\u036e\u036d\3\2\2\2\u036fk\3\2\2\2\u0370")
        buf.write("\u0374\5j\66\2\u0371\u0374\7\u00d3\2\2\u0372\u0374\7{")
        buf.write("\2\2\u0373\u0370\3\2\2\2\u0373\u0371\3\2\2\2\u0373\u0372")
        buf.write("\3\2\2\2\u0374m\3\2\2\2\u0375\u0376\t\25\2\2\u0376o\3")
        buf.write("\2\2\2\u0377\u0378\t\26\2\2\u0378q\3\2\2\2\u0379\u037a")
        buf.write("\t\27\2\2\u037as\3\2\2\2\u037b\u037c\t\30\2\2\u037cu\3")
        buf.write("\2\2\2\u037d\u037e\t\31\2\2\u037ew\3\2\2\2\u037f\u0380")
        buf.write("\t\32\2\2\u0380y\3\2\2\2\u0381\u0384\7\u00ce\2\2\u0382")
        buf.write("\u0384\5x=\2\u0383\u0381\3\2\2\2\u0383\u0382\3\2\2\2\u0384")
        buf.write("{\3\2\2\2\u0385\u0389\7\u00ce\2\2\u0386\u0389\5n8\2\u0387")
        buf.write("\u0389\5v<\2\u0388\u0385\3\2\2\2\u0388\u0386\3\2\2\2\u0388")
        buf.write("\u0387\3\2\2\2\u0389}\3\2\2\2\u038a\u038d\5|?\2\u038b")
        buf.write("\u038d\7{\2\2\u038c\u038a\3\2\2\2\u038c\u038b\3\2\2\2")
        buf.write("\u038d\177\3\2\2\2\u038e\u038f\7\u00d3\2\2\u038f\u0390")
        buf.write("\7\u00df\2\2\u0390\u0391\5j\66\2\u0391\u0081\3\2\2\2q")
        buf.write("\u008a\u0092\u0099\u009c\u00a0\u00a3\u00a6\u00a9\u00ac")
        buf.write("\u00af\u00b2\u00b5\u00b8\u00bb\u00be\u00c1\u00c8\u00cb")
        buf.write("\u00d6\u00dc\u00ef\u00f5\u00f7\u0109\u0112\u011d\u0122")
        buf.write("\u0125\u012b\u0133\u0136\u013c\u013e\u0142\u0147\u014b")
        buf.write("\u014f\u0153\u0156\u0159\u015d\u0161\u0164\u0166\u0169")
        buf.write("\u016e\u0179\u017f\u0184\u018b\u0190\u0194\u0198\u019d")
        buf.write("\u01a4\u01b4\u01c0\u01c8\u01cf\u01d6\u01da\u01e4\u01ef")
        buf.write("\u01f7\u01fb\u0200\u0204\u0225\u023b\u023e\u0241\u0259")
        buf.write("\u0260\u0263\u0267\u026a\u027c\u028d\u0291\u02a2\u02a5")
        buf.write("\u02a9\u02ac\u02b7\u02d3\u02da\u02df\u02e1\u02e9\u02ee")
        buf.write("\u02f6\u0300\u0303\u030b\u0312\u031c\u0322\u0326\u033c")
        buf.write("\u0341\u0348\u0351\u0357\u0361\u0363\u0366\u036e\u0373")
        buf.write("\u0383\u0388\u038c")
        return buf.getvalue()


class ClickHouseParser ( Parser ):

    grammarFileName = "ClickHouse.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'Decimal'", "'Decimal32'", "'Decimal64'", 
                     "'Decimal128'", "'Decimal256'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'false'", "'true'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'->'", "'*'", "'`'", "'\\'", "':'", "'::'", 
                     "','", "'||'", "'-'", "'.'", "'=='", "'='", "'>='", 
                     "'>'", "'{'", "'['", "'<='", "'('", "'<'", "<INVALID>", 
                     "'%'", "'+'", "'?'", "'\"'", "'''", "'}'", "']'", "')'", 
                     "';'", "'/'", "'_'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "ADD", "AFTER", "ALIAS", 
                      "ALL", "ALTER", "AND", "ANTI", "ANY", "ARRAY", "AS", 
                      "ASCENDING", "ASOF", "ASYNC", "ATTACH", "AVG", "BETWEEN", 
                      "BOTH", "BY", "CASE", "CAST", "CHECK", "CLEAR", "CLUSTER", 
                      "CODEC", "COLLATE", "COLUMN", "COMMENT", "CONSTRAINT", 
                      "COUNT", "CREATE", "CROSS", "CUBE", "DATABASE", "DATABASES", 
                      "DATE", "DAY", "DEDUPLICATE", "DEFAULT", "DELAY", 
                      "DELETE", "DESC", "DESCENDING", "DESCRIBE", "DETACH", 
                      "DICTIONARIES", "DICTIONARY", "DISK", "DISTINCT", 
                      "DISTRIBUTED", "DROP", "ELSE", "END", "ENGINE", "EVENTS", 
                      "EXISTS", "EXPLAIN", "EXPRESSION", "EXTRACT", "FETCHES", 
                      "FINAL", "FIRST", "FLUSH", "FOR", "FORMAT", "FREEZE", 
                      "FROM", "FULL", "FUNCTION", "FUSIONMERGE", "GLOBAL", 
                      "GRANULARITY", "GROUP", "HAVING", "HIERARCHICAL", 
                      "HOUR", "ID", "IF", "IIF", "ILIKE", "IN", "INDEX", 
                      "INF", "INJECTIVE", "INNER", "INSERT", "INTERVAL", 
                      "INTO", "IS", "IS_OBJECT_ID", "JOIN", "KEY", "KILL", 
                      "LAST", "LAYOUT", "LEADING", "LEFT", "LIFETIME", "LIKE", 
                      "LIMIT", "LIVE", "LOCAL", "LOGS", "MATERIALIZED", 
                      "MAX", "MERGES", "MIN", "MINUTE", "MODIFY", "MONTH", 
                      "MOVE", "MUTATION", "MULTIIF", "NAN_SQL", "NO", "NOT", 
                      "NULL_SQL", "NULLS", "OFFSET", "ON", "OPTIMIZE", "OR", 
                      "ORDER", "OUTER", "OUTFILE", "PARTITION", "PERCENTILE_CONT", 
                      "PERCENTILE_DISC", "POPULATE", "POW", "POWER", "PREWHERE", 
                      "PRIMARY", "QUARTER", "RANGE", "RELOAD", "REMOVE", 
                      "RENAME", "REPLACE", "REPLICA", "REPLICATED", "RIGHT", 
                      "ROLLUP", "SAMPLE", "SECOND", "SELECT", "SEMI", "SENDS", 
                      "SET", "SETTINGS", "SHOW", "SOURCE", "START", "STD", 
                      "STDDEV", "STDDEVPOP", "STOP", "SUBSTRING", "SUM", 
                      "SYNC", "SYNTAX", "SYSTEM", "TABLE", "TABLES", "TEALIMIT", 
                      "TEMPORARY", "TEST", "THEN", "TIES", "TIMEOUT", "TIMESTAMP", 
                      "TO", "TOP", "TOTALS", "TRAILING", "TRIM", "TRUNCATE", 
                      "TTL", "TUPLE", "TYPE", "UNION", "UPDATE", "USE", 
                      "USING", "UUID", "VALUES", "VIEW", "VOLUME", "WATCH", 
                      "WEEK", "VAR", "VARPOP", "VARIANCE", "WHEN", "WHERE", 
                      "WITH", "YEAR", "JSON_FALSE", "JSON_TRUE", "IDENTIFIER", 
                      "FLOATING_LITERAL", "OCTAL_LITERAL", "DECIMAL_LITERAL", 
                      "HEXADECIMAL_LITERAL", "STRING_LITERAL", "ARROW", 
                      "ASTERISK", "BACKQUOTE", "BACKSLASH", "COLON", "DOUBLECOLON", 
                      "COMMA", "CONCAT", "DASH", "DOT", "EQ_DOUBLE", "EQ_SINGLE", 
                      "GE", "GT", "LBRACE", "LBRACKET", "LE", "LPAREN", 
                      "LT", "NOT_EQ", "PERCENT", "PLUS", "QUERY", "QUOTE_DOUBLE", 
                      "QUOTE_SINGLE", "RBRACE", "RBRACKET", "RPAREN", "SEMICOLON", 
                      "SLASH", "UNDERSCORE", "MULTI_LINE_COMMENT", "SINGLE_LINE_COMMENT", 
                      "WHITESPACE" ]

    RULE_query = 0
    RULE_selectUnionStmt = 1
    RULE_stmtUnionFlag = 2
    RULE_selectStmtWithParens = 3
    RULE_selectStmt = 4
    RULE_formatClause = 5
    RULE_selectClause = 6
    RULE_withClause = 7
    RULE_topClause = 8
    RULE_fromClause = 9
    RULE_arrayJoinClause = 10
    RULE_prewhereClause = 11
    RULE_whereClause = 12
    RULE_groupByClause = 13
    RULE_havingClause = 14
    RULE_orderByClause = 15
    RULE_limitByClause = 16
    RULE_limitClause = 17
    RULE_tealimitClause = 18
    RULE_settingsClause = 19
    RULE_groupByTailFlag = 20
    RULE_joinExpr = 21
    RULE_joinOp = 22
    RULE_joinOpCross = 23
    RULE_joinConstraintClause = 24
    RULE_sampleClause = 25
    RULE_limitExpr = 26
    RULE_orderExprList = 27
    RULE_orderExpr = 28
    RULE_ratioExpr = 29
    RULE_settingExprList = 30
    RULE_settingExpr = 31
    RULE_columnTypeExpr = 32
    RULE_columnDefinitionExpr = 33
    RULE_columnExprList = 34
    RULE_columnExprWhen = 35
    RULE_columnsExpr = 36
    RULE_caseExpr = 37
    RULE_columnExpr = 38
    RULE_columnArgList = 39
    RULE_columnArgExpr = 40
    RULE_columnLambdaExpr = 41
    RULE_columnIdentifier = 42
    RULE_nestedIdentifier = 43
    RULE_tableExpr = 44
    RULE_fushionMerge = 45
    RULE_tableFunctionExpr = 46
    RULE_tableIdentifier = 47
    RULE_tableArgList = 48
    RULE_tableArgExpr = 49
    RULE_databaseIdentifier = 50
    RULE_floatingLiteral = 51
    RULE_numberLiteral = 52
    RULE_literal = 53
    RULE_interval = 54
    RULE_aggregateFunctionName = 55
    RULE_decimalTypeName = 56
    RULE_tupleOrArrayName = 57
    RULE_keyword = 58
    RULE_keywordForAlias = 59
    RULE_alias = 60
    RULE_identifier = 61
    RULE_identifierOrNull = 62
    RULE_enumValue = 63

    ruleNames =  [ "query", "selectUnionStmt", "stmtUnionFlag", "selectStmtWithParens", 
                   "selectStmt", "formatClause", "selectClause", "withClause", 
                   "topClause", "fromClause", "arrayJoinClause", "prewhereClause", 
                   "whereClause", "groupByClause", "havingClause", "orderByClause", 
                   "limitByClause", "limitClause", "tealimitClause", "settingsClause", 
                   "groupByTailFlag", "joinExpr", "joinOp", "joinOpCross", 
                   "joinConstraintClause", "sampleClause", "limitExpr", 
                   "orderExprList", "orderExpr", "ratioExpr", "settingExprList", 
                   "settingExpr", "columnTypeExpr", "columnDefinitionExpr", 
                   "columnExprList", "columnExprWhen", "columnsExpr", "caseExpr", 
                   "columnExpr", "columnArgList", "columnArgExpr", "columnLambdaExpr", 
                   "columnIdentifier", "nestedIdentifier", "tableExpr", 
                   "fushionMerge", "tableFunctionExpr", "tableIdentifier", 
                   "tableArgList", "tableArgExpr", "databaseIdentifier", 
                   "floatingLiteral", "numberLiteral", "literal", "interval", 
                   "aggregateFunctionName", "decimalTypeName", "tupleOrArrayName", 
                   "keyword", "keywordForAlias", "alias", "identifier", 
                   "identifierOrNull", "enumValue" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    ADD=6
    AFTER=7
    ALIAS=8
    ALL=9
    ALTER=10
    AND=11
    ANTI=12
    ANY=13
    ARRAY=14
    AS=15
    ASCENDING=16
    ASOF=17
    ASYNC=18
    ATTACH=19
    AVG=20
    BETWEEN=21
    BOTH=22
    BY=23
    CASE=24
    CAST=25
    CHECK=26
    CLEAR=27
    CLUSTER=28
    CODEC=29
    COLLATE=30
    COLUMN=31
    COMMENT=32
    CONSTRAINT=33
    COUNT=34
    CREATE=35
    CROSS=36
    CUBE=37
    DATABASE=38
    DATABASES=39
    DATE=40
    DAY=41
    DEDUPLICATE=42
    DEFAULT=43
    DELAY=44
    DELETE=45
    DESC=46
    DESCENDING=47
    DESCRIBE=48
    DETACH=49
    DICTIONARIES=50
    DICTIONARY=51
    DISK=52
    DISTINCT=53
    DISTRIBUTED=54
    DROP=55
    ELSE=56
    END=57
    ENGINE=58
    EVENTS=59
    EXISTS=60
    EXPLAIN=61
    EXPRESSION=62
    EXTRACT=63
    FETCHES=64
    FINAL=65
    FIRST=66
    FLUSH=67
    FOR=68
    FORMAT=69
    FREEZE=70
    FROM=71
    FULL=72
    FUNCTION=73
    FUSIONMERGE=74
    GLOBAL=75
    GRANULARITY=76
    GROUP=77
    HAVING=78
    HIERARCHICAL=79
    HOUR=80
    ID=81
    IF=82
    IIF=83
    ILIKE=84
    IN=85
    INDEX=86
    INF=87
    INJECTIVE=88
    INNER=89
    INSERT=90
    INTERVAL=91
    INTO=92
    IS=93
    IS_OBJECT_ID=94
    JOIN=95
    KEY=96
    KILL=97
    LAST=98
    LAYOUT=99
    LEADING=100
    LEFT=101
    LIFETIME=102
    LIKE=103
    LIMIT=104
    LIVE=105
    LOCAL=106
    LOGS=107
    MATERIALIZED=108
    MAX=109
    MERGES=110
    MIN=111
    MINUTE=112
    MODIFY=113
    MONTH=114
    MOVE=115
    MUTATION=116
    MULTIIF=117
    NAN_SQL=118
    NO=119
    NOT=120
    NULL_SQL=121
    NULLS=122
    OFFSET=123
    ON=124
    OPTIMIZE=125
    OR=126
    ORDER=127
    OUTER=128
    OUTFILE=129
    PARTITION=130
    PERCENTILE_CONT=131
    PERCENTILE_DISC=132
    POPULATE=133
    POW=134
    POWER=135
    PREWHERE=136
    PRIMARY=137
    QUARTER=138
    RANGE=139
    RELOAD=140
    REMOVE=141
    RENAME=142
    REPLACE=143
    REPLICA=144
    REPLICATED=145
    RIGHT=146
    ROLLUP=147
    SAMPLE=148
    SECOND=149
    SELECT=150
    SEMI=151
    SENDS=152
    SET=153
    SETTINGS=154
    SHOW=155
    SOURCE=156
    START=157
    STD=158
    STDDEV=159
    STDDEVPOP=160
    STOP=161
    SUBSTRING=162
    SUM=163
    SYNC=164
    SYNTAX=165
    SYSTEM=166
    TABLE=167
    TABLES=168
    TEALIMIT=169
    TEMPORARY=170
    TEST=171
    THEN=172
    TIES=173
    TIMEOUT=174
    TIMESTAMP=175
    TO=176
    TOP=177
    TOTALS=178
    TRAILING=179
    TRIM=180
    TRUNCATE=181
    TTL=182
    TUPLE=183
    TYPE=184
    UNION=185
    UPDATE=186
    USE=187
    USING=188
    UUID=189
    VALUES=190
    VIEW=191
    VOLUME=192
    WATCH=193
    WEEK=194
    VAR=195
    VARPOP=196
    VARIANCE=197
    WHEN=198
    WHERE=199
    WITH=200
    YEAR=201
    JSON_FALSE=202
    JSON_TRUE=203
    IDENTIFIER=204
    FLOATING_LITERAL=205
    OCTAL_LITERAL=206
    DECIMAL_LITERAL=207
    HEXADECIMAL_LITERAL=208
    STRING_LITERAL=209
    ARROW=210
    ASTERISK=211
    BACKQUOTE=212
    BACKSLASH=213
    COLON=214
    DOUBLECOLON=215
    COMMA=216
    CONCAT=217
    DASH=218
    DOT=219
    EQ_DOUBLE=220
    EQ_SINGLE=221
    GE=222
    GT=223
    LBRACE=224
    LBRACKET=225
    LE=226
    LPAREN=227
    LT=228
    NOT_EQ=229
    PERCENT=230
    PLUS=231
    QUERY=232
    QUOTE_DOUBLE=233
    QUOTE_SINGLE=234
    RBRACE=235
    RBRACKET=236
    RPAREN=237
    SEMICOLON=238
    SLASH=239
    UNDERSCORE=240
    MULTI_LINE_COMMENT=241
    SINGLE_LINE_COMMENT=242
    WHITESPACE=243

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class QueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectUnionStmt(self):
            return self.getTypedRuleContext(ClickHouseParser.SelectUnionStmtContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuery" ):
                listener.enterQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuery" ):
                listener.exitQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuery" ):
                return visitor.visitQuery(self)
            else:
                return visitor.visitChildren(self)




    def query(self):

        localctx = ClickHouseParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_query)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self.selectUnionStmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectUnionStmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectStmtWithParens(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.SelectStmtWithParensContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.SelectStmtWithParensContext,i)


        def stmtUnionFlag(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.StmtUnionFlagContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.StmtUnionFlagContext,i)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_selectUnionStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectUnionStmt" ):
                listener.enterSelectUnionStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectUnionStmt" ):
                listener.exitSelectUnionStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectUnionStmt" ):
                return visitor.visitSelectUnionStmt(self)
            else:
                return visitor.visitChildren(self)




    def selectUnionStmt(self):

        localctx = ClickHouseParser.SelectUnionStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_selectUnionStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 130
            self.selectStmtWithParens()
            self.state = 136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==ClickHouseParser.UNION:
                self.state = 131
                self.stmtUnionFlag()
                self.state = 132
                self.selectStmtWithParens()
                self.state = 138
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StmtUnionFlagContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ClickHouseParser.RULE_stmtUnionFlag

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class StmtUnionAllContext(StmtUnionFlagContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.StmtUnionFlagContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def UNION(self):
            return self.getToken(ClickHouseParser.UNION, 0)
        def ALL(self):
            return self.getToken(ClickHouseParser.ALL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmtUnionAll" ):
                listener.enterStmtUnionAll(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmtUnionAll" ):
                listener.exitStmtUnionAll(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStmtUnionAll" ):
                return visitor.visitStmtUnionAll(self)
            else:
                return visitor.visitChildren(self)


    class StmtUnionContext(StmtUnionFlagContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.StmtUnionFlagContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def UNION(self):
            return self.getToken(ClickHouseParser.UNION, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmtUnion" ):
                listener.enterStmtUnion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmtUnion" ):
                listener.exitStmtUnion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStmtUnion" ):
                return visitor.visitStmtUnion(self)
            else:
                return visitor.visitChildren(self)


    class StmtUnionDistinctContext(StmtUnionFlagContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.StmtUnionFlagContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def UNION(self):
            return self.getToken(ClickHouseParser.UNION, 0)
        def DISTINCT(self):
            return self.getToken(ClickHouseParser.DISTINCT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmtUnionDistinct" ):
                listener.enterStmtUnionDistinct(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmtUnionDistinct" ):
                listener.exitStmtUnionDistinct(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStmtUnionDistinct" ):
                return visitor.visitStmtUnionDistinct(self)
            else:
                return visitor.visitChildren(self)



    def stmtUnionFlag(self):

        localctx = ClickHouseParser.StmtUnionFlagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_stmtUnionFlag)
        try:
            self.state = 144
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                localctx = ClickHouseParser.StmtUnionAllContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 139
                self.match(ClickHouseParser.UNION)
                self.state = 140
                self.match(ClickHouseParser.ALL)
                pass

            elif la_ == 2:
                localctx = ClickHouseParser.StmtUnionDistinctContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 141
                self.match(ClickHouseParser.UNION)
                self.state = 142
                self.match(ClickHouseParser.DISTINCT)
                pass

            elif la_ == 3:
                localctx = ClickHouseParser.StmtUnionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 143
                self.match(ClickHouseParser.UNION)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectStmtWithParensContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectStmt(self):
            return self.getTypedRuleContext(ClickHouseParser.SelectStmtContext,0)


        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def selectUnionStmt(self):
            return self.getTypedRuleContext(ClickHouseParser.SelectUnionStmtContext,0)


        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_selectStmtWithParens

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectStmtWithParens" ):
                listener.enterSelectStmtWithParens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectStmtWithParens" ):
                listener.exitSelectStmtWithParens(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectStmtWithParens" ):
                return visitor.visitSelectStmtWithParens(self)
            else:
                return visitor.visitChildren(self)




    def selectStmtWithParens(self):

        localctx = ClickHouseParser.SelectStmtWithParensContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_selectStmtWithParens)
        try:
            self.state = 151
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.SELECT, ClickHouseParser.WITH]:
                self.enterOuterAlt(localctx, 1)
                self.state = 146
                self.selectStmt()
                pass
            elif token in [ClickHouseParser.LPAREN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 147
                self.match(ClickHouseParser.LPAREN)
                self.state = 148
                self.selectUnionStmt()
                self.state = 149
                self.match(ClickHouseParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectStmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectClause(self):
            return self.getTypedRuleContext(ClickHouseParser.SelectClauseContext,0)


        def withClause(self):
            return self.getTypedRuleContext(ClickHouseParser.WithClauseContext,0)


        def fromClause(self):
            return self.getTypedRuleContext(ClickHouseParser.FromClauseContext,0)


        def arrayJoinClause(self):
            return self.getTypedRuleContext(ClickHouseParser.ArrayJoinClauseContext,0)


        def prewhereClause(self):
            return self.getTypedRuleContext(ClickHouseParser.PrewhereClauseContext,0)


        def whereClause(self):
            return self.getTypedRuleContext(ClickHouseParser.WhereClauseContext,0)


        def groupByClause(self):
            return self.getTypedRuleContext(ClickHouseParser.GroupByClauseContext,0)


        def havingClause(self):
            return self.getTypedRuleContext(ClickHouseParser.HavingClauseContext,0)


        def orderByClause(self):
            return self.getTypedRuleContext(ClickHouseParser.OrderByClauseContext,0)


        def limitByClause(self):
            return self.getTypedRuleContext(ClickHouseParser.LimitByClauseContext,0)


        def limitClause(self):
            return self.getTypedRuleContext(ClickHouseParser.LimitClauseContext,0)


        def tealimitClause(self):
            return self.getTypedRuleContext(ClickHouseParser.TealimitClauseContext,0)


        def settingsClause(self):
            return self.getTypedRuleContext(ClickHouseParser.SettingsClauseContext,0)


        def formatClause(self):
            return self.getTypedRuleContext(ClickHouseParser.FormatClauseContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_selectStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectStmt" ):
                listener.enterSelectStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectStmt" ):
                listener.exitSelectStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectStmt" ):
                return visitor.visitSelectStmt(self)
            else:
                return visitor.visitChildren(self)




    def selectStmt(self):

        localctx = ClickHouseParser.SelectStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_selectStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.WITH:
                self.state = 153
                self.withClause()


            self.state = 156
            self.selectClause()
            self.state = 158
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.FROM:
                self.state = 157
                self.fromClause()


            self.state = 161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.ARRAY or _la==ClickHouseParser.INNER or _la==ClickHouseParser.LEFT:
                self.state = 160
                self.arrayJoinClause()


            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.PREWHERE:
                self.state = 163
                self.prewhereClause()


            self.state = 167
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.WHERE:
                self.state = 166
                self.whereClause()


            self.state = 170
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.GROUP:
                self.state = 169
                self.groupByClause()


            self.state = 173
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.HAVING:
                self.state = 172
                self.havingClause()


            self.state = 176
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.ORDER:
                self.state = 175
                self.orderByClause()


            self.state = 179
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.state = 178
                self.limitByClause()


            self.state = 182
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.LIMIT:
                self.state = 181
                self.limitClause()


            self.state = 185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.TEALIMIT:
                self.state = 184
                self.tealimitClause()


            self.state = 188
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.SETTINGS:
                self.state = 187
                self.settingsClause()


            self.state = 191
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.FORMAT:
                self.state = 190
                self.formatClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormatClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FORMAT(self):
            return self.getToken(ClickHouseParser.FORMAT, 0)

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_formatClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormatClause" ):
                listener.enterFormatClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormatClause" ):
                listener.exitFormatClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormatClause" ):
                return visitor.visitFormatClause(self)
            else:
                return visitor.visitChildren(self)




    def formatClause(self):

        localctx = ClickHouseParser.FormatClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_formatClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(ClickHouseParser.FORMAT)
            self.state = 194
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(ClickHouseParser.SELECT, 0)

        def columnExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,0)


        def DISTINCT(self):
            return self.getToken(ClickHouseParser.DISTINCT, 0)

        def topClause(self):
            return self.getTypedRuleContext(ClickHouseParser.TopClauseContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_selectClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectClause" ):
                listener.enterSelectClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectClause" ):
                listener.exitSelectClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectClause" ):
                return visitor.visitSelectClause(self)
            else:
                return visitor.visitChildren(self)




    def selectClause(self):

        localctx = ClickHouseParser.SelectClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_selectClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            self.match(ClickHouseParser.SELECT)
            self.state = 198
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.state = 197
                self.match(ClickHouseParser.DISTINCT)


            self.state = 201
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.state = 200
                self.topClause()


            self.state = 203
            self.columnExprList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(ClickHouseParser.WITH, 0)

        def columnExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_withClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithClause" ):
                listener.enterWithClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithClause" ):
                listener.exitWithClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWithClause" ):
                return visitor.visitWithClause(self)
            else:
                return visitor.visitChildren(self)




    def withClause(self):

        localctx = ClickHouseParser.WithClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_withClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            self.match(ClickHouseParser.WITH)
            self.state = 206
            self.columnExprList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOP(self):
            return self.getToken(ClickHouseParser.TOP, 0)

        def DECIMAL_LITERAL(self):
            return self.getToken(ClickHouseParser.DECIMAL_LITERAL, 0)

        def WITH(self):
            return self.getToken(ClickHouseParser.WITH, 0)

        def TIES(self):
            return self.getToken(ClickHouseParser.TIES, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_topClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopClause" ):
                listener.enterTopClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopClause" ):
                listener.exitTopClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTopClause" ):
                return visitor.visitTopClause(self)
            else:
                return visitor.visitChildren(self)




    def topClause(self):

        localctx = ClickHouseParser.TopClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_topClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.match(ClickHouseParser.TOP)
            self.state = 209
            self.match(ClickHouseParser.DECIMAL_LITERAL)
            self.state = 212
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.state = 210
                self.match(ClickHouseParser.WITH)
                self.state = 211
                self.match(ClickHouseParser.TIES)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM(self):
            return self.getToken(ClickHouseParser.FROM, 0)

        def joinExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.JoinExprContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_fromClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromClause" ):
                listener.enterFromClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromClause" ):
                listener.exitFromClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFromClause" ):
                return visitor.visitFromClause(self)
            else:
                return visitor.visitChildren(self)




    def fromClause(self):

        localctx = ClickHouseParser.FromClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_fromClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            self.match(ClickHouseParser.FROM)
            self.state = 215
            self.joinExpr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayJoinClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(ClickHouseParser.ARRAY, 0)

        def JOIN(self):
            return self.getToken(ClickHouseParser.JOIN, 0)

        def columnExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,0)


        def LEFT(self):
            return self.getToken(ClickHouseParser.LEFT, 0)

        def INNER(self):
            return self.getToken(ClickHouseParser.INNER, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_arrayJoinClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayJoinClause" ):
                listener.enterArrayJoinClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayJoinClause" ):
                listener.exitArrayJoinClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayJoinClause" ):
                return visitor.visitArrayJoinClause(self)
            else:
                return visitor.visitChildren(self)




    def arrayJoinClause(self):

        localctx = ClickHouseParser.ArrayJoinClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_arrayJoinClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 218
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.INNER or _la==ClickHouseParser.LEFT:
                self.state = 217
                _la = self._input.LA(1)
                if not(_la==ClickHouseParser.INNER or _la==ClickHouseParser.LEFT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 220
            self.match(ClickHouseParser.ARRAY)
            self.state = 221
            self.match(ClickHouseParser.JOIN)
            self.state = 222
            self.columnExprList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrewhereClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PREWHERE(self):
            return self.getToken(ClickHouseParser.PREWHERE, 0)

        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_prewhereClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrewhereClause" ):
                listener.enterPrewhereClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrewhereClause" ):
                listener.exitPrewhereClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrewhereClause" ):
                return visitor.visitPrewhereClause(self)
            else:
                return visitor.visitChildren(self)




    def prewhereClause(self):

        localctx = ClickHouseParser.PrewhereClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_prewhereClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 224
            self.match(ClickHouseParser.PREWHERE)
            self.state = 225
            self.columnExpr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhereClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(ClickHouseParser.WHERE, 0)

        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_whereClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhereClause" ):
                listener.enterWhereClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhereClause" ):
                listener.exitWhereClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhereClause" ):
                return visitor.visitWhereClause(self)
            else:
                return visitor.visitChildren(self)




    def whereClause(self):

        localctx = ClickHouseParser.WhereClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_whereClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 227
            self.match(ClickHouseParser.WHERE)
            self.state = 228
            self.columnExpr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupByClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ClickHouseParser.RULE_groupByClause

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class GroupFrontCrContext(GroupByClauseContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.GroupByClauseContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def GROUP(self):
            return self.getToken(ClickHouseParser.GROUP, 0)
        def BY(self):
            return self.getToken(ClickHouseParser.BY, 0)
        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def columnExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)
        def CUBE(self):
            return self.getToken(ClickHouseParser.CUBE, 0)
        def ROLLUP(self):
            return self.getToken(ClickHouseParser.ROLLUP, 0)
        def groupByTailFlag(self):
            return self.getTypedRuleContext(ClickHouseParser.GroupByTailFlagContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupFrontCr" ):
                listener.enterGroupFrontCr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupFrontCr" ):
                listener.exitGroupFrontCr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupFrontCr" ):
                return visitor.visitGroupFrontCr(self)
            else:
                return visitor.visitChildren(self)


    class GroupNoFrontCrContext(GroupByClauseContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.GroupByClauseContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def GROUP(self):
            return self.getToken(ClickHouseParser.GROUP, 0)
        def BY(self):
            return self.getToken(ClickHouseParser.BY, 0)
        def columnExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,0)

        def groupByTailFlag(self):
            return self.getTypedRuleContext(ClickHouseParser.GroupByTailFlagContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupNoFrontCr" ):
                listener.enterGroupNoFrontCr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupNoFrontCr" ):
                listener.exitGroupNoFrontCr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupNoFrontCr" ):
                return visitor.visitGroupNoFrontCr(self)
            else:
                return visitor.visitChildren(self)



    def groupByClause(self):

        localctx = ClickHouseParser.GroupByClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_groupByClause)
        self._la = 0 # Token type
        try:
            self.state = 245
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                localctx = ClickHouseParser.GroupFrontCrContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 230
                self.match(ClickHouseParser.GROUP)
                self.state = 231
                self.match(ClickHouseParser.BY)
                self.state = 232
                _la = self._input.LA(1)
                if not(_la==ClickHouseParser.CUBE or _la==ClickHouseParser.ROLLUP):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 233
                self.match(ClickHouseParser.LPAREN)
                self.state = 234
                self.columnExprList()
                self.state = 235
                self.match(ClickHouseParser.RPAREN)
                self.state = 237
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ClickHouseParser.WITH:
                    self.state = 236
                    self.groupByTailFlag()


                pass

            elif la_ == 2:
                localctx = ClickHouseParser.GroupNoFrontCrContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 239
                self.match(ClickHouseParser.GROUP)
                self.state = 240
                self.match(ClickHouseParser.BY)
                self.state = 241
                self.columnExprList()
                self.state = 243
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ClickHouseParser.WITH:
                    self.state = 242
                    self.groupByTailFlag()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HavingClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HAVING(self):
            return self.getToken(ClickHouseParser.HAVING, 0)

        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_havingClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHavingClause" ):
                listener.enterHavingClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHavingClause" ):
                listener.exitHavingClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHavingClause" ):
                return visitor.visitHavingClause(self)
            else:
                return visitor.visitChildren(self)




    def havingClause(self):

        localctx = ClickHouseParser.HavingClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_havingClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 247
            self.match(ClickHouseParser.HAVING)
            self.state = 248
            self.columnExpr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderByClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER(self):
            return self.getToken(ClickHouseParser.ORDER, 0)

        def BY(self):
            return self.getToken(ClickHouseParser.BY, 0)

        def orderExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.OrderExprListContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_orderByClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderByClause" ):
                listener.enterOrderByClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderByClause" ):
                listener.exitOrderByClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderByClause" ):
                return visitor.visitOrderByClause(self)
            else:
                return visitor.visitChildren(self)




    def orderByClause(self):

        localctx = ClickHouseParser.OrderByClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_orderByClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.match(ClickHouseParser.ORDER)
            self.state = 251
            self.match(ClickHouseParser.BY)
            self.state = 252
            self.orderExprList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LimitByClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIMIT(self):
            return self.getToken(ClickHouseParser.LIMIT, 0)

        def limitExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.LimitExprContext,0)


        def BY(self):
            return self.getToken(ClickHouseParser.BY, 0)

        def columnExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_limitByClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimitByClause" ):
                listener.enterLimitByClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimitByClause" ):
                listener.exitLimitByClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLimitByClause" ):
                return visitor.visitLimitByClause(self)
            else:
                return visitor.visitChildren(self)




    def limitByClause(self):

        localctx = ClickHouseParser.LimitByClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_limitByClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            self.match(ClickHouseParser.LIMIT)
            self.state = 255
            self.limitExpr()
            self.state = 256
            self.match(ClickHouseParser.BY)
            self.state = 257
            self.columnExprList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LimitClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIMIT(self):
            return self.getToken(ClickHouseParser.LIMIT, 0)

        def limitExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.LimitExprContext,0)


        def WITH(self):
            return self.getToken(ClickHouseParser.WITH, 0)

        def TIES(self):
            return self.getToken(ClickHouseParser.TIES, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_limitClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimitClause" ):
                listener.enterLimitClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimitClause" ):
                listener.exitLimitClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLimitClause" ):
                return visitor.visitLimitClause(self)
            else:
                return visitor.visitChildren(self)




    def limitClause(self):

        localctx = ClickHouseParser.LimitClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_limitClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 259
            self.match(ClickHouseParser.LIMIT)
            self.state = 260
            self.limitExpr()
            self.state = 263
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.WITH:
                self.state = 261
                self.match(ClickHouseParser.WITH)
                self.state = 262
                self.match(ClickHouseParser.TIES)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TealimitClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None # NumberLiteralContext
            self.groupExp = None # ColumnExprListContext
            self.orderExp = None # ColumnExprListContext
            self.ordering = None # Token

        def TEALIMIT(self):
            return self.getToken(ClickHouseParser.TEALIMIT, 0)

        def GROUP(self):
            return self.getToken(ClickHouseParser.GROUP, 0)

        def ORDER(self):
            return self.getToken(ClickHouseParser.ORDER, 0)

        def numberLiteral(self):
            return self.getTypedRuleContext(ClickHouseParser.NumberLiteralContext,0)


        def columnExprList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprListContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,i)


        def ASCENDING(self):
            return self.getToken(ClickHouseParser.ASCENDING, 0)

        def DESC(self):
            return self.getToken(ClickHouseParser.DESC, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_tealimitClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTealimitClause" ):
                listener.enterTealimitClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTealimitClause" ):
                listener.exitTealimitClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTealimitClause" ):
                return visitor.visitTealimitClause(self)
            else:
                return visitor.visitChildren(self)




    def tealimitClause(self):

        localctx = ClickHouseParser.TealimitClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_tealimitClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 265
            self.match(ClickHouseParser.TEALIMIT)
            self.state = 266
            localctx.n = self.numberLiteral()
            self.state = 267
            self.match(ClickHouseParser.GROUP)
            self.state = 268
            localctx.groupExp = self.columnExprList()
            self.state = 269
            self.match(ClickHouseParser.ORDER)
            self.state = 270
            localctx.orderExp = self.columnExprList()
            self.state = 272
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.ASCENDING or _la==ClickHouseParser.DESC:
                self.state = 271
                localctx.ordering = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==ClickHouseParser.ASCENDING or _la==ClickHouseParser.DESC):
                    localctx.ordering = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SettingsClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SETTINGS(self):
            return self.getToken(ClickHouseParser.SETTINGS, 0)

        def settingExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.SettingExprListContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_settingsClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSettingsClause" ):
                listener.enterSettingsClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSettingsClause" ):
                listener.exitSettingsClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSettingsClause" ):
                return visitor.visitSettingsClause(self)
            else:
                return visitor.visitChildren(self)




    def settingsClause(self):

        localctx = ClickHouseParser.SettingsClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_settingsClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.match(ClickHouseParser.SETTINGS)
            self.state = 275
            self.settingExprList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupByTailFlagContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ClickHouseParser.RULE_groupByTailFlag

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class GroupWithCubeContext(GroupByTailFlagContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.GroupByTailFlagContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WITH(self):
            return self.getToken(ClickHouseParser.WITH, 0)
        def CUBE(self):
            return self.getToken(ClickHouseParser.CUBE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupWithCube" ):
                listener.enterGroupWithCube(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupWithCube" ):
                listener.exitGroupWithCube(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupWithCube" ):
                return visitor.visitGroupWithCube(self)
            else:
                return visitor.visitChildren(self)


    class GroupWithTotalsContext(GroupByTailFlagContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.GroupByTailFlagContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WITH(self):
            return self.getToken(ClickHouseParser.WITH, 0)
        def TOTALS(self):
            return self.getToken(ClickHouseParser.TOTALS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupWithTotals" ):
                listener.enterGroupWithTotals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupWithTotals" ):
                listener.exitGroupWithTotals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupWithTotals" ):
                return visitor.visitGroupWithTotals(self)
            else:
                return visitor.visitChildren(self)


    class GroupWithRollupContext(GroupByTailFlagContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.GroupByTailFlagContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WITH(self):
            return self.getToken(ClickHouseParser.WITH, 0)
        def ROLLUP(self):
            return self.getToken(ClickHouseParser.ROLLUP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupWithRollup" ):
                listener.enterGroupWithRollup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupWithRollup" ):
                listener.exitGroupWithRollup(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupWithRollup" ):
                return visitor.visitGroupWithRollup(self)
            else:
                return visitor.visitChildren(self)



    def groupByTailFlag(self):

        localctx = ClickHouseParser.GroupByTailFlagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_groupByTailFlag)
        try:
            self.state = 283
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                localctx = ClickHouseParser.GroupWithCubeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 277
                self.match(ClickHouseParser.WITH)
                self.state = 278
                self.match(ClickHouseParser.CUBE)
                pass

            elif la_ == 2:
                localctx = ClickHouseParser.GroupWithRollupContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 279
                self.match(ClickHouseParser.WITH)
                self.state = 280
                self.match(ClickHouseParser.ROLLUP)
                pass

            elif la_ == 3:
                localctx = ClickHouseParser.GroupWithTotalsContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 281
                self.match(ClickHouseParser.WITH)
                self.state = 282
                self.match(ClickHouseParser.TOTALS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ClickHouseParser.RULE_joinExpr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class JoinExprOpContext(JoinExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.JoinExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def joinExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.JoinExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.JoinExprContext,i)

        def JOIN(self):
            return self.getToken(ClickHouseParser.JOIN, 0)
        def joinConstraintClause(self):
            return self.getTypedRuleContext(ClickHouseParser.JoinConstraintClauseContext,0)

        def joinOp(self):
            return self.getTypedRuleContext(ClickHouseParser.JoinOpContext,0)

        def GLOBAL(self):
            return self.getToken(ClickHouseParser.GLOBAL, 0)
        def LOCAL(self):
            return self.getToken(ClickHouseParser.LOCAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinExprOp" ):
                listener.enterJoinExprOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinExprOp" ):
                listener.exitJoinExprOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinExprOp" ):
                return visitor.visitJoinExprOp(self)
            else:
                return visitor.visitChildren(self)


    class JoinExprTableContext(JoinExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.JoinExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def tableExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.TableExprContext,0)

        def FINAL(self):
            return self.getToken(ClickHouseParser.FINAL, 0)
        def sampleClause(self):
            return self.getTypedRuleContext(ClickHouseParser.SampleClauseContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinExprTable" ):
                listener.enterJoinExprTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinExprTable" ):
                listener.exitJoinExprTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinExprTable" ):
                return visitor.visitJoinExprTable(self)
            else:
                return visitor.visitChildren(self)


    class JoinExprParensContext(JoinExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.JoinExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def joinExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.JoinExprContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinExprParens" ):
                listener.enterJoinExprParens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinExprParens" ):
                listener.exitJoinExprParens(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinExprParens" ):
                return visitor.visitJoinExprParens(self)
            else:
                return visitor.visitChildren(self)


    class JoinExprCrossOpContext(JoinExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.JoinExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def joinExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.JoinExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.JoinExprContext,i)

        def joinOpCross(self):
            return self.getTypedRuleContext(ClickHouseParser.JoinOpCrossContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinExprCrossOp" ):
                listener.enterJoinExprCrossOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinExprCrossOp" ):
                listener.exitJoinExprCrossOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinExprCrossOp" ):
                return visitor.visitJoinExprCrossOp(self)
            else:
                return visitor.visitChildren(self)



    def joinExpr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ClickHouseParser.JoinExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 42
        self.enterRecursionRule(localctx, 42, self.RULE_joinExpr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 297
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                localctx = ClickHouseParser.JoinExprTableContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 286
                self.tableExpr(0)
                self.state = 288
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
                if la_ == 1:
                    self.state = 287
                    self.match(ClickHouseParser.FINAL)


                self.state = 291
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
                if la_ == 1:
                    self.state = 290
                    self.sampleClause()


                pass

            elif la_ == 2:
                localctx = ClickHouseParser.JoinExprParensContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 293
                self.match(ClickHouseParser.LPAREN)
                self.state = 294
                self.joinExpr(0)
                self.state = 295
                self.match(ClickHouseParser.RPAREN)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 316
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,32,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 314
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
                    if la_ == 1:
                        localctx = ClickHouseParser.JoinExprCrossOpContext(self, ClickHouseParser.JoinExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_joinExpr)
                        self.state = 299
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 300
                        self.joinOpCross()
                        self.state = 301
                        self.joinExpr(4)
                        pass

                    elif la_ == 2:
                        localctx = ClickHouseParser.JoinExprOpContext(self, ClickHouseParser.JoinExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_joinExpr)
                        self.state = 303
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 305
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==ClickHouseParser.GLOBAL or _la==ClickHouseParser.LOCAL:
                            self.state = 304
                            _la = self._input.LA(1)
                            if not(_la==ClickHouseParser.GLOBAL or _la==ClickHouseParser.LOCAL):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()


                        self.state = 308
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if ((((_la - 9)) & ~0x3f) == 0 and ((1 << (_la - 9)) & ((1 << (ClickHouseParser.ALL - 9)) | (1 << (ClickHouseParser.ANTI - 9)) | (1 << (ClickHouseParser.ANY - 9)) | (1 << (ClickHouseParser.ASOF - 9)) | (1 << (ClickHouseParser.FULL - 9)))) != 0) or ((((_la - 89)) & ~0x3f) == 0 and ((1 << (_la - 89)) & ((1 << (ClickHouseParser.INNER - 89)) | (1 << (ClickHouseParser.LEFT - 89)) | (1 << (ClickHouseParser.RIGHT - 89)) | (1 << (ClickHouseParser.SEMI - 89)))) != 0):
                            self.state = 307
                            self.joinOp()


                        self.state = 310
                        self.match(ClickHouseParser.JOIN)
                        self.state = 311
                        self.joinExpr(0)
                        self.state = 312
                        self.joinConstraintClause()
                        pass

             
                self.state = 318
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,32,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class JoinOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ClickHouseParser.RULE_joinOp

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class JoinOpInner1Context(JoinOpContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.JoinOpContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INNER(self):
            return self.getToken(ClickHouseParser.INNER, 0)
        def ALL(self):
            return self.getToken(ClickHouseParser.ALL, 0)
        def ANY(self):
            return self.getToken(ClickHouseParser.ANY, 0)
        def ASOF(self):
            return self.getToken(ClickHouseParser.ASOF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinOpInner1" ):
                listener.enterJoinOpInner1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinOpInner1" ):
                listener.exitJoinOpInner1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinOpInner1" ):
                return visitor.visitJoinOpInner1(self)
            else:
                return visitor.visitChildren(self)


    class JoinOpInner2Context(JoinOpContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.JoinOpContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INNER(self):
            return self.getToken(ClickHouseParser.INNER, 0)
        def ALL(self):
            return self.getToken(ClickHouseParser.ALL, 0)
        def ANY(self):
            return self.getToken(ClickHouseParser.ANY, 0)
        def ASOF(self):
            return self.getToken(ClickHouseParser.ASOF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinOpInner2" ):
                listener.enterJoinOpInner2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinOpInner2" ):
                listener.exitJoinOpInner2(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinOpInner2" ):
                return visitor.visitJoinOpInner2(self)
            else:
                return visitor.visitChildren(self)


    class JoinOpFull1Context(JoinOpContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.JoinOpContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FULL(self):
            return self.getToken(ClickHouseParser.FULL, 0)
        def OUTER(self):
            return self.getToken(ClickHouseParser.OUTER, 0)
        def ALL(self):
            return self.getToken(ClickHouseParser.ALL, 0)
        def ANY(self):
            return self.getToken(ClickHouseParser.ANY, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinOpFull1" ):
                listener.enterJoinOpFull1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinOpFull1" ):
                listener.exitJoinOpFull1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinOpFull1" ):
                return visitor.visitJoinOpFull1(self)
            else:
                return visitor.visitChildren(self)


    class JoinOpLeftRight2Context(JoinOpContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.JoinOpContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LEFT(self):
            return self.getToken(ClickHouseParser.LEFT, 0)
        def RIGHT(self):
            return self.getToken(ClickHouseParser.RIGHT, 0)
        def OUTER(self):
            return self.getToken(ClickHouseParser.OUTER, 0)
        def SEMI(self):
            return self.getToken(ClickHouseParser.SEMI, 0)
        def ALL(self):
            return self.getToken(ClickHouseParser.ALL, 0)
        def ANTI(self):
            return self.getToken(ClickHouseParser.ANTI, 0)
        def ANY(self):
            return self.getToken(ClickHouseParser.ANY, 0)
        def ASOF(self):
            return self.getToken(ClickHouseParser.ASOF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinOpLeftRight2" ):
                listener.enterJoinOpLeftRight2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinOpLeftRight2" ):
                listener.exitJoinOpLeftRight2(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinOpLeftRight2" ):
                return visitor.visitJoinOpLeftRight2(self)
            else:
                return visitor.visitChildren(self)


    class JoinOpLeftRight1Context(JoinOpContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.JoinOpContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LEFT(self):
            return self.getToken(ClickHouseParser.LEFT, 0)
        def RIGHT(self):
            return self.getToken(ClickHouseParser.RIGHT, 0)
        def OUTER(self):
            return self.getToken(ClickHouseParser.OUTER, 0)
        def SEMI(self):
            return self.getToken(ClickHouseParser.SEMI, 0)
        def ALL(self):
            return self.getToken(ClickHouseParser.ALL, 0)
        def ANTI(self):
            return self.getToken(ClickHouseParser.ANTI, 0)
        def ANY(self):
            return self.getToken(ClickHouseParser.ANY, 0)
        def ASOF(self):
            return self.getToken(ClickHouseParser.ASOF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinOpLeftRight1" ):
                listener.enterJoinOpLeftRight1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinOpLeftRight1" ):
                listener.exitJoinOpLeftRight1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinOpLeftRight1" ):
                return visitor.visitJoinOpLeftRight1(self)
            else:
                return visitor.visitChildren(self)


    class JoinOpFull2Context(JoinOpContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.JoinOpContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FULL(self):
            return self.getToken(ClickHouseParser.FULL, 0)
        def OUTER(self):
            return self.getToken(ClickHouseParser.OUTER, 0)
        def ALL(self):
            return self.getToken(ClickHouseParser.ALL, 0)
        def ANY(self):
            return self.getToken(ClickHouseParser.ANY, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinOpFull2" ):
                listener.enterJoinOpFull2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinOpFull2" ):
                listener.exitJoinOpFull2(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinOpFull2" ):
                return visitor.visitJoinOpFull2(self)
            else:
                return visitor.visitChildren(self)


    class JoinOpInner3Context(JoinOpContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.JoinOpContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ALL(self):
            return self.getToken(ClickHouseParser.ALL, 0)
        def ANY(self):
            return self.getToken(ClickHouseParser.ANY, 0)
        def ASOF(self):
            return self.getToken(ClickHouseParser.ASOF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinOpInner3" ):
                listener.enterJoinOpInner3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinOpInner3" ):
                listener.exitJoinOpInner3(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinOpInner3" ):
                return visitor.visitJoinOpInner3(self)
            else:
                return visitor.visitChildren(self)



    def joinOp(self):

        localctx = ClickHouseParser.JoinOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_joinOp)
        self._la = 0 # Token type
        try:
            self.state = 356
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                localctx = ClickHouseParser.JoinOpInner1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 320
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ASOF))) != 0):
                    self.state = 319
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ASOF))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 322
                self.match(ClickHouseParser.INNER)
                pass

            elif la_ == 2:
                localctx = ClickHouseParser.JoinOpInner2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 323
                self.match(ClickHouseParser.INNER)
                self.state = 325
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ASOF))) != 0):
                    self.state = 324
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ASOF))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass

            elif la_ == 3:
                localctx = ClickHouseParser.JoinOpInner3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 327
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ASOF))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 4:
                localctx = ClickHouseParser.JoinOpLeftRight1Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 329
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ASOF))) != 0) or _la==ClickHouseParser.SEMI:
                    self.state = 328
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ASOF))) != 0) or _la==ClickHouseParser.SEMI):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 331
                _la = self._input.LA(1)
                if not(_la==ClickHouseParser.LEFT or _la==ClickHouseParser.RIGHT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 333
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ClickHouseParser.OUTER:
                    self.state = 332
                    self.match(ClickHouseParser.OUTER)


                pass

            elif la_ == 5:
                localctx = ClickHouseParser.JoinOpLeftRight2Context(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 335
                _la = self._input.LA(1)
                if not(_la==ClickHouseParser.LEFT or _la==ClickHouseParser.RIGHT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 337
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ClickHouseParser.OUTER:
                    self.state = 336
                    self.match(ClickHouseParser.OUTER)


                self.state = 340
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ASOF))) != 0) or _la==ClickHouseParser.SEMI:
                    self.state = 339
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ASOF))) != 0) or _la==ClickHouseParser.SEMI):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass

            elif la_ == 6:
                localctx = ClickHouseParser.JoinOpFull1Context(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 343
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ClickHouseParser.ALL or _la==ClickHouseParser.ANY:
                    self.state = 342
                    _la = self._input.LA(1)
                    if not(_la==ClickHouseParser.ALL or _la==ClickHouseParser.ANY):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 345
                self.match(ClickHouseParser.FULL)
                self.state = 347
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ClickHouseParser.OUTER:
                    self.state = 346
                    self.match(ClickHouseParser.OUTER)


                pass

            elif la_ == 7:
                localctx = ClickHouseParser.JoinOpFull2Context(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 349
                self.match(ClickHouseParser.FULL)
                self.state = 351
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ClickHouseParser.OUTER:
                    self.state = 350
                    self.match(ClickHouseParser.OUTER)


                self.state = 354
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ClickHouseParser.ALL or _la==ClickHouseParser.ANY:
                    self.state = 353
                    _la = self._input.LA(1)
                    if not(_la==ClickHouseParser.ALL or _la==ClickHouseParser.ANY):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinOpCrossContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CROSS(self):
            return self.getToken(ClickHouseParser.CROSS, 0)

        def JOIN(self):
            return self.getToken(ClickHouseParser.JOIN, 0)

        def GLOBAL(self):
            return self.getToken(ClickHouseParser.GLOBAL, 0)

        def LOCAL(self):
            return self.getToken(ClickHouseParser.LOCAL, 0)

        def COMMA(self):
            return self.getToken(ClickHouseParser.COMMA, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_joinOpCross

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinOpCross" ):
                listener.enterJoinOpCross(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinOpCross" ):
                listener.exitJoinOpCross(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinOpCross" ):
                return visitor.visitJoinOpCross(self)
            else:
                return visitor.visitChildren(self)




    def joinOpCross(self):

        localctx = ClickHouseParser.JoinOpCrossContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_joinOpCross)
        self._la = 0 # Token type
        try:
            self.state = 364
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.CROSS, ClickHouseParser.GLOBAL, ClickHouseParser.LOCAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 359
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ClickHouseParser.GLOBAL or _la==ClickHouseParser.LOCAL:
                    self.state = 358
                    _la = self._input.LA(1)
                    if not(_la==ClickHouseParser.GLOBAL or _la==ClickHouseParser.LOCAL):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 361
                self.match(ClickHouseParser.CROSS)
                self.state = 362
                self.match(ClickHouseParser.JOIN)
                pass
            elif token in [ClickHouseParser.COMMA]:
                self.enterOuterAlt(localctx, 2)
                self.state = 363
                self.match(ClickHouseParser.COMMA)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinConstraintClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON(self):
            return self.getToken(ClickHouseParser.ON, 0)

        def columnExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,0)


        def USING(self):
            return self.getToken(ClickHouseParser.USING, 0)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_joinConstraintClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinConstraintClause" ):
                listener.enterJoinConstraintClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinConstraintClause" ):
                listener.exitJoinConstraintClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinConstraintClause" ):
                return visitor.visitJoinConstraintClause(self)
            else:
                return visitor.visitChildren(self)




    def joinConstraintClause(self):

        localctx = ClickHouseParser.JoinConstraintClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_joinConstraintClause)
        try:
            self.state = 375
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 366
                self.match(ClickHouseParser.ON)
                self.state = 367
                self.columnExprList()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 368
                self.match(ClickHouseParser.USING)
                self.state = 369
                self.match(ClickHouseParser.LPAREN)
                self.state = 370
                self.columnExprList()
                self.state = 371
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 373
                self.match(ClickHouseParser.USING)
                self.state = 374
                self.columnExprList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SampleClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SAMPLE(self):
            return self.getToken(ClickHouseParser.SAMPLE, 0)

        def ratioExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.RatioExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.RatioExprContext,i)


        def OFFSET(self):
            return self.getToken(ClickHouseParser.OFFSET, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_sampleClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSampleClause" ):
                listener.enterSampleClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSampleClause" ):
                listener.exitSampleClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSampleClause" ):
                return visitor.visitSampleClause(self)
            else:
                return visitor.visitChildren(self)




    def sampleClause(self):

        localctx = ClickHouseParser.SampleClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_sampleClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 377
            self.match(ClickHouseParser.SAMPLE)
            self.state = 378
            self.ratioExpr()
            self.state = 381
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.state = 379
                self.match(ClickHouseParser.OFFSET)
                self.state = 380
                self.ratioExpr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LimitExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)


        def COMMA(self):
            return self.getToken(ClickHouseParser.COMMA, 0)

        def OFFSET(self):
            return self.getToken(ClickHouseParser.OFFSET, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_limitExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimitExpr" ):
                listener.enterLimitExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimitExpr" ):
                listener.exitLimitExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLimitExpr" ):
                return visitor.visitLimitExpr(self)
            else:
                return visitor.visitChildren(self)




    def limitExpr(self):

        localctx = ClickHouseParser.LimitExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_limitExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            self.columnExpr(0)
            self.state = 386
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.OFFSET or _la==ClickHouseParser.COMMA:
                self.state = 384
                _la = self._input.LA(1)
                if not(_la==ClickHouseParser.OFFSET or _la==ClickHouseParser.COMMA):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 385
                self.columnExpr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderExprListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.OrderExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.OrderExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_orderExprList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderExprList" ):
                listener.enterOrderExprList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderExprList" ):
                listener.exitOrderExprList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderExprList" ):
                return visitor.visitOrderExprList(self)
            else:
                return visitor.visitChildren(self)




    def orderExprList(self):

        localctx = ClickHouseParser.OrderExprListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_orderExprList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 388
            self.orderExpr()
            self.state = 393
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==ClickHouseParser.COMMA:
                self.state = 389
                self.match(ClickHouseParser.COMMA)
                self.state = 390
                self.orderExpr()
                self.state = 395
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)


        def NULLS(self):
            return self.getToken(ClickHouseParser.NULLS, 0)

        def COLLATE(self):
            return self.getToken(ClickHouseParser.COLLATE, 0)

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def ASCENDING(self):
            return self.getToken(ClickHouseParser.ASCENDING, 0)

        def DESCENDING(self):
            return self.getToken(ClickHouseParser.DESCENDING, 0)

        def DESC(self):
            return self.getToken(ClickHouseParser.DESC, 0)

        def FIRST(self):
            return self.getToken(ClickHouseParser.FIRST, 0)

        def LAST(self):
            return self.getToken(ClickHouseParser.LAST, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_orderExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderExpr" ):
                listener.enterOrderExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderExpr" ):
                listener.exitOrderExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderExpr" ):
                return visitor.visitOrderExpr(self)
            else:
                return visitor.visitChildren(self)




    def orderExpr(self):

        localctx = ClickHouseParser.OrderExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_orderExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 396
            self.columnExpr(0)
            self.state = 398
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.ASCENDING) | (1 << ClickHouseParser.DESC) | (1 << ClickHouseParser.DESCENDING))) != 0):
                self.state = 397
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.ASCENDING) | (1 << ClickHouseParser.DESC) | (1 << ClickHouseParser.DESCENDING))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 402
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.NULLS:
                self.state = 400
                self.match(ClickHouseParser.NULLS)
                self.state = 401
                _la = self._input.LA(1)
                if not(_la==ClickHouseParser.FIRST or _la==ClickHouseParser.LAST):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 406
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.COLLATE:
                self.state = 404
                self.match(ClickHouseParser.COLLATE)
                self.state = 405
                self.match(ClickHouseParser.STRING_LITERAL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.NumberLiteralContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.NumberLiteralContext,i)


        def SLASH(self):
            return self.getToken(ClickHouseParser.SLASH, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_ratioExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatioExpr" ):
                listener.enterRatioExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatioExpr" ):
                listener.exitRatioExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRatioExpr" ):
                return visitor.visitRatioExpr(self)
            else:
                return visitor.visitChildren(self)




    def ratioExpr(self):

        localctx = ClickHouseParser.RatioExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_ratioExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 408
            self.numberLiteral()
            self.state = 411
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
            if la_ == 1:
                self.state = 409
                self.match(ClickHouseParser.SLASH)
                self.state = 410
                self.numberLiteral()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SettingExprListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def settingExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.SettingExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.SettingExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_settingExprList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSettingExprList" ):
                listener.enterSettingExprList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSettingExprList" ):
                listener.exitSettingExprList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSettingExprList" ):
                return visitor.visitSettingExprList(self)
            else:
                return visitor.visitChildren(self)




    def settingExprList(self):

        localctx = ClickHouseParser.SettingExprListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_settingExprList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 413
            self.settingExpr()
            self.state = 418
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==ClickHouseParser.COMMA:
                self.state = 414
                self.match(ClickHouseParser.COMMA)
                self.state = 415
                self.settingExpr()
                self.state = 420
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SettingExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)


        def EQ_SINGLE(self):
            return self.getToken(ClickHouseParser.EQ_SINGLE, 0)

        def literal(self):
            return self.getTypedRuleContext(ClickHouseParser.LiteralContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_settingExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSettingExpr" ):
                listener.enterSettingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSettingExpr" ):
                listener.exitSettingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSettingExpr" ):
                return visitor.visitSettingExpr(self)
            else:
                return visitor.visitChildren(self)




    def settingExpr(self):

        localctx = ClickHouseParser.SettingExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_settingExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 421
            self.identifier()
            self.state = 422
            self.match(ClickHouseParser.EQ_SINGLE)
            self.state = 423
            self.literal()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnTypeExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ClickHouseParser.RULE_columnTypeExpr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ColumnTypeExprNestedContext(ColumnTypeExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnTypeExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,i)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def columnTypeExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnTypeExprContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)
        def columnDefinitionExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnDefinitionExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnDefinitionExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnTypeExprNested" ):
                listener.enterColumnTypeExprNested(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnTypeExprNested" ):
                listener.exitColumnTypeExprNested(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnTypeExprNested" ):
                return visitor.visitColumnTypeExprNested(self)
            else:
                return visitor.visitChildren(self)


    class ColumnTypeExprParamContext(ColumnTypeExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnTypeExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)
        def columnExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnTypeExprParam" ):
                listener.enterColumnTypeExprParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnTypeExprParam" ):
                listener.exitColumnTypeExprParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnTypeExprParam" ):
                return visitor.visitColumnTypeExprParam(self)
            else:
                return visitor.visitChildren(self)


    class ColumnTypeExprSimpleContext(ColumnTypeExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnTypeExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnTypeExprSimple" ):
                listener.enterColumnTypeExprSimple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnTypeExprSimple" ):
                listener.exitColumnTypeExprSimple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnTypeExprSimple" ):
                return visitor.visitColumnTypeExprSimple(self)
            else:
                return visitor.visitChildren(self)


    class ColumnTypeExprComplexContext(ColumnTypeExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnTypeExprContext
            super().__init__(parser)
            self.ttype = None # TupleOrArrayNameContext
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)
        def tupleOrArrayName(self):
            return self.getTypedRuleContext(ClickHouseParser.TupleOrArrayNameContext,0)

        def columnExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnTypeExprComplex" ):
                listener.enterColumnTypeExprComplex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnTypeExprComplex" ):
                listener.exitColumnTypeExprComplex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnTypeExprComplex" ):
                return visitor.visitColumnTypeExprComplex(self)
            else:
                return visitor.visitChildren(self)


    class ColumnTypeDecimalContext(ColumnTypeExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnTypeExprContext
            super().__init__(parser)
            self.decimaltype = None # DecimalTypeNameContext
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)
        def decimalTypeName(self):
            return self.getTypedRuleContext(ClickHouseParser.DecimalTypeNameContext,0)

        def columnExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnTypeDecimal" ):
                listener.enterColumnTypeDecimal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnTypeDecimal" ):
                listener.exitColumnTypeDecimal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnTypeDecimal" ):
                return visitor.visitColumnTypeDecimal(self)
            else:
                return visitor.visitChildren(self)


    class ColumnTypeExprEnumContext(ColumnTypeExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnTypeExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def enumValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.EnumValueContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.EnumValueContext,i)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnTypeExprEnum" ):
                listener.enterColumnTypeExprEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnTypeExprEnum" ):
                listener.exitColumnTypeExprEnum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnTypeExprEnum" ):
                return visitor.visitColumnTypeExprEnum(self)
            else:
                return visitor.visitChildren(self)



    def columnTypeExpr(self):

        localctx = ClickHouseParser.ColumnTypeExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_columnTypeExpr)
        self._la = 0 # Token type
        try:
            self.state = 472
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
            if la_ == 1:
                localctx = ClickHouseParser.ColumnTypeExprSimpleContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 425
                self.identifier()
                pass

            elif la_ == 2:
                localctx = ClickHouseParser.ColumnTypeExprNestedContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 426
                self.identifier()
                self.state = 427
                self.match(ClickHouseParser.LPAREN)
                self.state = 428
                self.identifier()
                self.state = 429
                self.columnTypeExpr()
                self.state = 434
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==ClickHouseParser.COMMA:
                    self.state = 430
                    self.match(ClickHouseParser.COMMA)
                    self.state = 431
                    self.columnDefinitionExpr()
                    self.state = 436
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 437
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = ClickHouseParser.ColumnTypeExprEnumContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 439
                self.identifier()
                self.state = 440
                self.match(ClickHouseParser.LPAREN)
                self.state = 441
                self.enumValue()
                self.state = 446
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==ClickHouseParser.COMMA:
                    self.state = 442
                    self.match(ClickHouseParser.COMMA)
                    self.state = 443
                    self.enumValue()
                    self.state = 448
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 449
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 4:
                localctx = ClickHouseParser.ColumnTypeExprComplexContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 451
                localctx.ttype = self.tupleOrArrayName()
                self.state = 452
                self.match(ClickHouseParser.LPAREN)
                self.state = 454
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.AFTER) | (1 << ClickHouseParser.ALIAS) | (1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ALTER) | (1 << ClickHouseParser.AND) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ARRAY) | (1 << ClickHouseParser.AS) | (1 << ClickHouseParser.ASCENDING) | (1 << ClickHouseParser.ASOF) | (1 << ClickHouseParser.ASYNC) | (1 << ClickHouseParser.ATTACH) | (1 << ClickHouseParser.AVG) | (1 << ClickHouseParser.BETWEEN) | (1 << ClickHouseParser.BOTH) | (1 << ClickHouseParser.BY) | (1 << ClickHouseParser.CASE) | (1 << ClickHouseParser.CAST) | (1 << ClickHouseParser.CHECK) | (1 << ClickHouseParser.CLEAR) | (1 << ClickHouseParser.CLUSTER) | (1 << ClickHouseParser.CODEC) | (1 << ClickHouseParser.COLLATE) | (1 << ClickHouseParser.COLUMN) | (1 << ClickHouseParser.COMMENT) | (1 << ClickHouseParser.CONSTRAINT) | (1 << ClickHouseParser.COUNT) | (1 << ClickHouseParser.CREATE) | (1 << ClickHouseParser.CROSS) | (1 << ClickHouseParser.CUBE) | (1 << ClickHouseParser.DATABASE) | (1 << ClickHouseParser.DATABASES) | (1 << ClickHouseParser.DATE) | (1 << ClickHouseParser.DAY) | (1 << ClickHouseParser.DEDUPLICATE) | (1 << ClickHouseParser.DEFAULT) | (1 << ClickHouseParser.DELAY) | (1 << ClickHouseParser.DELETE) | (1 << ClickHouseParser.DESC) | (1 << ClickHouseParser.DESCENDING) | (1 << ClickHouseParser.DESCRIBE) | (1 << ClickHouseParser.DETACH) | (1 << ClickHouseParser.DICTIONARIES) | (1 << ClickHouseParser.DICTIONARY) | (1 << ClickHouseParser.DISK) | (1 << ClickHouseParser.DISTINCT) | (1 << ClickHouseParser.DISTRIBUTED) | (1 << ClickHouseParser.DROP) | (1 << ClickHouseParser.ELSE) | (1 << ClickHouseParser.END) | (1 << ClickHouseParser.ENGINE) | (1 << ClickHouseParser.EVENTS) | (1 << ClickHouseParser.EXISTS) | (1 << ClickHouseParser.EXPLAIN) | (1 << ClickHouseParser.EXPRESSION) | (1 << ClickHouseParser.EXTRACT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ClickHouseParser.FETCHES - 64)) | (1 << (ClickHouseParser.FINAL - 64)) | (1 << (ClickHouseParser.FIRST - 64)) | (1 << (ClickHouseParser.FLUSH - 64)) | (1 << (ClickHouseParser.FOR - 64)) | (1 << (ClickHouseParser.FORMAT - 64)) | (1 << (ClickHouseParser.FREEZE - 64)) | (1 << (ClickHouseParser.FROM - 64)) | (1 << (ClickHouseParser.FULL - 64)) | (1 << (ClickHouseParser.FUNCTION - 64)) | (1 << (ClickHouseParser.GLOBAL - 64)) | (1 << (ClickHouseParser.GRANULARITY - 64)) | (1 << (ClickHouseParser.GROUP - 64)) | (1 << (ClickHouseParser.HAVING - 64)) | (1 << (ClickHouseParser.HIERARCHICAL - 64)) | (1 << (ClickHouseParser.HOUR - 64)) | (1 << (ClickHouseParser.ID - 64)) | (1 << (ClickHouseParser.IF - 64)) | (1 << (ClickHouseParser.IIF - 64)) | (1 << (ClickHouseParser.ILIKE - 64)) | (1 << (ClickHouseParser.IN - 64)) | (1 << (ClickHouseParser.INDEX - 64)) | (1 << (ClickHouseParser.INF - 64)) | (1 << (ClickHouseParser.INJECTIVE - 64)) | (1 << (ClickHouseParser.INNER - 64)) | (1 << (ClickHouseParser.INSERT - 64)) | (1 << (ClickHouseParser.INTERVAL - 64)) | (1 << (ClickHouseParser.INTO - 64)) | (1 << (ClickHouseParser.IS - 64)) | (1 << (ClickHouseParser.IS_OBJECT_ID - 64)) | (1 << (ClickHouseParser.JOIN - 64)) | (1 << (ClickHouseParser.KEY - 64)) | (1 << (ClickHouseParser.KILL - 64)) | (1 << (ClickHouseParser.LAST - 64)) | (1 << (ClickHouseParser.LAYOUT - 64)) | (1 << (ClickHouseParser.LEADING - 64)) | (1 << (ClickHouseParser.LEFT - 64)) | (1 << (ClickHouseParser.LIFETIME - 64)) | (1 << (ClickHouseParser.LIKE - 64)) | (1 << (ClickHouseParser.LIMIT - 64)) | (1 << (ClickHouseParser.LIVE - 64)) | (1 << (ClickHouseParser.LOCAL - 64)) | (1 << (ClickHouseParser.LOGS - 64)) | (1 << (ClickHouseParser.MATERIALIZED - 64)) | (1 << (ClickHouseParser.MAX - 64)) | (1 << (ClickHouseParser.MERGES - 64)) | (1 << (ClickHouseParser.MIN - 64)) | (1 << (ClickHouseParser.MINUTE - 64)) | (1 << (ClickHouseParser.MODIFY - 64)) | (1 << (ClickHouseParser.MONTH - 64)) | (1 << (ClickHouseParser.MOVE - 64)) | (1 << (ClickHouseParser.MUTATION - 64)) | (1 << (ClickHouseParser.MULTIIF - 64)) | (1 << (ClickHouseParser.NAN_SQL - 64)) | (1 << (ClickHouseParser.NO - 64)) | (1 << (ClickHouseParser.NOT - 64)) | (1 << (ClickHouseParser.NULL_SQL - 64)) | (1 << (ClickHouseParser.NULLS - 64)) | (1 << (ClickHouseParser.OFFSET - 64)) | (1 << (ClickHouseParser.ON - 64)) | (1 << (ClickHouseParser.OPTIMIZE - 64)) | (1 << (ClickHouseParser.OR - 64)) | (1 << (ClickHouseParser.ORDER - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (ClickHouseParser.OUTER - 128)) | (1 << (ClickHouseParser.OUTFILE - 128)) | (1 << (ClickHouseParser.PARTITION - 128)) | (1 << (ClickHouseParser.PERCENTILE_CONT - 128)) | (1 << (ClickHouseParser.PERCENTILE_DISC - 128)) | (1 << (ClickHouseParser.POPULATE - 128)) | (1 << (ClickHouseParser.POW - 128)) | (1 << (ClickHouseParser.POWER - 128)) | (1 << (ClickHouseParser.PREWHERE - 128)) | (1 << (ClickHouseParser.PRIMARY - 128)) | (1 << (ClickHouseParser.QUARTER - 128)) | (1 << (ClickHouseParser.RANGE - 128)) | (1 << (ClickHouseParser.RELOAD - 128)) | (1 << (ClickHouseParser.REMOVE - 128)) | (1 << (ClickHouseParser.RENAME - 128)) | (1 << (ClickHouseParser.REPLACE - 128)) | (1 << (ClickHouseParser.REPLICA - 128)) | (1 << (ClickHouseParser.REPLICATED - 128)) | (1 << (ClickHouseParser.RIGHT - 128)) | (1 << (ClickHouseParser.ROLLUP - 128)) | (1 << (ClickHouseParser.SAMPLE - 128)) | (1 << (ClickHouseParser.SECOND - 128)) | (1 << (ClickHouseParser.SELECT - 128)) | (1 << (ClickHouseParser.SEMI - 128)) | (1 << (ClickHouseParser.SENDS - 128)) | (1 << (ClickHouseParser.SET - 128)) | (1 << (ClickHouseParser.SETTINGS - 128)) | (1 << (ClickHouseParser.SHOW - 128)) | (1 << (ClickHouseParser.SOURCE - 128)) | (1 << (ClickHouseParser.START - 128)) | (1 << (ClickHouseParser.STD - 128)) | (1 << (ClickHouseParser.STDDEV - 128)) | (1 << (ClickHouseParser.STDDEVPOP - 128)) | (1 << (ClickHouseParser.STOP - 128)) | (1 << (ClickHouseParser.SUBSTRING - 128)) | (1 << (ClickHouseParser.SUM - 128)) | (1 << (ClickHouseParser.SYNC - 128)) | (1 << (ClickHouseParser.SYNTAX - 128)) | (1 << (ClickHouseParser.SYSTEM - 128)) | (1 << (ClickHouseParser.TABLE - 128)) | (1 << (ClickHouseParser.TABLES - 128)) | (1 << (ClickHouseParser.TEMPORARY - 128)) | (1 << (ClickHouseParser.TEST - 128)) | (1 << (ClickHouseParser.THEN - 128)) | (1 << (ClickHouseParser.TIES - 128)) | (1 << (ClickHouseParser.TIMEOUT - 128)) | (1 << (ClickHouseParser.TIMESTAMP - 128)) | (1 << (ClickHouseParser.TO - 128)) | (1 << (ClickHouseParser.TOP - 128)) | (1 << (ClickHouseParser.TOTALS - 128)) | (1 << (ClickHouseParser.TRAILING - 128)) | (1 << (ClickHouseParser.TRIM - 128)) | (1 << (ClickHouseParser.TRUNCATE - 128)) | (1 << (ClickHouseParser.TTL - 128)) | (1 << (ClickHouseParser.TYPE - 128)) | (1 << (ClickHouseParser.UNION - 128)) | (1 << (ClickHouseParser.UPDATE - 128)) | (1 << (ClickHouseParser.USE - 128)) | (1 << (ClickHouseParser.USING - 128)) | (1 << (ClickHouseParser.UUID - 128)) | (1 << (ClickHouseParser.VALUES - 128)) | (1 << (ClickHouseParser.VIEW - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (ClickHouseParser.VOLUME - 192)) | (1 << (ClickHouseParser.WATCH - 192)) | (1 << (ClickHouseParser.WEEK - 192)) | (1 << (ClickHouseParser.VAR - 192)) | (1 << (ClickHouseParser.VARPOP - 192)) | (1 << (ClickHouseParser.VARIANCE - 192)) | (1 << (ClickHouseParser.WHEN - 192)) | (1 << (ClickHouseParser.WHERE - 192)) | (1 << (ClickHouseParser.WITH - 192)) | (1 << (ClickHouseParser.YEAR - 192)) | (1 << (ClickHouseParser.JSON_FALSE - 192)) | (1 << (ClickHouseParser.JSON_TRUE - 192)) | (1 << (ClickHouseParser.IDENTIFIER - 192)) | (1 << (ClickHouseParser.FLOATING_LITERAL - 192)) | (1 << (ClickHouseParser.OCTAL_LITERAL - 192)) | (1 << (ClickHouseParser.DECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.HEXADECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.STRING_LITERAL - 192)) | (1 << (ClickHouseParser.ASTERISK - 192)) | (1 << (ClickHouseParser.DASH - 192)) | (1 << (ClickHouseParser.DOT - 192)) | (1 << (ClickHouseParser.LBRACKET - 192)) | (1 << (ClickHouseParser.LPAREN - 192)) | (1 << (ClickHouseParser.PLUS - 192)))) != 0):
                    self.state = 453
                    self.columnExprList()


                self.state = 456
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 5:
                localctx = ClickHouseParser.ColumnTypeDecimalContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 458
                localctx.decimaltype = self.decimalTypeName()
                self.state = 459
                self.match(ClickHouseParser.LPAREN)
                self.state = 461
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.AFTER) | (1 << ClickHouseParser.ALIAS) | (1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ALTER) | (1 << ClickHouseParser.AND) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ARRAY) | (1 << ClickHouseParser.AS) | (1 << ClickHouseParser.ASCENDING) | (1 << ClickHouseParser.ASOF) | (1 << ClickHouseParser.ASYNC) | (1 << ClickHouseParser.ATTACH) | (1 << ClickHouseParser.AVG) | (1 << ClickHouseParser.BETWEEN) | (1 << ClickHouseParser.BOTH) | (1 << ClickHouseParser.BY) | (1 << ClickHouseParser.CASE) | (1 << ClickHouseParser.CAST) | (1 << ClickHouseParser.CHECK) | (1 << ClickHouseParser.CLEAR) | (1 << ClickHouseParser.CLUSTER) | (1 << ClickHouseParser.CODEC) | (1 << ClickHouseParser.COLLATE) | (1 << ClickHouseParser.COLUMN) | (1 << ClickHouseParser.COMMENT) | (1 << ClickHouseParser.CONSTRAINT) | (1 << ClickHouseParser.COUNT) | (1 << ClickHouseParser.CREATE) | (1 << ClickHouseParser.CROSS) | (1 << ClickHouseParser.CUBE) | (1 << ClickHouseParser.DATABASE) | (1 << ClickHouseParser.DATABASES) | (1 << ClickHouseParser.DATE) | (1 << ClickHouseParser.DAY) | (1 << ClickHouseParser.DEDUPLICATE) | (1 << ClickHouseParser.DEFAULT) | (1 << ClickHouseParser.DELAY) | (1 << ClickHouseParser.DELETE) | (1 << ClickHouseParser.DESC) | (1 << ClickHouseParser.DESCENDING) | (1 << ClickHouseParser.DESCRIBE) | (1 << ClickHouseParser.DETACH) | (1 << ClickHouseParser.DICTIONARIES) | (1 << ClickHouseParser.DICTIONARY) | (1 << ClickHouseParser.DISK) | (1 << ClickHouseParser.DISTINCT) | (1 << ClickHouseParser.DISTRIBUTED) | (1 << ClickHouseParser.DROP) | (1 << ClickHouseParser.ELSE) | (1 << ClickHouseParser.END) | (1 << ClickHouseParser.ENGINE) | (1 << ClickHouseParser.EVENTS) | (1 << ClickHouseParser.EXISTS) | (1 << ClickHouseParser.EXPLAIN) | (1 << ClickHouseParser.EXPRESSION) | (1 << ClickHouseParser.EXTRACT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ClickHouseParser.FETCHES - 64)) | (1 << (ClickHouseParser.FINAL - 64)) | (1 << (ClickHouseParser.FIRST - 64)) | (1 << (ClickHouseParser.FLUSH - 64)) | (1 << (ClickHouseParser.FOR - 64)) | (1 << (ClickHouseParser.FORMAT - 64)) | (1 << (ClickHouseParser.FREEZE - 64)) | (1 << (ClickHouseParser.FROM - 64)) | (1 << (ClickHouseParser.FULL - 64)) | (1 << (ClickHouseParser.FUNCTION - 64)) | (1 << (ClickHouseParser.GLOBAL - 64)) | (1 << (ClickHouseParser.GRANULARITY - 64)) | (1 << (ClickHouseParser.GROUP - 64)) | (1 << (ClickHouseParser.HAVING - 64)) | (1 << (ClickHouseParser.HIERARCHICAL - 64)) | (1 << (ClickHouseParser.HOUR - 64)) | (1 << (ClickHouseParser.ID - 64)) | (1 << (ClickHouseParser.IF - 64)) | (1 << (ClickHouseParser.IIF - 64)) | (1 << (ClickHouseParser.ILIKE - 64)) | (1 << (ClickHouseParser.IN - 64)) | (1 << (ClickHouseParser.INDEX - 64)) | (1 << (ClickHouseParser.INF - 64)) | (1 << (ClickHouseParser.INJECTIVE - 64)) | (1 << (ClickHouseParser.INNER - 64)) | (1 << (ClickHouseParser.INSERT - 64)) | (1 << (ClickHouseParser.INTERVAL - 64)) | (1 << (ClickHouseParser.INTO - 64)) | (1 << (ClickHouseParser.IS - 64)) | (1 << (ClickHouseParser.IS_OBJECT_ID - 64)) | (1 << (ClickHouseParser.JOIN - 64)) | (1 << (ClickHouseParser.KEY - 64)) | (1 << (ClickHouseParser.KILL - 64)) | (1 << (ClickHouseParser.LAST - 64)) | (1 << (ClickHouseParser.LAYOUT - 64)) | (1 << (ClickHouseParser.LEADING - 64)) | (1 << (ClickHouseParser.LEFT - 64)) | (1 << (ClickHouseParser.LIFETIME - 64)) | (1 << (ClickHouseParser.LIKE - 64)) | (1 << (ClickHouseParser.LIMIT - 64)) | (1 << (ClickHouseParser.LIVE - 64)) | (1 << (ClickHouseParser.LOCAL - 64)) | (1 << (ClickHouseParser.LOGS - 64)) | (1 << (ClickHouseParser.MATERIALIZED - 64)) | (1 << (ClickHouseParser.MAX - 64)) | (1 << (ClickHouseParser.MERGES - 64)) | (1 << (ClickHouseParser.MIN - 64)) | (1 << (ClickHouseParser.MINUTE - 64)) | (1 << (ClickHouseParser.MODIFY - 64)) | (1 << (ClickHouseParser.MONTH - 64)) | (1 << (ClickHouseParser.MOVE - 64)) | (1 << (ClickHouseParser.MUTATION - 64)) | (1 << (ClickHouseParser.MULTIIF - 64)) | (1 << (ClickHouseParser.NAN_SQL - 64)) | (1 << (ClickHouseParser.NO - 64)) | (1 << (ClickHouseParser.NOT - 64)) | (1 << (ClickHouseParser.NULL_SQL - 64)) | (1 << (ClickHouseParser.NULLS - 64)) | (1 << (ClickHouseParser.OFFSET - 64)) | (1 << (ClickHouseParser.ON - 64)) | (1 << (ClickHouseParser.OPTIMIZE - 64)) | (1 << (ClickHouseParser.OR - 64)) | (1 << (ClickHouseParser.ORDER - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (ClickHouseParser.OUTER - 128)) | (1 << (ClickHouseParser.OUTFILE - 128)) | (1 << (ClickHouseParser.PARTITION - 128)) | (1 << (ClickHouseParser.PERCENTILE_CONT - 128)) | (1 << (ClickHouseParser.PERCENTILE_DISC - 128)) | (1 << (ClickHouseParser.POPULATE - 128)) | (1 << (ClickHouseParser.POW - 128)) | (1 << (ClickHouseParser.POWER - 128)) | (1 << (ClickHouseParser.PREWHERE - 128)) | (1 << (ClickHouseParser.PRIMARY - 128)) | (1 << (ClickHouseParser.QUARTER - 128)) | (1 << (ClickHouseParser.RANGE - 128)) | (1 << (ClickHouseParser.RELOAD - 128)) | (1 << (ClickHouseParser.REMOVE - 128)) | (1 << (ClickHouseParser.RENAME - 128)) | (1 << (ClickHouseParser.REPLACE - 128)) | (1 << (ClickHouseParser.REPLICA - 128)) | (1 << (ClickHouseParser.REPLICATED - 128)) | (1 << (ClickHouseParser.RIGHT - 128)) | (1 << (ClickHouseParser.ROLLUP - 128)) | (1 << (ClickHouseParser.SAMPLE - 128)) | (1 << (ClickHouseParser.SECOND - 128)) | (1 << (ClickHouseParser.SELECT - 128)) | (1 << (ClickHouseParser.SEMI - 128)) | (1 << (ClickHouseParser.SENDS - 128)) | (1 << (ClickHouseParser.SET - 128)) | (1 << (ClickHouseParser.SETTINGS - 128)) | (1 << (ClickHouseParser.SHOW - 128)) | (1 << (ClickHouseParser.SOURCE - 128)) | (1 << (ClickHouseParser.START - 128)) | (1 << (ClickHouseParser.STD - 128)) | (1 << (ClickHouseParser.STDDEV - 128)) | (1 << (ClickHouseParser.STDDEVPOP - 128)) | (1 << (ClickHouseParser.STOP - 128)) | (1 << (ClickHouseParser.SUBSTRING - 128)) | (1 << (ClickHouseParser.SUM - 128)) | (1 << (ClickHouseParser.SYNC - 128)) | (1 << (ClickHouseParser.SYNTAX - 128)) | (1 << (ClickHouseParser.SYSTEM - 128)) | (1 << (ClickHouseParser.TABLE - 128)) | (1 << (ClickHouseParser.TABLES - 128)) | (1 << (ClickHouseParser.TEMPORARY - 128)) | (1 << (ClickHouseParser.TEST - 128)) | (1 << (ClickHouseParser.THEN - 128)) | (1 << (ClickHouseParser.TIES - 128)) | (1 << (ClickHouseParser.TIMEOUT - 128)) | (1 << (ClickHouseParser.TIMESTAMP - 128)) | (1 << (ClickHouseParser.TO - 128)) | (1 << (ClickHouseParser.TOP - 128)) | (1 << (ClickHouseParser.TOTALS - 128)) | (1 << (ClickHouseParser.TRAILING - 128)) | (1 << (ClickHouseParser.TRIM - 128)) | (1 << (ClickHouseParser.TRUNCATE - 128)) | (1 << (ClickHouseParser.TTL - 128)) | (1 << (ClickHouseParser.TYPE - 128)) | (1 << (ClickHouseParser.UNION - 128)) | (1 << (ClickHouseParser.UPDATE - 128)) | (1 << (ClickHouseParser.USE - 128)) | (1 << (ClickHouseParser.USING - 128)) | (1 << (ClickHouseParser.UUID - 128)) | (1 << (ClickHouseParser.VALUES - 128)) | (1 << (ClickHouseParser.VIEW - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (ClickHouseParser.VOLUME - 192)) | (1 << (ClickHouseParser.WATCH - 192)) | (1 << (ClickHouseParser.WEEK - 192)) | (1 << (ClickHouseParser.VAR - 192)) | (1 << (ClickHouseParser.VARPOP - 192)) | (1 << (ClickHouseParser.VARIANCE - 192)) | (1 << (ClickHouseParser.WHEN - 192)) | (1 << (ClickHouseParser.WHERE - 192)) | (1 << (ClickHouseParser.WITH - 192)) | (1 << (ClickHouseParser.YEAR - 192)) | (1 << (ClickHouseParser.JSON_FALSE - 192)) | (1 << (ClickHouseParser.JSON_TRUE - 192)) | (1 << (ClickHouseParser.IDENTIFIER - 192)) | (1 << (ClickHouseParser.FLOATING_LITERAL - 192)) | (1 << (ClickHouseParser.OCTAL_LITERAL - 192)) | (1 << (ClickHouseParser.DECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.HEXADECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.STRING_LITERAL - 192)) | (1 << (ClickHouseParser.ASTERISK - 192)) | (1 << (ClickHouseParser.DASH - 192)) | (1 << (ClickHouseParser.DOT - 192)) | (1 << (ClickHouseParser.LBRACKET - 192)) | (1 << (ClickHouseParser.LPAREN - 192)) | (1 << (ClickHouseParser.PLUS - 192)))) != 0):
                    self.state = 460
                    self.columnExprList()


                self.state = 463
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 6:
                localctx = ClickHouseParser.ColumnTypeExprParamContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 465
                self.identifier()
                self.state = 466
                self.match(ClickHouseParser.LPAREN)
                self.state = 468
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.AFTER) | (1 << ClickHouseParser.ALIAS) | (1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ALTER) | (1 << ClickHouseParser.AND) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ARRAY) | (1 << ClickHouseParser.AS) | (1 << ClickHouseParser.ASCENDING) | (1 << ClickHouseParser.ASOF) | (1 << ClickHouseParser.ASYNC) | (1 << ClickHouseParser.ATTACH) | (1 << ClickHouseParser.AVG) | (1 << ClickHouseParser.BETWEEN) | (1 << ClickHouseParser.BOTH) | (1 << ClickHouseParser.BY) | (1 << ClickHouseParser.CASE) | (1 << ClickHouseParser.CAST) | (1 << ClickHouseParser.CHECK) | (1 << ClickHouseParser.CLEAR) | (1 << ClickHouseParser.CLUSTER) | (1 << ClickHouseParser.CODEC) | (1 << ClickHouseParser.COLLATE) | (1 << ClickHouseParser.COLUMN) | (1 << ClickHouseParser.COMMENT) | (1 << ClickHouseParser.CONSTRAINT) | (1 << ClickHouseParser.COUNT) | (1 << ClickHouseParser.CREATE) | (1 << ClickHouseParser.CROSS) | (1 << ClickHouseParser.CUBE) | (1 << ClickHouseParser.DATABASE) | (1 << ClickHouseParser.DATABASES) | (1 << ClickHouseParser.DATE) | (1 << ClickHouseParser.DAY) | (1 << ClickHouseParser.DEDUPLICATE) | (1 << ClickHouseParser.DEFAULT) | (1 << ClickHouseParser.DELAY) | (1 << ClickHouseParser.DELETE) | (1 << ClickHouseParser.DESC) | (1 << ClickHouseParser.DESCENDING) | (1 << ClickHouseParser.DESCRIBE) | (1 << ClickHouseParser.DETACH) | (1 << ClickHouseParser.DICTIONARIES) | (1 << ClickHouseParser.DICTIONARY) | (1 << ClickHouseParser.DISK) | (1 << ClickHouseParser.DISTINCT) | (1 << ClickHouseParser.DISTRIBUTED) | (1 << ClickHouseParser.DROP) | (1 << ClickHouseParser.ELSE) | (1 << ClickHouseParser.END) | (1 << ClickHouseParser.ENGINE) | (1 << ClickHouseParser.EVENTS) | (1 << ClickHouseParser.EXISTS) | (1 << ClickHouseParser.EXPLAIN) | (1 << ClickHouseParser.EXPRESSION) | (1 << ClickHouseParser.EXTRACT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ClickHouseParser.FETCHES - 64)) | (1 << (ClickHouseParser.FINAL - 64)) | (1 << (ClickHouseParser.FIRST - 64)) | (1 << (ClickHouseParser.FLUSH - 64)) | (1 << (ClickHouseParser.FOR - 64)) | (1 << (ClickHouseParser.FORMAT - 64)) | (1 << (ClickHouseParser.FREEZE - 64)) | (1 << (ClickHouseParser.FROM - 64)) | (1 << (ClickHouseParser.FULL - 64)) | (1 << (ClickHouseParser.FUNCTION - 64)) | (1 << (ClickHouseParser.GLOBAL - 64)) | (1 << (ClickHouseParser.GRANULARITY - 64)) | (1 << (ClickHouseParser.GROUP - 64)) | (1 << (ClickHouseParser.HAVING - 64)) | (1 << (ClickHouseParser.HIERARCHICAL - 64)) | (1 << (ClickHouseParser.HOUR - 64)) | (1 << (ClickHouseParser.ID - 64)) | (1 << (ClickHouseParser.IF - 64)) | (1 << (ClickHouseParser.IIF - 64)) | (1 << (ClickHouseParser.ILIKE - 64)) | (1 << (ClickHouseParser.IN - 64)) | (1 << (ClickHouseParser.INDEX - 64)) | (1 << (ClickHouseParser.INF - 64)) | (1 << (ClickHouseParser.INJECTIVE - 64)) | (1 << (ClickHouseParser.INNER - 64)) | (1 << (ClickHouseParser.INSERT - 64)) | (1 << (ClickHouseParser.INTERVAL - 64)) | (1 << (ClickHouseParser.INTO - 64)) | (1 << (ClickHouseParser.IS - 64)) | (1 << (ClickHouseParser.IS_OBJECT_ID - 64)) | (1 << (ClickHouseParser.JOIN - 64)) | (1 << (ClickHouseParser.KEY - 64)) | (1 << (ClickHouseParser.KILL - 64)) | (1 << (ClickHouseParser.LAST - 64)) | (1 << (ClickHouseParser.LAYOUT - 64)) | (1 << (ClickHouseParser.LEADING - 64)) | (1 << (ClickHouseParser.LEFT - 64)) | (1 << (ClickHouseParser.LIFETIME - 64)) | (1 << (ClickHouseParser.LIKE - 64)) | (1 << (ClickHouseParser.LIMIT - 64)) | (1 << (ClickHouseParser.LIVE - 64)) | (1 << (ClickHouseParser.LOCAL - 64)) | (1 << (ClickHouseParser.LOGS - 64)) | (1 << (ClickHouseParser.MATERIALIZED - 64)) | (1 << (ClickHouseParser.MAX - 64)) | (1 << (ClickHouseParser.MERGES - 64)) | (1 << (ClickHouseParser.MIN - 64)) | (1 << (ClickHouseParser.MINUTE - 64)) | (1 << (ClickHouseParser.MODIFY - 64)) | (1 << (ClickHouseParser.MONTH - 64)) | (1 << (ClickHouseParser.MOVE - 64)) | (1 << (ClickHouseParser.MUTATION - 64)) | (1 << (ClickHouseParser.MULTIIF - 64)) | (1 << (ClickHouseParser.NAN_SQL - 64)) | (1 << (ClickHouseParser.NO - 64)) | (1 << (ClickHouseParser.NOT - 64)) | (1 << (ClickHouseParser.NULL_SQL - 64)) | (1 << (ClickHouseParser.NULLS - 64)) | (1 << (ClickHouseParser.OFFSET - 64)) | (1 << (ClickHouseParser.ON - 64)) | (1 << (ClickHouseParser.OPTIMIZE - 64)) | (1 << (ClickHouseParser.OR - 64)) | (1 << (ClickHouseParser.ORDER - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (ClickHouseParser.OUTER - 128)) | (1 << (ClickHouseParser.OUTFILE - 128)) | (1 << (ClickHouseParser.PARTITION - 128)) | (1 << (ClickHouseParser.PERCENTILE_CONT - 128)) | (1 << (ClickHouseParser.PERCENTILE_DISC - 128)) | (1 << (ClickHouseParser.POPULATE - 128)) | (1 << (ClickHouseParser.POW - 128)) | (1 << (ClickHouseParser.POWER - 128)) | (1 << (ClickHouseParser.PREWHERE - 128)) | (1 << (ClickHouseParser.PRIMARY - 128)) | (1 << (ClickHouseParser.QUARTER - 128)) | (1 << (ClickHouseParser.RANGE - 128)) | (1 << (ClickHouseParser.RELOAD - 128)) | (1 << (ClickHouseParser.REMOVE - 128)) | (1 << (ClickHouseParser.RENAME - 128)) | (1 << (ClickHouseParser.REPLACE - 128)) | (1 << (ClickHouseParser.REPLICA - 128)) | (1 << (ClickHouseParser.REPLICATED - 128)) | (1 << (ClickHouseParser.RIGHT - 128)) | (1 << (ClickHouseParser.ROLLUP - 128)) | (1 << (ClickHouseParser.SAMPLE - 128)) | (1 << (ClickHouseParser.SECOND - 128)) | (1 << (ClickHouseParser.SELECT - 128)) | (1 << (ClickHouseParser.SEMI - 128)) | (1 << (ClickHouseParser.SENDS - 128)) | (1 << (ClickHouseParser.SET - 128)) | (1 << (ClickHouseParser.SETTINGS - 128)) | (1 << (ClickHouseParser.SHOW - 128)) | (1 << (ClickHouseParser.SOURCE - 128)) | (1 << (ClickHouseParser.START - 128)) | (1 << (ClickHouseParser.STD - 128)) | (1 << (ClickHouseParser.STDDEV - 128)) | (1 << (ClickHouseParser.STDDEVPOP - 128)) | (1 << (ClickHouseParser.STOP - 128)) | (1 << (ClickHouseParser.SUBSTRING - 128)) | (1 << (ClickHouseParser.SUM - 128)) | (1 << (ClickHouseParser.SYNC - 128)) | (1 << (ClickHouseParser.SYNTAX - 128)) | (1 << (ClickHouseParser.SYSTEM - 128)) | (1 << (ClickHouseParser.TABLE - 128)) | (1 << (ClickHouseParser.TABLES - 128)) | (1 << (ClickHouseParser.TEMPORARY - 128)) | (1 << (ClickHouseParser.TEST - 128)) | (1 << (ClickHouseParser.THEN - 128)) | (1 << (ClickHouseParser.TIES - 128)) | (1 << (ClickHouseParser.TIMEOUT - 128)) | (1 << (ClickHouseParser.TIMESTAMP - 128)) | (1 << (ClickHouseParser.TO - 128)) | (1 << (ClickHouseParser.TOP - 128)) | (1 << (ClickHouseParser.TOTALS - 128)) | (1 << (ClickHouseParser.TRAILING - 128)) | (1 << (ClickHouseParser.TRIM - 128)) | (1 << (ClickHouseParser.TRUNCATE - 128)) | (1 << (ClickHouseParser.TTL - 128)) | (1 << (ClickHouseParser.TYPE - 128)) | (1 << (ClickHouseParser.UNION - 128)) | (1 << (ClickHouseParser.UPDATE - 128)) | (1 << (ClickHouseParser.USE - 128)) | (1 << (ClickHouseParser.USING - 128)) | (1 << (ClickHouseParser.UUID - 128)) | (1 << (ClickHouseParser.VALUES - 128)) | (1 << (ClickHouseParser.VIEW - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (ClickHouseParser.VOLUME - 192)) | (1 << (ClickHouseParser.WATCH - 192)) | (1 << (ClickHouseParser.WEEK - 192)) | (1 << (ClickHouseParser.VAR - 192)) | (1 << (ClickHouseParser.VARPOP - 192)) | (1 << (ClickHouseParser.VARIANCE - 192)) | (1 << (ClickHouseParser.WHEN - 192)) | (1 << (ClickHouseParser.WHERE - 192)) | (1 << (ClickHouseParser.WITH - 192)) | (1 << (ClickHouseParser.YEAR - 192)) | (1 << (ClickHouseParser.JSON_FALSE - 192)) | (1 << (ClickHouseParser.JSON_TRUE - 192)) | (1 << (ClickHouseParser.IDENTIFIER - 192)) | (1 << (ClickHouseParser.FLOATING_LITERAL - 192)) | (1 << (ClickHouseParser.OCTAL_LITERAL - 192)) | (1 << (ClickHouseParser.DECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.HEXADECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.STRING_LITERAL - 192)) | (1 << (ClickHouseParser.ASTERISK - 192)) | (1 << (ClickHouseParser.DASH - 192)) | (1 << (ClickHouseParser.DOT - 192)) | (1 << (ClickHouseParser.LBRACKET - 192)) | (1 << (ClickHouseParser.LPAREN - 192)) | (1 << (ClickHouseParser.PLUS - 192)))) != 0):
                    self.state = 467
                    self.columnExprList()


                self.state = 470
                self.match(ClickHouseParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnDefinitionExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)


        def columnTypeExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnTypeExprContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_columnDefinitionExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnDefinitionExpr" ):
                listener.enterColumnDefinitionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnDefinitionExpr" ):
                listener.exitColumnDefinitionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnDefinitionExpr" ):
                return visitor.visitColumnDefinitionExpr(self)
            else:
                return visitor.visitChildren(self)




    def columnDefinitionExpr(self):

        localctx = ClickHouseParser.ColumnDefinitionExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_columnDefinitionExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 474
            self.identifier()
            self.state = 475
            self.columnTypeExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnExprListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnsExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnsExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnsExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_columnExprList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprList" ):
                listener.enterColumnExprList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprList" ):
                listener.exitColumnExprList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprList" ):
                return visitor.visitColumnExprList(self)
            else:
                return visitor.visitChildren(self)




    def columnExprList(self):

        localctx = ClickHouseParser.ColumnExprListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_columnExprList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 477
            self.columnsExpr()
            self.state = 482
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,61,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 478
                    self.match(ClickHouseParser.COMMA)
                    self.state = 479
                    self.columnsExpr() 
                self.state = 484
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,61,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnExprWhenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHEN(self):
            return self.getToken(ClickHouseParser.WHEN, 0)

        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)


        def THEN(self):
            return self.getToken(ClickHouseParser.THEN, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_columnExprWhen

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprWhen" ):
                listener.enterColumnExprWhen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprWhen" ):
                listener.exitColumnExprWhen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprWhen" ):
                return visitor.visitColumnExprWhen(self)
            else:
                return visitor.visitChildren(self)




    def columnExprWhen(self):

        localctx = ClickHouseParser.ColumnExprWhenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_columnExprWhen)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 485
            self.match(ClickHouseParser.WHEN)
            self.state = 486
            self.columnExpr(0)
            self.state = 487
            self.match(ClickHouseParser.THEN)
            self.state = 488
            self.columnExpr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnsExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ClickHouseParser.RULE_columnsExpr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ColumnsExprColumnContext(ColumnsExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnsExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnsExprColumn" ):
                listener.enterColumnsExprColumn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnsExprColumn" ):
                listener.exitColumnsExprColumn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnsExprColumn" ):
                return visitor.visitColumnsExprColumn(self)
            else:
                return visitor.visitChildren(self)


    class ColumnsExprAsteriskContext(ColumnsExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnsExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ASTERISK(self):
            return self.getToken(ClickHouseParser.ASTERISK, 0)
        def tableIdentifier(self):
            return self.getTypedRuleContext(ClickHouseParser.TableIdentifierContext,0)

        def DOT(self):
            return self.getToken(ClickHouseParser.DOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnsExprAsterisk" ):
                listener.enterColumnsExprAsterisk(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnsExprAsterisk" ):
                listener.exitColumnsExprAsterisk(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnsExprAsterisk" ):
                return visitor.visitColumnsExprAsterisk(self)
            else:
                return visitor.visitChildren(self)


    class ColumnsExprSubqueryContext(ColumnsExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnsExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def selectUnionStmt(self):
            return self.getTypedRuleContext(ClickHouseParser.SelectUnionStmtContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnsExprSubquery" ):
                listener.enterColumnsExprSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnsExprSubquery" ):
                listener.exitColumnsExprSubquery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnsExprSubquery" ):
                return visitor.visitColumnsExprSubquery(self)
            else:
                return visitor.visitChildren(self)



    def columnsExpr(self):

        localctx = ClickHouseParser.ColumnsExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_columnsExpr)
        self._la = 0 # Token type
        try:
            self.state = 501
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
            if la_ == 1:
                localctx = ClickHouseParser.ColumnsExprAsteriskContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 493
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.AFTER) | (1 << ClickHouseParser.ALIAS) | (1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ALTER) | (1 << ClickHouseParser.AND) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ARRAY) | (1 << ClickHouseParser.AS) | (1 << ClickHouseParser.ASCENDING) | (1 << ClickHouseParser.ASOF) | (1 << ClickHouseParser.ASYNC) | (1 << ClickHouseParser.ATTACH) | (1 << ClickHouseParser.BETWEEN) | (1 << ClickHouseParser.BOTH) | (1 << ClickHouseParser.BY) | (1 << ClickHouseParser.CASE) | (1 << ClickHouseParser.CAST) | (1 << ClickHouseParser.CHECK) | (1 << ClickHouseParser.CLEAR) | (1 << ClickHouseParser.CLUSTER) | (1 << ClickHouseParser.CODEC) | (1 << ClickHouseParser.COLLATE) | (1 << ClickHouseParser.COLUMN) | (1 << ClickHouseParser.COMMENT) | (1 << ClickHouseParser.CONSTRAINT) | (1 << ClickHouseParser.CREATE) | (1 << ClickHouseParser.CROSS) | (1 << ClickHouseParser.CUBE) | (1 << ClickHouseParser.DATABASE) | (1 << ClickHouseParser.DATABASES) | (1 << ClickHouseParser.DATE) | (1 << ClickHouseParser.DAY) | (1 << ClickHouseParser.DEDUPLICATE) | (1 << ClickHouseParser.DEFAULT) | (1 << ClickHouseParser.DELAY) | (1 << ClickHouseParser.DELETE) | (1 << ClickHouseParser.DESC) | (1 << ClickHouseParser.DESCENDING) | (1 << ClickHouseParser.DESCRIBE) | (1 << ClickHouseParser.DETACH) | (1 << ClickHouseParser.DICTIONARIES) | (1 << ClickHouseParser.DICTIONARY) | (1 << ClickHouseParser.DISK) | (1 << ClickHouseParser.DISTINCT) | (1 << ClickHouseParser.DISTRIBUTED) | (1 << ClickHouseParser.DROP) | (1 << ClickHouseParser.ELSE) | (1 << ClickHouseParser.END) | (1 << ClickHouseParser.ENGINE) | (1 << ClickHouseParser.EVENTS) | (1 << ClickHouseParser.EXISTS) | (1 << ClickHouseParser.EXPLAIN) | (1 << ClickHouseParser.EXPRESSION) | (1 << ClickHouseParser.EXTRACT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ClickHouseParser.FETCHES - 64)) | (1 << (ClickHouseParser.FINAL - 64)) | (1 << (ClickHouseParser.FIRST - 64)) | (1 << (ClickHouseParser.FLUSH - 64)) | (1 << (ClickHouseParser.FOR - 64)) | (1 << (ClickHouseParser.FORMAT - 64)) | (1 << (ClickHouseParser.FREEZE - 64)) | (1 << (ClickHouseParser.FROM - 64)) | (1 << (ClickHouseParser.FULL - 64)) | (1 << (ClickHouseParser.FUNCTION - 64)) | (1 << (ClickHouseParser.GLOBAL - 64)) | (1 << (ClickHouseParser.GRANULARITY - 64)) | (1 << (ClickHouseParser.GROUP - 64)) | (1 << (ClickHouseParser.HAVING - 64)) | (1 << (ClickHouseParser.HIERARCHICAL - 64)) | (1 << (ClickHouseParser.HOUR - 64)) | (1 << (ClickHouseParser.ID - 64)) | (1 << (ClickHouseParser.IF - 64)) | (1 << (ClickHouseParser.ILIKE - 64)) | (1 << (ClickHouseParser.IN - 64)) | (1 << (ClickHouseParser.INDEX - 64)) | (1 << (ClickHouseParser.INJECTIVE - 64)) | (1 << (ClickHouseParser.INNER - 64)) | (1 << (ClickHouseParser.INSERT - 64)) | (1 << (ClickHouseParser.INTERVAL - 64)) | (1 << (ClickHouseParser.INTO - 64)) | (1 << (ClickHouseParser.IS - 64)) | (1 << (ClickHouseParser.IS_OBJECT_ID - 64)) | (1 << (ClickHouseParser.JOIN - 64)) | (1 << (ClickHouseParser.KEY - 64)) | (1 << (ClickHouseParser.KILL - 64)) | (1 << (ClickHouseParser.LAST - 64)) | (1 << (ClickHouseParser.LAYOUT - 64)) | (1 << (ClickHouseParser.LEADING - 64)) | (1 << (ClickHouseParser.LEFT - 64)) | (1 << (ClickHouseParser.LIFETIME - 64)) | (1 << (ClickHouseParser.LIKE - 64)) | (1 << (ClickHouseParser.LIMIT - 64)) | (1 << (ClickHouseParser.LIVE - 64)) | (1 << (ClickHouseParser.LOCAL - 64)) | (1 << (ClickHouseParser.LOGS - 64)) | (1 << (ClickHouseParser.MATERIALIZED - 64)) | (1 << (ClickHouseParser.MAX - 64)) | (1 << (ClickHouseParser.MERGES - 64)) | (1 << (ClickHouseParser.MIN - 64)) | (1 << (ClickHouseParser.MINUTE - 64)) | (1 << (ClickHouseParser.MODIFY - 64)) | (1 << (ClickHouseParser.MONTH - 64)) | (1 << (ClickHouseParser.MOVE - 64)) | (1 << (ClickHouseParser.MUTATION - 64)) | (1 << (ClickHouseParser.NO - 64)) | (1 << (ClickHouseParser.NOT - 64)) | (1 << (ClickHouseParser.NULLS - 64)) | (1 << (ClickHouseParser.OFFSET - 64)) | (1 << (ClickHouseParser.ON - 64)) | (1 << (ClickHouseParser.OPTIMIZE - 64)) | (1 << (ClickHouseParser.OR - 64)) | (1 << (ClickHouseParser.ORDER - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (ClickHouseParser.OUTER - 128)) | (1 << (ClickHouseParser.OUTFILE - 128)) | (1 << (ClickHouseParser.PARTITION - 128)) | (1 << (ClickHouseParser.POPULATE - 128)) | (1 << (ClickHouseParser.PREWHERE - 128)) | (1 << (ClickHouseParser.PRIMARY - 128)) | (1 << (ClickHouseParser.QUARTER - 128)) | (1 << (ClickHouseParser.RANGE - 128)) | (1 << (ClickHouseParser.RELOAD - 128)) | (1 << (ClickHouseParser.REMOVE - 128)) | (1 << (ClickHouseParser.RENAME - 128)) | (1 << (ClickHouseParser.REPLACE - 128)) | (1 << (ClickHouseParser.REPLICA - 128)) | (1 << (ClickHouseParser.REPLICATED - 128)) | (1 << (ClickHouseParser.RIGHT - 128)) | (1 << (ClickHouseParser.ROLLUP - 128)) | (1 << (ClickHouseParser.SAMPLE - 128)) | (1 << (ClickHouseParser.SECOND - 128)) | (1 << (ClickHouseParser.SELECT - 128)) | (1 << (ClickHouseParser.SEMI - 128)) | (1 << (ClickHouseParser.SENDS - 128)) | (1 << (ClickHouseParser.SET - 128)) | (1 << (ClickHouseParser.SETTINGS - 128)) | (1 << (ClickHouseParser.SHOW - 128)) | (1 << (ClickHouseParser.SOURCE - 128)) | (1 << (ClickHouseParser.START - 128)) | (1 << (ClickHouseParser.STOP - 128)) | (1 << (ClickHouseParser.SUBSTRING - 128)) | (1 << (ClickHouseParser.SYNC - 128)) | (1 << (ClickHouseParser.SYNTAX - 128)) | (1 << (ClickHouseParser.SYSTEM - 128)) | (1 << (ClickHouseParser.TABLE - 128)) | (1 << (ClickHouseParser.TABLES - 128)) | (1 << (ClickHouseParser.TEMPORARY - 128)) | (1 << (ClickHouseParser.TEST - 128)) | (1 << (ClickHouseParser.THEN - 128)) | (1 << (ClickHouseParser.TIES - 128)) | (1 << (ClickHouseParser.TIMEOUT - 128)) | (1 << (ClickHouseParser.TIMESTAMP - 128)) | (1 << (ClickHouseParser.TO - 128)) | (1 << (ClickHouseParser.TOP - 128)) | (1 << (ClickHouseParser.TOTALS - 128)) | (1 << (ClickHouseParser.TRAILING - 128)) | (1 << (ClickHouseParser.TRIM - 128)) | (1 << (ClickHouseParser.TRUNCATE - 128)) | (1 << (ClickHouseParser.TTL - 128)) | (1 << (ClickHouseParser.TYPE - 128)) | (1 << (ClickHouseParser.UNION - 128)) | (1 << (ClickHouseParser.UPDATE - 128)) | (1 << (ClickHouseParser.USE - 128)) | (1 << (ClickHouseParser.USING - 128)) | (1 << (ClickHouseParser.UUID - 128)) | (1 << (ClickHouseParser.VALUES - 128)) | (1 << (ClickHouseParser.VIEW - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (ClickHouseParser.VOLUME - 192)) | (1 << (ClickHouseParser.WATCH - 192)) | (1 << (ClickHouseParser.WEEK - 192)) | (1 << (ClickHouseParser.WHEN - 192)) | (1 << (ClickHouseParser.WHERE - 192)) | (1 << (ClickHouseParser.WITH - 192)) | (1 << (ClickHouseParser.YEAR - 192)) | (1 << (ClickHouseParser.JSON_FALSE - 192)) | (1 << (ClickHouseParser.JSON_TRUE - 192)) | (1 << (ClickHouseParser.IDENTIFIER - 192)))) != 0):
                    self.state = 490
                    self.tableIdentifier()
                    self.state = 491
                    self.match(ClickHouseParser.DOT)


                self.state = 495
                self.match(ClickHouseParser.ASTERISK)
                pass

            elif la_ == 2:
                localctx = ClickHouseParser.ColumnsExprSubqueryContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 496
                self.match(ClickHouseParser.LPAREN)
                self.state = 497
                self.selectUnionStmt()
                self.state = 498
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = ClickHouseParser.ColumnsExprColumnContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 500
                self.columnExpr(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.case_expr = None # ColumnExprContext
            self.else_expr = None # ColumnExprContext

        def CASE(self):
            return self.getToken(ClickHouseParser.CASE, 0)

        def END(self):
            return self.getToken(ClickHouseParser.END, 0)

        def columnExprWhen(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprWhenContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprWhenContext,i)


        def ELSE(self):
            return self.getToken(ClickHouseParser.ELSE, 0)

        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_caseExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseExpr" ):
                listener.enterCaseExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseExpr" ):
                listener.exitCaseExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseExpr" ):
                return visitor.visitCaseExpr(self)
            else:
                return visitor.visitChildren(self)




    def caseExpr(self):

        localctx = ClickHouseParser.CaseExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_caseExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 503
            self.match(ClickHouseParser.CASE)
            self.state = 505
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,64,self._ctx)
            if la_ == 1:
                self.state = 504
                localctx.case_expr = self.columnExpr(0)


            self.state = 508 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 507
                self.columnExprWhen()
                self.state = 510 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==ClickHouseParser.WHEN):
                    break

            self.state = 514
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.ELSE:
                self.state = 512
                self.match(ClickHouseParser.ELSE)
                self.state = 513
                localctx.else_expr = self.columnExpr(0)


            self.state = 516
            self.match(ClickHouseParser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ClickHouseParser.RULE_columnExpr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class ColumnExprTernaryOpContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)

        def QUERY(self):
            return self.getToken(ClickHouseParser.QUERY, 0)
        def COLON(self):
            return self.getToken(ClickHouseParser.COLON, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprTernaryOp" ):
                listener.enterColumnExprTernaryOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprTernaryOp" ):
                listener.exitColumnExprTernaryOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprTernaryOp" ):
                return visitor.visitColumnExprTernaryOp(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprAliasContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)

        def alias(self):
            return self.getTypedRuleContext(ClickHouseParser.AliasContext,0)

        def AS(self):
            return self.getToken(ClickHouseParser.AS, 0)
        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprAlias" ):
                listener.enterColumnExprAlias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprAlias" ):
                listener.exitColumnExprAlias(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprAlias" ):
                return visitor.visitColumnExprAlias(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprExtractContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXTRACT(self):
            return self.getToken(ClickHouseParser.EXTRACT, 0)
        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def interval(self):
            return self.getTypedRuleContext(ClickHouseParser.IntervalContext,0)

        def FROM(self):
            return self.getToken(ClickHouseParser.FROM, 0)
        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprExtract" ):
                listener.enterColumnExprExtract(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprExtract" ):
                listener.exitColumnExprExtract(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprExtract" ):
                return visitor.visitColumnExprExtract(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprNegateContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DASH(self):
            return self.getToken(ClickHouseParser.DASH, 0)
        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprNegate" ):
                listener.enterColumnExprNegate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprNegate" ):
                listener.exitColumnExprNegate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprNegate" ):
                return visitor.visitColumnExprNegate(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprSubqueryContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def selectUnionStmt(self):
            return self.getTypedRuleContext(ClickHouseParser.SelectUnionStmtContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprSubquery" ):
                listener.enterColumnExprSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprSubquery" ):
                listener.exitColumnExprSubquery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprSubquery" ):
                return visitor.visitColumnExprSubquery(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprLiteralContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def literal(self):
            return self.getTypedRuleContext(ClickHouseParser.LiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprLiteral" ):
                listener.enterColumnExprLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprLiteral" ):
                listener.exitColumnExprLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprLiteral" ):
                return visitor.visitColumnExprLiteral(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprArrayContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LBRACKET(self):
            return self.getToken(ClickHouseParser.LBRACKET, 0)
        def RBRACKET(self):
            return self.getToken(ClickHouseParser.RBRACKET, 0)
        def columnExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprArray" ):
                listener.enterColumnExprArray(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprArray" ):
                listener.exitColumnExprArray(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprArray" ):
                return visitor.visitColumnExprArray(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprSubstringContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SUBSTRING(self):
            return self.getToken(ClickHouseParser.SUBSTRING, 0)
        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)

        def FROM(self):
            return self.getToken(ClickHouseParser.FROM, 0)
        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)
        def FOR(self):
            return self.getToken(ClickHouseParser.FOR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprSubstring" ):
                listener.enterColumnExprSubstring(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprSubstring" ):
                listener.exitColumnExprSubstring(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprSubstring" ):
                return visitor.visitColumnExprSubstring(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprCastContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CAST(self):
            return self.getToken(ClickHouseParser.CAST, 0)
        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)

        def AS(self):
            return self.getToken(ClickHouseParser.AS, 0)
        def columnTypeExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnTypeExprContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprCast" ):
                listener.enterColumnExprCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprCast" ):
                listener.exitColumnExprCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprCast" ):
                return visitor.visitColumnExprCast(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprMultiIfExprContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MULTIIF(self):
            return self.getToken(ClickHouseParser.MULTIIF, 0)
        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def columnArgList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnArgListContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprMultiIfExpr" ):
                listener.enterColumnExprMultiIfExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprMultiIfExpr" ):
                listener.exitColumnExprMultiIfExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprMultiIfExpr" ):
                return visitor.visitColumnExprMultiIfExpr(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprOrContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)

        def OR(self):
            return self.getToken(ClickHouseParser.OR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprOr" ):
                listener.enterColumnExprOr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprOr" ):
                listener.exitColumnExprOr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprOr" ):
                return visitor.visitColumnExprOr(self)
            else:
                return visitor.visitChildren(self)


    class ColumnTypeDefinitionContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)

        def DOUBLECOLON(self):
            return self.getToken(ClickHouseParser.DOUBLECOLON, 0)
        def columnTypeExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnTypeExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnTypeDefinition" ):
                listener.enterColumnTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnTypeDefinition" ):
                listener.exitColumnTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnTypeDefinition" ):
                return visitor.visitColumnTypeDefinition(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprPowFunctionContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)

        def COMMA(self):
            return self.getToken(ClickHouseParser.COMMA, 0)
        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)
        def POW(self):
            return self.getToken(ClickHouseParser.POW, 0)
        def POWER(self):
            return self.getToken(ClickHouseParser.POWER, 0)
        def numberLiteral(self):
            return self.getTypedRuleContext(ClickHouseParser.NumberLiteralContext,0)

        def NULL_SQL(self):
            return self.getToken(ClickHouseParser.NULL_SQL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprPowFunction" ):
                listener.enterColumnExprPowFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprPowFunction" ):
                listener.exitColumnExprPowFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprPowFunction" ):
                return visitor.visitColumnExprPowFunction(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprPrecedence1Context(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)

        def ASTERISK(self):
            return self.getToken(ClickHouseParser.ASTERISK, 0)
        def SLASH(self):
            return self.getToken(ClickHouseParser.SLASH, 0)
        def PERCENT(self):
            return self.getToken(ClickHouseParser.PERCENT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprPrecedence1" ):
                listener.enterColumnExprPrecedence1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprPrecedence1" ):
                listener.exitColumnExprPrecedence1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprPrecedence1" ):
                return visitor.visitColumnExprPrecedence1(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprPrecedence2Context(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)

        def PLUS(self):
            return self.getToken(ClickHouseParser.PLUS, 0)
        def DASH(self):
            return self.getToken(ClickHouseParser.DASH, 0)
        def CONCAT(self):
            return self.getToken(ClickHouseParser.CONCAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprPrecedence2" ):
                listener.enterColumnExprPrecedence2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprPrecedence2" ):
                listener.exitColumnExprPrecedence2(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprPrecedence2" ):
                return visitor.visitColumnExprPrecedence2(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprPrecedence3Context(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)

        def EQ_DOUBLE(self):
            return self.getToken(ClickHouseParser.EQ_DOUBLE, 0)
        def EQ_SINGLE(self):
            return self.getToken(ClickHouseParser.EQ_SINGLE, 0)
        def NOT_EQ(self):
            return self.getToken(ClickHouseParser.NOT_EQ, 0)
        def LE(self):
            return self.getToken(ClickHouseParser.LE, 0)
        def GE(self):
            return self.getToken(ClickHouseParser.GE, 0)
        def LT(self):
            return self.getToken(ClickHouseParser.LT, 0)
        def GT(self):
            return self.getToken(ClickHouseParser.GT, 0)
        def IN(self):
            return self.getToken(ClickHouseParser.IN, 0)
        def LIKE(self):
            return self.getToken(ClickHouseParser.LIKE, 0)
        def ILIKE(self):
            return self.getToken(ClickHouseParser.ILIKE, 0)
        def GLOBAL(self):
            return self.getToken(ClickHouseParser.GLOBAL, 0)
        def NOT(self):
            return self.getToken(ClickHouseParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprPrecedence3" ):
                listener.enterColumnExprPrecedence3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprPrecedence3" ):
                listener.exitColumnExprPrecedence3(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprPrecedence3" ):
                return visitor.visitColumnExprPrecedence3(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprIntervalContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INTERVAL(self):
            return self.getToken(ClickHouseParser.INTERVAL, 0)
        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)

        def interval(self):
            return self.getTypedRuleContext(ClickHouseParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprInterval" ):
                listener.enterColumnExprInterval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprInterval" ):
                listener.exitColumnExprInterval(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprInterval" ):
                return visitor.visitColumnExprInterval(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprIsNullContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)

        def IS(self):
            return self.getToken(ClickHouseParser.IS, 0)
        def NULL_SQL(self):
            return self.getToken(ClickHouseParser.NULL_SQL, 0)
        def NOT(self):
            return self.getToken(ClickHouseParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprIsNull" ):
                listener.enterColumnExprIsNull(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprIsNull" ):
                listener.exitColumnExprIsNull(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprIsNull" ):
                return visitor.visitColumnExprIsNull(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprTrimContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRIM(self):
            return self.getToken(ClickHouseParser.TRIM, 0)
        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)
        def FROM(self):
            return self.getToken(ClickHouseParser.FROM, 0)
        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)
        def BOTH(self):
            return self.getToken(ClickHouseParser.BOTH, 0)
        def LEADING(self):
            return self.getToken(ClickHouseParser.LEADING, 0)
        def TRAILING(self):
            return self.getToken(ClickHouseParser.TRAILING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprTrim" ):
                listener.enterColumnExprTrim(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprTrim" ):
                listener.exitColumnExprTrim(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprTrim" ):
                return visitor.visitColumnExprTrim(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprTupleContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def columnExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprTuple" ):
                listener.enterColumnExprTuple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprTuple" ):
                listener.exitColumnExprTuple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprTuple" ):
                return visitor.visitColumnExprTuple(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprArrayAccessContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)

        def LBRACKET(self):
            return self.getToken(ClickHouseParser.LBRACKET, 0)
        def RBRACKET(self):
            return self.getToken(ClickHouseParser.RBRACKET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprArrayAccess" ):
                listener.enterColumnExprArrayAccess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprArrayAccess" ):
                listener.exitColumnExprArrayAccess(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprArrayAccess" ):
                return visitor.visitColumnExprArrayAccess(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprBetweenContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)

        def BETWEEN(self):
            return self.getToken(ClickHouseParser.BETWEEN, 0)
        def AND(self):
            return self.getToken(ClickHouseParser.AND, 0)
        def NOT(self):
            return self.getToken(ClickHouseParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprBetween" ):
                listener.enterColumnExprBetween(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprBetween" ):
                listener.exitColumnExprBetween(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprBetween" ):
                return visitor.visitColumnExprBetween(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprParensContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprParens" ):
                listener.enterColumnExprParens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprParens" ):
                listener.exitColumnExprParens(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprParens" ):
                return visitor.visitColumnExprParens(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprTimestampContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TIMESTAMP(self):
            return self.getToken(ClickHouseParser.TIMESTAMP, 0)
        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprTimestamp" ):
                listener.enterColumnExprTimestamp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprTimestamp" ):
                listener.exitColumnExprTimestamp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprTimestamp" ):
                return visitor.visitColumnExprTimestamp(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprAggFunctionContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.function = None # AggregateFunctionNameContext
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)
        def aggregateFunctionName(self):
            return self.getTypedRuleContext(ClickHouseParser.AggregateFunctionNameContext,0)

        def DISTINCT(self):
            return self.getToken(ClickHouseParser.DISTINCT, 0)
        def ALL(self):
            return self.getToken(ClickHouseParser.ALL, 0)
        def columnArgList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnArgListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprAggFunction" ):
                listener.enterColumnExprAggFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprAggFunction" ):
                listener.exitColumnExprAggFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprAggFunction" ):
                return visitor.visitColumnExprAggFunction(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprIfExprContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.cond = None # ColumnExprContext
            self.trueExpr = None # ColumnExprContext
            self.falseExpr = None # ColumnExprContext
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)
        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)
        def IF(self):
            return self.getToken(ClickHouseParser.IF, 0)
        def IIF(self):
            return self.getToken(ClickHouseParser.IIF, 0)
        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprIfExpr" ):
                listener.enterColumnExprIfExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprIfExpr" ):
                listener.exitColumnExprIfExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprIfExpr" ):
                return visitor.visitColumnExprIfExpr(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprAliasSubqueryContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)

        def AS(self):
            return self.getToken(ClickHouseParser.AS, 0)
        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def selectUnionStmt(self):
            return self.getTypedRuleContext(ClickHouseParser.SelectUnionStmtContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprAliasSubquery" ):
                listener.enterColumnExprAliasSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprAliasSubquery" ):
                listener.exitColumnExprAliasSubquery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprAliasSubquery" ):
                return visitor.visitColumnExprAliasSubquery(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprAndContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)

        def AND(self):
            return self.getToken(ClickHouseParser.AND, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprAnd" ):
                listener.enterColumnExprAnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprAnd" ):
                listener.exitColumnExprAnd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprAnd" ):
                return visitor.visitColumnExprAnd(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprTupleAccessContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)

        def DOT(self):
            return self.getToken(ClickHouseParser.DOT, 0)
        def DECIMAL_LITERAL(self):
            return self.getToken(ClickHouseParser.DECIMAL_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprTupleAccess" ):
                listener.enterColumnExprTupleAccess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprTupleAccess" ):
                listener.exitColumnExprTupleAccess(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprTupleAccess" ):
                return visitor.visitColumnExprTupleAccess(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprCaseContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def caseExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.CaseExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprCase" ):
                listener.enterColumnExprCase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprCase" ):
                listener.exitColumnExprCase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprCase" ):
                return visitor.visitColumnExprCase(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprSumCaseFunctionContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SUM(self):
            return self.getToken(ClickHouseParser.SUM, 0)
        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def caseExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.CaseExprContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprSumCaseFunction" ):
                listener.enterColumnExprSumCaseFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprSumCaseFunction" ):
                listener.exitColumnExprSumCaseFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprSumCaseFunction" ):
                return visitor.visitColumnExprSumCaseFunction(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprDateContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DATE(self):
            return self.getToken(ClickHouseParser.DATE, 0)
        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprDate" ):
                listener.enterColumnExprDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprDate" ):
                listener.exitColumnExprDate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprDate" ):
                return visitor.visitColumnExprDate(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprNotContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(ClickHouseParser.NOT, 0)
        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprNot" ):
                listener.enterColumnExprNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprNot" ):
                listener.exitColumnExprNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprNot" ):
                return visitor.visitColumnExprNot(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprIdentifierContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnIdentifier(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprIdentifier" ):
                listener.enterColumnExprIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprIdentifier" ):
                listener.exitColumnExprIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprIdentifier" ):
                return visitor.visitColumnExprIdentifier(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprFunctionContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(ClickHouseParser.LPAREN)
            else:
                return self.getToken(ClickHouseParser.LPAREN, i)
        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(ClickHouseParser.RPAREN)
            else:
                return self.getToken(ClickHouseParser.RPAREN, i)
        def DISTINCT(self):
            return self.getToken(ClickHouseParser.DISTINCT, 0)
        def columnArgList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnArgListContext,0)

        def columnExprList(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprFunction" ):
                listener.enterColumnExprFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprFunction" ):
                listener.exitColumnExprFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprFunction" ):
                return visitor.visitColumnExprFunction(self)
            else:
                return visitor.visitChildren(self)


    class ColumnExprAsteriskContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ASTERISK(self):
            return self.getToken(ClickHouseParser.ASTERISK, 0)
        def tableIdentifier(self):
            return self.getTypedRuleContext(ClickHouseParser.TableIdentifierContext,0)

        def DOT(self):
            return self.getToken(ClickHouseParser.DOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnExprAsterisk" ):
                listener.enterColumnExprAsterisk(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnExprAsterisk" ):
                listener.exitColumnExprAsterisk(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnExprAsterisk" ):
                return visitor.visitColumnExprAsterisk(self)
            else:
                return visitor.visitChildren(self)


    class ColumnQuoteExprContext(ColumnExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.ColumnExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)

        def LBRACE(self):
            return self.getToken(ClickHouseParser.LBRACE, 0)
        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)
        def RBRACE(self):
            return self.getToken(ClickHouseParser.RBRACE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnQuoteExpr" ):
                listener.enterColumnQuoteExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnQuoteExpr" ):
                listener.exitColumnQuoteExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnQuoteExpr" ):
                return visitor.visitColumnQuoteExpr(self)
            else:
                return visitor.visitChildren(self)



    def columnExpr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ClickHouseParser.ColumnExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 76
        self.enterRecursionRule(localctx, 76, self.RULE_columnExpr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 655
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
            if la_ == 1:
                localctx = ClickHouseParser.ColumnExprCaseContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 519
                self.caseExpr()
                pass

            elif la_ == 2:
                localctx = ClickHouseParser.ColumnExprCastContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 520
                self.match(ClickHouseParser.CAST)
                self.state = 521
                self.match(ClickHouseParser.LPAREN)
                self.state = 522
                self.columnExpr(0)
                self.state = 523
                self.match(ClickHouseParser.AS)
                self.state = 524
                self.columnTypeExpr()
                self.state = 525
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = ClickHouseParser.ColumnExprDateContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 527
                self.match(ClickHouseParser.DATE)
                self.state = 528
                self.match(ClickHouseParser.STRING_LITERAL)
                pass

            elif la_ == 4:
                localctx = ClickHouseParser.ColumnExprExtractContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 529
                self.match(ClickHouseParser.EXTRACT)
                self.state = 530
                self.match(ClickHouseParser.LPAREN)
                self.state = 531
                self.interval()
                self.state = 532
                self.match(ClickHouseParser.FROM)
                self.state = 533
                self.columnExpr(0)
                self.state = 534
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 5:
                localctx = ClickHouseParser.ColumnExprIntervalContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 536
                self.match(ClickHouseParser.INTERVAL)
                self.state = 537
                self.columnExpr(0)
                self.state = 538
                self.interval()
                pass

            elif la_ == 6:
                localctx = ClickHouseParser.ColumnExprSubstringContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 540
                self.match(ClickHouseParser.SUBSTRING)
                self.state = 541
                self.match(ClickHouseParser.LPAREN)
                self.state = 542
                self.columnExpr(0)
                self.state = 543
                self.match(ClickHouseParser.FROM)
                self.state = 544
                self.columnExpr(0)
                self.state = 547
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ClickHouseParser.FOR:
                    self.state = 545
                    self.match(ClickHouseParser.FOR)
                    self.state = 546
                    self.columnExpr(0)


                self.state = 549
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 7:
                localctx = ClickHouseParser.ColumnExprTimestampContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 551
                self.match(ClickHouseParser.TIMESTAMP)
                self.state = 552
                self.match(ClickHouseParser.STRING_LITERAL)
                pass

            elif la_ == 8:
                localctx = ClickHouseParser.ColumnExprTrimContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 553
                self.match(ClickHouseParser.TRIM)
                self.state = 554
                self.match(ClickHouseParser.LPAREN)
                self.state = 555
                _la = self._input.LA(1)
                if not(_la==ClickHouseParser.BOTH or _la==ClickHouseParser.LEADING or _la==ClickHouseParser.TRAILING):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 556
                self.match(ClickHouseParser.STRING_LITERAL)
                self.state = 557
                self.match(ClickHouseParser.FROM)
                self.state = 558
                self.columnExpr(0)
                self.state = 559
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 9:
                localctx = ClickHouseParser.ColumnExprSumCaseFunctionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 561
                self.match(ClickHouseParser.SUM)
                self.state = 562
                self.match(ClickHouseParser.LPAREN)
                self.state = 563
                self.caseExpr()
                self.state = 564
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 10:
                localctx = ClickHouseParser.ColumnExprAggFunctionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 566
                localctx.function = self.aggregateFunctionName()
                self.state = 567
                self.match(ClickHouseParser.LPAREN)
                self.state = 569
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
                if la_ == 1:
                    self.state = 568
                    self.match(ClickHouseParser.DISTINCT)


                self.state = 572
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
                if la_ == 1:
                    self.state = 571
                    self.match(ClickHouseParser.ALL)


                self.state = 575
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.AFTER) | (1 << ClickHouseParser.ALIAS) | (1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ALTER) | (1 << ClickHouseParser.AND) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ARRAY) | (1 << ClickHouseParser.AS) | (1 << ClickHouseParser.ASCENDING) | (1 << ClickHouseParser.ASOF) | (1 << ClickHouseParser.ASYNC) | (1 << ClickHouseParser.ATTACH) | (1 << ClickHouseParser.AVG) | (1 << ClickHouseParser.BETWEEN) | (1 << ClickHouseParser.BOTH) | (1 << ClickHouseParser.BY) | (1 << ClickHouseParser.CASE) | (1 << ClickHouseParser.CAST) | (1 << ClickHouseParser.CHECK) | (1 << ClickHouseParser.CLEAR) | (1 << ClickHouseParser.CLUSTER) | (1 << ClickHouseParser.CODEC) | (1 << ClickHouseParser.COLLATE) | (1 << ClickHouseParser.COLUMN) | (1 << ClickHouseParser.COMMENT) | (1 << ClickHouseParser.CONSTRAINT) | (1 << ClickHouseParser.COUNT) | (1 << ClickHouseParser.CREATE) | (1 << ClickHouseParser.CROSS) | (1 << ClickHouseParser.CUBE) | (1 << ClickHouseParser.DATABASE) | (1 << ClickHouseParser.DATABASES) | (1 << ClickHouseParser.DATE) | (1 << ClickHouseParser.DAY) | (1 << ClickHouseParser.DEDUPLICATE) | (1 << ClickHouseParser.DEFAULT) | (1 << ClickHouseParser.DELAY) | (1 << ClickHouseParser.DELETE) | (1 << ClickHouseParser.DESC) | (1 << ClickHouseParser.DESCENDING) | (1 << ClickHouseParser.DESCRIBE) | (1 << ClickHouseParser.DETACH) | (1 << ClickHouseParser.DICTIONARIES) | (1 << ClickHouseParser.DICTIONARY) | (1 << ClickHouseParser.DISK) | (1 << ClickHouseParser.DISTINCT) | (1 << ClickHouseParser.DISTRIBUTED) | (1 << ClickHouseParser.DROP) | (1 << ClickHouseParser.ELSE) | (1 << ClickHouseParser.END) | (1 << ClickHouseParser.ENGINE) | (1 << ClickHouseParser.EVENTS) | (1 << ClickHouseParser.EXISTS) | (1 << ClickHouseParser.EXPLAIN) | (1 << ClickHouseParser.EXPRESSION) | (1 << ClickHouseParser.EXTRACT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ClickHouseParser.FETCHES - 64)) | (1 << (ClickHouseParser.FINAL - 64)) | (1 << (ClickHouseParser.FIRST - 64)) | (1 << (ClickHouseParser.FLUSH - 64)) | (1 << (ClickHouseParser.FOR - 64)) | (1 << (ClickHouseParser.FORMAT - 64)) | (1 << (ClickHouseParser.FREEZE - 64)) | (1 << (ClickHouseParser.FROM - 64)) | (1 << (ClickHouseParser.FULL - 64)) | (1 << (ClickHouseParser.FUNCTION - 64)) | (1 << (ClickHouseParser.GLOBAL - 64)) | (1 << (ClickHouseParser.GRANULARITY - 64)) | (1 << (ClickHouseParser.GROUP - 64)) | (1 << (ClickHouseParser.HAVING - 64)) | (1 << (ClickHouseParser.HIERARCHICAL - 64)) | (1 << (ClickHouseParser.HOUR - 64)) | (1 << (ClickHouseParser.ID - 64)) | (1 << (ClickHouseParser.IF - 64)) | (1 << (ClickHouseParser.IIF - 64)) | (1 << (ClickHouseParser.ILIKE - 64)) | (1 << (ClickHouseParser.IN - 64)) | (1 << (ClickHouseParser.INDEX - 64)) | (1 << (ClickHouseParser.INF - 64)) | (1 << (ClickHouseParser.INJECTIVE - 64)) | (1 << (ClickHouseParser.INNER - 64)) | (1 << (ClickHouseParser.INSERT - 64)) | (1 << (ClickHouseParser.INTERVAL - 64)) | (1 << (ClickHouseParser.INTO - 64)) | (1 << (ClickHouseParser.IS - 64)) | (1 << (ClickHouseParser.IS_OBJECT_ID - 64)) | (1 << (ClickHouseParser.JOIN - 64)) | (1 << (ClickHouseParser.KEY - 64)) | (1 << (ClickHouseParser.KILL - 64)) | (1 << (ClickHouseParser.LAST - 64)) | (1 << (ClickHouseParser.LAYOUT - 64)) | (1 << (ClickHouseParser.LEADING - 64)) | (1 << (ClickHouseParser.LEFT - 64)) | (1 << (ClickHouseParser.LIFETIME - 64)) | (1 << (ClickHouseParser.LIKE - 64)) | (1 << (ClickHouseParser.LIMIT - 64)) | (1 << (ClickHouseParser.LIVE - 64)) | (1 << (ClickHouseParser.LOCAL - 64)) | (1 << (ClickHouseParser.LOGS - 64)) | (1 << (ClickHouseParser.MATERIALIZED - 64)) | (1 << (ClickHouseParser.MAX - 64)) | (1 << (ClickHouseParser.MERGES - 64)) | (1 << (ClickHouseParser.MIN - 64)) | (1 << (ClickHouseParser.MINUTE - 64)) | (1 << (ClickHouseParser.MODIFY - 64)) | (1 << (ClickHouseParser.MONTH - 64)) | (1 << (ClickHouseParser.MOVE - 64)) | (1 << (ClickHouseParser.MUTATION - 64)) | (1 << (ClickHouseParser.MULTIIF - 64)) | (1 << (ClickHouseParser.NAN_SQL - 64)) | (1 << (ClickHouseParser.NO - 64)) | (1 << (ClickHouseParser.NOT - 64)) | (1 << (ClickHouseParser.NULL_SQL - 64)) | (1 << (ClickHouseParser.NULLS - 64)) | (1 << (ClickHouseParser.OFFSET - 64)) | (1 << (ClickHouseParser.ON - 64)) | (1 << (ClickHouseParser.OPTIMIZE - 64)) | (1 << (ClickHouseParser.OR - 64)) | (1 << (ClickHouseParser.ORDER - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (ClickHouseParser.OUTER - 128)) | (1 << (ClickHouseParser.OUTFILE - 128)) | (1 << (ClickHouseParser.PARTITION - 128)) | (1 << (ClickHouseParser.PERCENTILE_CONT - 128)) | (1 << (ClickHouseParser.PERCENTILE_DISC - 128)) | (1 << (ClickHouseParser.POPULATE - 128)) | (1 << (ClickHouseParser.POW - 128)) | (1 << (ClickHouseParser.POWER - 128)) | (1 << (ClickHouseParser.PREWHERE - 128)) | (1 << (ClickHouseParser.PRIMARY - 128)) | (1 << (ClickHouseParser.QUARTER - 128)) | (1 << (ClickHouseParser.RANGE - 128)) | (1 << (ClickHouseParser.RELOAD - 128)) | (1 << (ClickHouseParser.REMOVE - 128)) | (1 << (ClickHouseParser.RENAME - 128)) | (1 << (ClickHouseParser.REPLACE - 128)) | (1 << (ClickHouseParser.REPLICA - 128)) | (1 << (ClickHouseParser.REPLICATED - 128)) | (1 << (ClickHouseParser.RIGHT - 128)) | (1 << (ClickHouseParser.ROLLUP - 128)) | (1 << (ClickHouseParser.SAMPLE - 128)) | (1 << (ClickHouseParser.SECOND - 128)) | (1 << (ClickHouseParser.SELECT - 128)) | (1 << (ClickHouseParser.SEMI - 128)) | (1 << (ClickHouseParser.SENDS - 128)) | (1 << (ClickHouseParser.SET - 128)) | (1 << (ClickHouseParser.SETTINGS - 128)) | (1 << (ClickHouseParser.SHOW - 128)) | (1 << (ClickHouseParser.SOURCE - 128)) | (1 << (ClickHouseParser.START - 128)) | (1 << (ClickHouseParser.STD - 128)) | (1 << (ClickHouseParser.STDDEV - 128)) | (1 << (ClickHouseParser.STDDEVPOP - 128)) | (1 << (ClickHouseParser.STOP - 128)) | (1 << (ClickHouseParser.SUBSTRING - 128)) | (1 << (ClickHouseParser.SUM - 128)) | (1 << (ClickHouseParser.SYNC - 128)) | (1 << (ClickHouseParser.SYNTAX - 128)) | (1 << (ClickHouseParser.SYSTEM - 128)) | (1 << (ClickHouseParser.TABLE - 128)) | (1 << (ClickHouseParser.TABLES - 128)) | (1 << (ClickHouseParser.TEMPORARY - 128)) | (1 << (ClickHouseParser.TEST - 128)) | (1 << (ClickHouseParser.THEN - 128)) | (1 << (ClickHouseParser.TIES - 128)) | (1 << (ClickHouseParser.TIMEOUT - 128)) | (1 << (ClickHouseParser.TIMESTAMP - 128)) | (1 << (ClickHouseParser.TO - 128)) | (1 << (ClickHouseParser.TOP - 128)) | (1 << (ClickHouseParser.TOTALS - 128)) | (1 << (ClickHouseParser.TRAILING - 128)) | (1 << (ClickHouseParser.TRIM - 128)) | (1 << (ClickHouseParser.TRUNCATE - 128)) | (1 << (ClickHouseParser.TTL - 128)) | (1 << (ClickHouseParser.TYPE - 128)) | (1 << (ClickHouseParser.UNION - 128)) | (1 << (ClickHouseParser.UPDATE - 128)) | (1 << (ClickHouseParser.USE - 128)) | (1 << (ClickHouseParser.USING - 128)) | (1 << (ClickHouseParser.UUID - 128)) | (1 << (ClickHouseParser.VALUES - 128)) | (1 << (ClickHouseParser.VIEW - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (ClickHouseParser.VOLUME - 192)) | (1 << (ClickHouseParser.WATCH - 192)) | (1 << (ClickHouseParser.WEEK - 192)) | (1 << (ClickHouseParser.VAR - 192)) | (1 << (ClickHouseParser.VARPOP - 192)) | (1 << (ClickHouseParser.VARIANCE - 192)) | (1 << (ClickHouseParser.WHEN - 192)) | (1 << (ClickHouseParser.WHERE - 192)) | (1 << (ClickHouseParser.WITH - 192)) | (1 << (ClickHouseParser.YEAR - 192)) | (1 << (ClickHouseParser.JSON_FALSE - 192)) | (1 << (ClickHouseParser.JSON_TRUE - 192)) | (1 << (ClickHouseParser.IDENTIFIER - 192)) | (1 << (ClickHouseParser.FLOATING_LITERAL - 192)) | (1 << (ClickHouseParser.OCTAL_LITERAL - 192)) | (1 << (ClickHouseParser.DECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.HEXADECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.STRING_LITERAL - 192)) | (1 << (ClickHouseParser.ASTERISK - 192)) | (1 << (ClickHouseParser.DASH - 192)) | (1 << (ClickHouseParser.DOT - 192)) | (1 << (ClickHouseParser.LBRACKET - 192)) | (1 << (ClickHouseParser.LPAREN - 192)) | (1 << (ClickHouseParser.PLUS - 192)))) != 0):
                    self.state = 574
                    self.columnArgList()


                self.state = 577
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 11:
                localctx = ClickHouseParser.ColumnExprIfExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 579
                _la = self._input.LA(1)
                if not(_la==ClickHouseParser.IF or _la==ClickHouseParser.IIF):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 580
                self.match(ClickHouseParser.LPAREN)
                self.state = 581
                localctx.cond = self.columnExpr(0)
                self.state = 582
                self.match(ClickHouseParser.COMMA)
                self.state = 583
                localctx.trueExpr = self.columnExpr(0)
                self.state = 584
                self.match(ClickHouseParser.COMMA)
                self.state = 585
                localctx.falseExpr = self.columnExpr(0)
                self.state = 586
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 12:
                localctx = ClickHouseParser.ColumnExprMultiIfExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 588
                self.match(ClickHouseParser.MULTIIF)
                self.state = 589
                self.match(ClickHouseParser.LPAREN)
                self.state = 590
                self.columnArgList()
                self.state = 591
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 13:
                localctx = ClickHouseParser.ColumnExprPowFunctionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 593
                _la = self._input.LA(1)
                if not(_la==ClickHouseParser.POW or _la==ClickHouseParser.POWER):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 594
                self.match(ClickHouseParser.LPAREN)
                self.state = 595
                self.columnExpr(0)
                self.state = 596
                self.match(ClickHouseParser.COMMA)
                self.state = 599
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ClickHouseParser.INF, ClickHouseParser.NAN_SQL, ClickHouseParser.FLOATING_LITERAL, ClickHouseParser.OCTAL_LITERAL, ClickHouseParser.DECIMAL_LITERAL, ClickHouseParser.HEXADECIMAL_LITERAL, ClickHouseParser.DASH, ClickHouseParser.DOT, ClickHouseParser.PLUS]:
                    self.state = 597
                    self.numberLiteral()
                    pass
                elif token in [ClickHouseParser.NULL_SQL]:
                    self.state = 598
                    self.match(ClickHouseParser.NULL_SQL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 601
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 14:
                localctx = ClickHouseParser.ColumnExprFunctionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 603
                self.identifier()
                self.state = 609
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
                if la_ == 1:
                    self.state = 604
                    self.match(ClickHouseParser.LPAREN)
                    self.state = 606
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.AFTER) | (1 << ClickHouseParser.ALIAS) | (1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ALTER) | (1 << ClickHouseParser.AND) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ARRAY) | (1 << ClickHouseParser.AS) | (1 << ClickHouseParser.ASCENDING) | (1 << ClickHouseParser.ASOF) | (1 << ClickHouseParser.ASYNC) | (1 << ClickHouseParser.ATTACH) | (1 << ClickHouseParser.AVG) | (1 << ClickHouseParser.BETWEEN) | (1 << ClickHouseParser.BOTH) | (1 << ClickHouseParser.BY) | (1 << ClickHouseParser.CASE) | (1 << ClickHouseParser.CAST) | (1 << ClickHouseParser.CHECK) | (1 << ClickHouseParser.CLEAR) | (1 << ClickHouseParser.CLUSTER) | (1 << ClickHouseParser.CODEC) | (1 << ClickHouseParser.COLLATE) | (1 << ClickHouseParser.COLUMN) | (1 << ClickHouseParser.COMMENT) | (1 << ClickHouseParser.CONSTRAINT) | (1 << ClickHouseParser.COUNT) | (1 << ClickHouseParser.CREATE) | (1 << ClickHouseParser.CROSS) | (1 << ClickHouseParser.CUBE) | (1 << ClickHouseParser.DATABASE) | (1 << ClickHouseParser.DATABASES) | (1 << ClickHouseParser.DATE) | (1 << ClickHouseParser.DAY) | (1 << ClickHouseParser.DEDUPLICATE) | (1 << ClickHouseParser.DEFAULT) | (1 << ClickHouseParser.DELAY) | (1 << ClickHouseParser.DELETE) | (1 << ClickHouseParser.DESC) | (1 << ClickHouseParser.DESCENDING) | (1 << ClickHouseParser.DESCRIBE) | (1 << ClickHouseParser.DETACH) | (1 << ClickHouseParser.DICTIONARIES) | (1 << ClickHouseParser.DICTIONARY) | (1 << ClickHouseParser.DISK) | (1 << ClickHouseParser.DISTINCT) | (1 << ClickHouseParser.DISTRIBUTED) | (1 << ClickHouseParser.DROP) | (1 << ClickHouseParser.ELSE) | (1 << ClickHouseParser.END) | (1 << ClickHouseParser.ENGINE) | (1 << ClickHouseParser.EVENTS) | (1 << ClickHouseParser.EXISTS) | (1 << ClickHouseParser.EXPLAIN) | (1 << ClickHouseParser.EXPRESSION) | (1 << ClickHouseParser.EXTRACT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ClickHouseParser.FETCHES - 64)) | (1 << (ClickHouseParser.FINAL - 64)) | (1 << (ClickHouseParser.FIRST - 64)) | (1 << (ClickHouseParser.FLUSH - 64)) | (1 << (ClickHouseParser.FOR - 64)) | (1 << (ClickHouseParser.FORMAT - 64)) | (1 << (ClickHouseParser.FREEZE - 64)) | (1 << (ClickHouseParser.FROM - 64)) | (1 << (ClickHouseParser.FULL - 64)) | (1 << (ClickHouseParser.FUNCTION - 64)) | (1 << (ClickHouseParser.GLOBAL - 64)) | (1 << (ClickHouseParser.GRANULARITY - 64)) | (1 << (ClickHouseParser.GROUP - 64)) | (1 << (ClickHouseParser.HAVING - 64)) | (1 << (ClickHouseParser.HIERARCHICAL - 64)) | (1 << (ClickHouseParser.HOUR - 64)) | (1 << (ClickHouseParser.ID - 64)) | (1 << (ClickHouseParser.IF - 64)) | (1 << (ClickHouseParser.IIF - 64)) | (1 << (ClickHouseParser.ILIKE - 64)) | (1 << (ClickHouseParser.IN - 64)) | (1 << (ClickHouseParser.INDEX - 64)) | (1 << (ClickHouseParser.INF - 64)) | (1 << (ClickHouseParser.INJECTIVE - 64)) | (1 << (ClickHouseParser.INNER - 64)) | (1 << (ClickHouseParser.INSERT - 64)) | (1 << (ClickHouseParser.INTERVAL - 64)) | (1 << (ClickHouseParser.INTO - 64)) | (1 << (ClickHouseParser.IS - 64)) | (1 << (ClickHouseParser.IS_OBJECT_ID - 64)) | (1 << (ClickHouseParser.JOIN - 64)) | (1 << (ClickHouseParser.KEY - 64)) | (1 << (ClickHouseParser.KILL - 64)) | (1 << (ClickHouseParser.LAST - 64)) | (1 << (ClickHouseParser.LAYOUT - 64)) | (1 << (ClickHouseParser.LEADING - 64)) | (1 << (ClickHouseParser.LEFT - 64)) | (1 << (ClickHouseParser.LIFETIME - 64)) | (1 << (ClickHouseParser.LIKE - 64)) | (1 << (ClickHouseParser.LIMIT - 64)) | (1 << (ClickHouseParser.LIVE - 64)) | (1 << (ClickHouseParser.LOCAL - 64)) | (1 << (ClickHouseParser.LOGS - 64)) | (1 << (ClickHouseParser.MATERIALIZED - 64)) | (1 << (ClickHouseParser.MAX - 64)) | (1 << (ClickHouseParser.MERGES - 64)) | (1 << (ClickHouseParser.MIN - 64)) | (1 << (ClickHouseParser.MINUTE - 64)) | (1 << (ClickHouseParser.MODIFY - 64)) | (1 << (ClickHouseParser.MONTH - 64)) | (1 << (ClickHouseParser.MOVE - 64)) | (1 << (ClickHouseParser.MUTATION - 64)) | (1 << (ClickHouseParser.MULTIIF - 64)) | (1 << (ClickHouseParser.NAN_SQL - 64)) | (1 << (ClickHouseParser.NO - 64)) | (1 << (ClickHouseParser.NOT - 64)) | (1 << (ClickHouseParser.NULL_SQL - 64)) | (1 << (ClickHouseParser.NULLS - 64)) | (1 << (ClickHouseParser.OFFSET - 64)) | (1 << (ClickHouseParser.ON - 64)) | (1 << (ClickHouseParser.OPTIMIZE - 64)) | (1 << (ClickHouseParser.OR - 64)) | (1 << (ClickHouseParser.ORDER - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (ClickHouseParser.OUTER - 128)) | (1 << (ClickHouseParser.OUTFILE - 128)) | (1 << (ClickHouseParser.PARTITION - 128)) | (1 << (ClickHouseParser.PERCENTILE_CONT - 128)) | (1 << (ClickHouseParser.PERCENTILE_DISC - 128)) | (1 << (ClickHouseParser.POPULATE - 128)) | (1 << (ClickHouseParser.POW - 128)) | (1 << (ClickHouseParser.POWER - 128)) | (1 << (ClickHouseParser.PREWHERE - 128)) | (1 << (ClickHouseParser.PRIMARY - 128)) | (1 << (ClickHouseParser.QUARTER - 128)) | (1 << (ClickHouseParser.RANGE - 128)) | (1 << (ClickHouseParser.RELOAD - 128)) | (1 << (ClickHouseParser.REMOVE - 128)) | (1 << (ClickHouseParser.RENAME - 128)) | (1 << (ClickHouseParser.REPLACE - 128)) | (1 << (ClickHouseParser.REPLICA - 128)) | (1 << (ClickHouseParser.REPLICATED - 128)) | (1 << (ClickHouseParser.RIGHT - 128)) | (1 << (ClickHouseParser.ROLLUP - 128)) | (1 << (ClickHouseParser.SAMPLE - 128)) | (1 << (ClickHouseParser.SECOND - 128)) | (1 << (ClickHouseParser.SELECT - 128)) | (1 << (ClickHouseParser.SEMI - 128)) | (1 << (ClickHouseParser.SENDS - 128)) | (1 << (ClickHouseParser.SET - 128)) | (1 << (ClickHouseParser.SETTINGS - 128)) | (1 << (ClickHouseParser.SHOW - 128)) | (1 << (ClickHouseParser.SOURCE - 128)) | (1 << (ClickHouseParser.START - 128)) | (1 << (ClickHouseParser.STD - 128)) | (1 << (ClickHouseParser.STDDEV - 128)) | (1 << (ClickHouseParser.STDDEVPOP - 128)) | (1 << (ClickHouseParser.STOP - 128)) | (1 << (ClickHouseParser.SUBSTRING - 128)) | (1 << (ClickHouseParser.SUM - 128)) | (1 << (ClickHouseParser.SYNC - 128)) | (1 << (ClickHouseParser.SYNTAX - 128)) | (1 << (ClickHouseParser.SYSTEM - 128)) | (1 << (ClickHouseParser.TABLE - 128)) | (1 << (ClickHouseParser.TABLES - 128)) | (1 << (ClickHouseParser.TEMPORARY - 128)) | (1 << (ClickHouseParser.TEST - 128)) | (1 << (ClickHouseParser.THEN - 128)) | (1 << (ClickHouseParser.TIES - 128)) | (1 << (ClickHouseParser.TIMEOUT - 128)) | (1 << (ClickHouseParser.TIMESTAMP - 128)) | (1 << (ClickHouseParser.TO - 128)) | (1 << (ClickHouseParser.TOP - 128)) | (1 << (ClickHouseParser.TOTALS - 128)) | (1 << (ClickHouseParser.TRAILING - 128)) | (1 << (ClickHouseParser.TRIM - 128)) | (1 << (ClickHouseParser.TRUNCATE - 128)) | (1 << (ClickHouseParser.TTL - 128)) | (1 << (ClickHouseParser.TYPE - 128)) | (1 << (ClickHouseParser.UNION - 128)) | (1 << (ClickHouseParser.UPDATE - 128)) | (1 << (ClickHouseParser.USE - 128)) | (1 << (ClickHouseParser.USING - 128)) | (1 << (ClickHouseParser.UUID - 128)) | (1 << (ClickHouseParser.VALUES - 128)) | (1 << (ClickHouseParser.VIEW - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (ClickHouseParser.VOLUME - 192)) | (1 << (ClickHouseParser.WATCH - 192)) | (1 << (ClickHouseParser.WEEK - 192)) | (1 << (ClickHouseParser.VAR - 192)) | (1 << (ClickHouseParser.VARPOP - 192)) | (1 << (ClickHouseParser.VARIANCE - 192)) | (1 << (ClickHouseParser.WHEN - 192)) | (1 << (ClickHouseParser.WHERE - 192)) | (1 << (ClickHouseParser.WITH - 192)) | (1 << (ClickHouseParser.YEAR - 192)) | (1 << (ClickHouseParser.JSON_FALSE - 192)) | (1 << (ClickHouseParser.JSON_TRUE - 192)) | (1 << (ClickHouseParser.IDENTIFIER - 192)) | (1 << (ClickHouseParser.FLOATING_LITERAL - 192)) | (1 << (ClickHouseParser.OCTAL_LITERAL - 192)) | (1 << (ClickHouseParser.DECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.HEXADECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.STRING_LITERAL - 192)) | (1 << (ClickHouseParser.ASTERISK - 192)) | (1 << (ClickHouseParser.DASH - 192)) | (1 << (ClickHouseParser.DOT - 192)) | (1 << (ClickHouseParser.LBRACKET - 192)) | (1 << (ClickHouseParser.LPAREN - 192)) | (1 << (ClickHouseParser.PLUS - 192)))) != 0):
                        self.state = 605
                        self.columnExprList()


                    self.state = 608
                    self.match(ClickHouseParser.RPAREN)


                self.state = 611
                self.match(ClickHouseParser.LPAREN)
                self.state = 613
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
                if la_ == 1:
                    self.state = 612
                    self.match(ClickHouseParser.DISTINCT)


                self.state = 616
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.AFTER) | (1 << ClickHouseParser.ALIAS) | (1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ALTER) | (1 << ClickHouseParser.AND) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ARRAY) | (1 << ClickHouseParser.AS) | (1 << ClickHouseParser.ASCENDING) | (1 << ClickHouseParser.ASOF) | (1 << ClickHouseParser.ASYNC) | (1 << ClickHouseParser.ATTACH) | (1 << ClickHouseParser.AVG) | (1 << ClickHouseParser.BETWEEN) | (1 << ClickHouseParser.BOTH) | (1 << ClickHouseParser.BY) | (1 << ClickHouseParser.CASE) | (1 << ClickHouseParser.CAST) | (1 << ClickHouseParser.CHECK) | (1 << ClickHouseParser.CLEAR) | (1 << ClickHouseParser.CLUSTER) | (1 << ClickHouseParser.CODEC) | (1 << ClickHouseParser.COLLATE) | (1 << ClickHouseParser.COLUMN) | (1 << ClickHouseParser.COMMENT) | (1 << ClickHouseParser.CONSTRAINT) | (1 << ClickHouseParser.COUNT) | (1 << ClickHouseParser.CREATE) | (1 << ClickHouseParser.CROSS) | (1 << ClickHouseParser.CUBE) | (1 << ClickHouseParser.DATABASE) | (1 << ClickHouseParser.DATABASES) | (1 << ClickHouseParser.DATE) | (1 << ClickHouseParser.DAY) | (1 << ClickHouseParser.DEDUPLICATE) | (1 << ClickHouseParser.DEFAULT) | (1 << ClickHouseParser.DELAY) | (1 << ClickHouseParser.DELETE) | (1 << ClickHouseParser.DESC) | (1 << ClickHouseParser.DESCENDING) | (1 << ClickHouseParser.DESCRIBE) | (1 << ClickHouseParser.DETACH) | (1 << ClickHouseParser.DICTIONARIES) | (1 << ClickHouseParser.DICTIONARY) | (1 << ClickHouseParser.DISK) | (1 << ClickHouseParser.DISTINCT) | (1 << ClickHouseParser.DISTRIBUTED) | (1 << ClickHouseParser.DROP) | (1 << ClickHouseParser.ELSE) | (1 << ClickHouseParser.END) | (1 << ClickHouseParser.ENGINE) | (1 << ClickHouseParser.EVENTS) | (1 << ClickHouseParser.EXISTS) | (1 << ClickHouseParser.EXPLAIN) | (1 << ClickHouseParser.EXPRESSION) | (1 << ClickHouseParser.EXTRACT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ClickHouseParser.FETCHES - 64)) | (1 << (ClickHouseParser.FINAL - 64)) | (1 << (ClickHouseParser.FIRST - 64)) | (1 << (ClickHouseParser.FLUSH - 64)) | (1 << (ClickHouseParser.FOR - 64)) | (1 << (ClickHouseParser.FORMAT - 64)) | (1 << (ClickHouseParser.FREEZE - 64)) | (1 << (ClickHouseParser.FROM - 64)) | (1 << (ClickHouseParser.FULL - 64)) | (1 << (ClickHouseParser.FUNCTION - 64)) | (1 << (ClickHouseParser.GLOBAL - 64)) | (1 << (ClickHouseParser.GRANULARITY - 64)) | (1 << (ClickHouseParser.GROUP - 64)) | (1 << (ClickHouseParser.HAVING - 64)) | (1 << (ClickHouseParser.HIERARCHICAL - 64)) | (1 << (ClickHouseParser.HOUR - 64)) | (1 << (ClickHouseParser.ID - 64)) | (1 << (ClickHouseParser.IF - 64)) | (1 << (ClickHouseParser.IIF - 64)) | (1 << (ClickHouseParser.ILIKE - 64)) | (1 << (ClickHouseParser.IN - 64)) | (1 << (ClickHouseParser.INDEX - 64)) | (1 << (ClickHouseParser.INF - 64)) | (1 << (ClickHouseParser.INJECTIVE - 64)) | (1 << (ClickHouseParser.INNER - 64)) | (1 << (ClickHouseParser.INSERT - 64)) | (1 << (ClickHouseParser.INTERVAL - 64)) | (1 << (ClickHouseParser.INTO - 64)) | (1 << (ClickHouseParser.IS - 64)) | (1 << (ClickHouseParser.IS_OBJECT_ID - 64)) | (1 << (ClickHouseParser.JOIN - 64)) | (1 << (ClickHouseParser.KEY - 64)) | (1 << (ClickHouseParser.KILL - 64)) | (1 << (ClickHouseParser.LAST - 64)) | (1 << (ClickHouseParser.LAYOUT - 64)) | (1 << (ClickHouseParser.LEADING - 64)) | (1 << (ClickHouseParser.LEFT - 64)) | (1 << (ClickHouseParser.LIFETIME - 64)) | (1 << (ClickHouseParser.LIKE - 64)) | (1 << (ClickHouseParser.LIMIT - 64)) | (1 << (ClickHouseParser.LIVE - 64)) | (1 << (ClickHouseParser.LOCAL - 64)) | (1 << (ClickHouseParser.LOGS - 64)) | (1 << (ClickHouseParser.MATERIALIZED - 64)) | (1 << (ClickHouseParser.MAX - 64)) | (1 << (ClickHouseParser.MERGES - 64)) | (1 << (ClickHouseParser.MIN - 64)) | (1 << (ClickHouseParser.MINUTE - 64)) | (1 << (ClickHouseParser.MODIFY - 64)) | (1 << (ClickHouseParser.MONTH - 64)) | (1 << (ClickHouseParser.MOVE - 64)) | (1 << (ClickHouseParser.MUTATION - 64)) | (1 << (ClickHouseParser.MULTIIF - 64)) | (1 << (ClickHouseParser.NAN_SQL - 64)) | (1 << (ClickHouseParser.NO - 64)) | (1 << (ClickHouseParser.NOT - 64)) | (1 << (ClickHouseParser.NULL_SQL - 64)) | (1 << (ClickHouseParser.NULLS - 64)) | (1 << (ClickHouseParser.OFFSET - 64)) | (1 << (ClickHouseParser.ON - 64)) | (1 << (ClickHouseParser.OPTIMIZE - 64)) | (1 << (ClickHouseParser.OR - 64)) | (1 << (ClickHouseParser.ORDER - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (ClickHouseParser.OUTER - 128)) | (1 << (ClickHouseParser.OUTFILE - 128)) | (1 << (ClickHouseParser.PARTITION - 128)) | (1 << (ClickHouseParser.PERCENTILE_CONT - 128)) | (1 << (ClickHouseParser.PERCENTILE_DISC - 128)) | (1 << (ClickHouseParser.POPULATE - 128)) | (1 << (ClickHouseParser.POW - 128)) | (1 << (ClickHouseParser.POWER - 128)) | (1 << (ClickHouseParser.PREWHERE - 128)) | (1 << (ClickHouseParser.PRIMARY - 128)) | (1 << (ClickHouseParser.QUARTER - 128)) | (1 << (ClickHouseParser.RANGE - 128)) | (1 << (ClickHouseParser.RELOAD - 128)) | (1 << (ClickHouseParser.REMOVE - 128)) | (1 << (ClickHouseParser.RENAME - 128)) | (1 << (ClickHouseParser.REPLACE - 128)) | (1 << (ClickHouseParser.REPLICA - 128)) | (1 << (ClickHouseParser.REPLICATED - 128)) | (1 << (ClickHouseParser.RIGHT - 128)) | (1 << (ClickHouseParser.ROLLUP - 128)) | (1 << (ClickHouseParser.SAMPLE - 128)) | (1 << (ClickHouseParser.SECOND - 128)) | (1 << (ClickHouseParser.SELECT - 128)) | (1 << (ClickHouseParser.SEMI - 128)) | (1 << (ClickHouseParser.SENDS - 128)) | (1 << (ClickHouseParser.SET - 128)) | (1 << (ClickHouseParser.SETTINGS - 128)) | (1 << (ClickHouseParser.SHOW - 128)) | (1 << (ClickHouseParser.SOURCE - 128)) | (1 << (ClickHouseParser.START - 128)) | (1 << (ClickHouseParser.STD - 128)) | (1 << (ClickHouseParser.STDDEV - 128)) | (1 << (ClickHouseParser.STDDEVPOP - 128)) | (1 << (ClickHouseParser.STOP - 128)) | (1 << (ClickHouseParser.SUBSTRING - 128)) | (1 << (ClickHouseParser.SUM - 128)) | (1 << (ClickHouseParser.SYNC - 128)) | (1 << (ClickHouseParser.SYNTAX - 128)) | (1 << (ClickHouseParser.SYSTEM - 128)) | (1 << (ClickHouseParser.TABLE - 128)) | (1 << (ClickHouseParser.TABLES - 128)) | (1 << (ClickHouseParser.TEMPORARY - 128)) | (1 << (ClickHouseParser.TEST - 128)) | (1 << (ClickHouseParser.THEN - 128)) | (1 << (ClickHouseParser.TIES - 128)) | (1 << (ClickHouseParser.TIMEOUT - 128)) | (1 << (ClickHouseParser.TIMESTAMP - 128)) | (1 << (ClickHouseParser.TO - 128)) | (1 << (ClickHouseParser.TOP - 128)) | (1 << (ClickHouseParser.TOTALS - 128)) | (1 << (ClickHouseParser.TRAILING - 128)) | (1 << (ClickHouseParser.TRIM - 128)) | (1 << (ClickHouseParser.TRUNCATE - 128)) | (1 << (ClickHouseParser.TTL - 128)) | (1 << (ClickHouseParser.TYPE - 128)) | (1 << (ClickHouseParser.UNION - 128)) | (1 << (ClickHouseParser.UPDATE - 128)) | (1 << (ClickHouseParser.USE - 128)) | (1 << (ClickHouseParser.USING - 128)) | (1 << (ClickHouseParser.UUID - 128)) | (1 << (ClickHouseParser.VALUES - 128)) | (1 << (ClickHouseParser.VIEW - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (ClickHouseParser.VOLUME - 192)) | (1 << (ClickHouseParser.WATCH - 192)) | (1 << (ClickHouseParser.WEEK - 192)) | (1 << (ClickHouseParser.VAR - 192)) | (1 << (ClickHouseParser.VARPOP - 192)) | (1 << (ClickHouseParser.VARIANCE - 192)) | (1 << (ClickHouseParser.WHEN - 192)) | (1 << (ClickHouseParser.WHERE - 192)) | (1 << (ClickHouseParser.WITH - 192)) | (1 << (ClickHouseParser.YEAR - 192)) | (1 << (ClickHouseParser.JSON_FALSE - 192)) | (1 << (ClickHouseParser.JSON_TRUE - 192)) | (1 << (ClickHouseParser.IDENTIFIER - 192)) | (1 << (ClickHouseParser.FLOATING_LITERAL - 192)) | (1 << (ClickHouseParser.OCTAL_LITERAL - 192)) | (1 << (ClickHouseParser.DECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.HEXADECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.STRING_LITERAL - 192)) | (1 << (ClickHouseParser.ASTERISK - 192)) | (1 << (ClickHouseParser.DASH - 192)) | (1 << (ClickHouseParser.DOT - 192)) | (1 << (ClickHouseParser.LBRACKET - 192)) | (1 << (ClickHouseParser.LPAREN - 192)) | (1 << (ClickHouseParser.PLUS - 192)))) != 0):
                    self.state = 615
                    self.columnArgList()


                self.state = 618
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 15:
                localctx = ClickHouseParser.ColumnExprLiteralContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 620
                self.literal()
                pass

            elif la_ == 16:
                localctx = ClickHouseParser.ColumnExprNegateContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 621
                self.match(ClickHouseParser.DASH)
                self.state = 622
                self.columnExpr(19)
                pass

            elif la_ == 17:
                localctx = ClickHouseParser.ColumnExprNotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 623
                self.match(ClickHouseParser.NOT)
                self.state = 624
                self.columnExpr(14)
                pass

            elif la_ == 18:
                localctx = ClickHouseParser.ColumnExprAliasSubqueryContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 625
                self.identifier()
                self.state = 626
                self.match(ClickHouseParser.AS)
                self.state = 627
                self.match(ClickHouseParser.LPAREN)
                self.state = 628
                self.selectUnionStmt()
                self.state = 629
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 19:
                localctx = ClickHouseParser.ColumnExprAsteriskContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 634
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.AFTER) | (1 << ClickHouseParser.ALIAS) | (1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ALTER) | (1 << ClickHouseParser.AND) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ARRAY) | (1 << ClickHouseParser.AS) | (1 << ClickHouseParser.ASCENDING) | (1 << ClickHouseParser.ASOF) | (1 << ClickHouseParser.ASYNC) | (1 << ClickHouseParser.ATTACH) | (1 << ClickHouseParser.BETWEEN) | (1 << ClickHouseParser.BOTH) | (1 << ClickHouseParser.BY) | (1 << ClickHouseParser.CASE) | (1 << ClickHouseParser.CAST) | (1 << ClickHouseParser.CHECK) | (1 << ClickHouseParser.CLEAR) | (1 << ClickHouseParser.CLUSTER) | (1 << ClickHouseParser.CODEC) | (1 << ClickHouseParser.COLLATE) | (1 << ClickHouseParser.COLUMN) | (1 << ClickHouseParser.COMMENT) | (1 << ClickHouseParser.CONSTRAINT) | (1 << ClickHouseParser.CREATE) | (1 << ClickHouseParser.CROSS) | (1 << ClickHouseParser.CUBE) | (1 << ClickHouseParser.DATABASE) | (1 << ClickHouseParser.DATABASES) | (1 << ClickHouseParser.DATE) | (1 << ClickHouseParser.DAY) | (1 << ClickHouseParser.DEDUPLICATE) | (1 << ClickHouseParser.DEFAULT) | (1 << ClickHouseParser.DELAY) | (1 << ClickHouseParser.DELETE) | (1 << ClickHouseParser.DESC) | (1 << ClickHouseParser.DESCENDING) | (1 << ClickHouseParser.DESCRIBE) | (1 << ClickHouseParser.DETACH) | (1 << ClickHouseParser.DICTIONARIES) | (1 << ClickHouseParser.DICTIONARY) | (1 << ClickHouseParser.DISK) | (1 << ClickHouseParser.DISTINCT) | (1 << ClickHouseParser.DISTRIBUTED) | (1 << ClickHouseParser.DROP) | (1 << ClickHouseParser.ELSE) | (1 << ClickHouseParser.END) | (1 << ClickHouseParser.ENGINE) | (1 << ClickHouseParser.EVENTS) | (1 << ClickHouseParser.EXISTS) | (1 << ClickHouseParser.EXPLAIN) | (1 << ClickHouseParser.EXPRESSION) | (1 << ClickHouseParser.EXTRACT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ClickHouseParser.FETCHES - 64)) | (1 << (ClickHouseParser.FINAL - 64)) | (1 << (ClickHouseParser.FIRST - 64)) | (1 << (ClickHouseParser.FLUSH - 64)) | (1 << (ClickHouseParser.FOR - 64)) | (1 << (ClickHouseParser.FORMAT - 64)) | (1 << (ClickHouseParser.FREEZE - 64)) | (1 << (ClickHouseParser.FROM - 64)) | (1 << (ClickHouseParser.FULL - 64)) | (1 << (ClickHouseParser.FUNCTION - 64)) | (1 << (ClickHouseParser.GLOBAL - 64)) | (1 << (ClickHouseParser.GRANULARITY - 64)) | (1 << (ClickHouseParser.GROUP - 64)) | (1 << (ClickHouseParser.HAVING - 64)) | (1 << (ClickHouseParser.HIERARCHICAL - 64)) | (1 << (ClickHouseParser.HOUR - 64)) | (1 << (ClickHouseParser.ID - 64)) | (1 << (ClickHouseParser.IF - 64)) | (1 << (ClickHouseParser.ILIKE - 64)) | (1 << (ClickHouseParser.IN - 64)) | (1 << (ClickHouseParser.INDEX - 64)) | (1 << (ClickHouseParser.INJECTIVE - 64)) | (1 << (ClickHouseParser.INNER - 64)) | (1 << (ClickHouseParser.INSERT - 64)) | (1 << (ClickHouseParser.INTERVAL - 64)) | (1 << (ClickHouseParser.INTO - 64)) | (1 << (ClickHouseParser.IS - 64)) | (1 << (ClickHouseParser.IS_OBJECT_ID - 64)) | (1 << (ClickHouseParser.JOIN - 64)) | (1 << (ClickHouseParser.KEY - 64)) | (1 << (ClickHouseParser.KILL - 64)) | (1 << (ClickHouseParser.LAST - 64)) | (1 << (ClickHouseParser.LAYOUT - 64)) | (1 << (ClickHouseParser.LEADING - 64)) | (1 << (ClickHouseParser.LEFT - 64)) | (1 << (ClickHouseParser.LIFETIME - 64)) | (1 << (ClickHouseParser.LIKE - 64)) | (1 << (ClickHouseParser.LIMIT - 64)) | (1 << (ClickHouseParser.LIVE - 64)) | (1 << (ClickHouseParser.LOCAL - 64)) | (1 << (ClickHouseParser.LOGS - 64)) | (1 << (ClickHouseParser.MATERIALIZED - 64)) | (1 << (ClickHouseParser.MAX - 64)) | (1 << (ClickHouseParser.MERGES - 64)) | (1 << (ClickHouseParser.MIN - 64)) | (1 << (ClickHouseParser.MINUTE - 64)) | (1 << (ClickHouseParser.MODIFY - 64)) | (1 << (ClickHouseParser.MONTH - 64)) | (1 << (ClickHouseParser.MOVE - 64)) | (1 << (ClickHouseParser.MUTATION - 64)) | (1 << (ClickHouseParser.NO - 64)) | (1 << (ClickHouseParser.NOT - 64)) | (1 << (ClickHouseParser.NULLS - 64)) | (1 << (ClickHouseParser.OFFSET - 64)) | (1 << (ClickHouseParser.ON - 64)) | (1 << (ClickHouseParser.OPTIMIZE - 64)) | (1 << (ClickHouseParser.OR - 64)) | (1 << (ClickHouseParser.ORDER - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (ClickHouseParser.OUTER - 128)) | (1 << (ClickHouseParser.OUTFILE - 128)) | (1 << (ClickHouseParser.PARTITION - 128)) | (1 << (ClickHouseParser.POPULATE - 128)) | (1 << (ClickHouseParser.PREWHERE - 128)) | (1 << (ClickHouseParser.PRIMARY - 128)) | (1 << (ClickHouseParser.QUARTER - 128)) | (1 << (ClickHouseParser.RANGE - 128)) | (1 << (ClickHouseParser.RELOAD - 128)) | (1 << (ClickHouseParser.REMOVE - 128)) | (1 << (ClickHouseParser.RENAME - 128)) | (1 << (ClickHouseParser.REPLACE - 128)) | (1 << (ClickHouseParser.REPLICA - 128)) | (1 << (ClickHouseParser.REPLICATED - 128)) | (1 << (ClickHouseParser.RIGHT - 128)) | (1 << (ClickHouseParser.ROLLUP - 128)) | (1 << (ClickHouseParser.SAMPLE - 128)) | (1 << (ClickHouseParser.SECOND - 128)) | (1 << (ClickHouseParser.SELECT - 128)) | (1 << (ClickHouseParser.SEMI - 128)) | (1 << (ClickHouseParser.SENDS - 128)) | (1 << (ClickHouseParser.SET - 128)) | (1 << (ClickHouseParser.SETTINGS - 128)) | (1 << (ClickHouseParser.SHOW - 128)) | (1 << (ClickHouseParser.SOURCE - 128)) | (1 << (ClickHouseParser.START - 128)) | (1 << (ClickHouseParser.STOP - 128)) | (1 << (ClickHouseParser.SUBSTRING - 128)) | (1 << (ClickHouseParser.SYNC - 128)) | (1 << (ClickHouseParser.SYNTAX - 128)) | (1 << (ClickHouseParser.SYSTEM - 128)) | (1 << (ClickHouseParser.TABLE - 128)) | (1 << (ClickHouseParser.TABLES - 128)) | (1 << (ClickHouseParser.TEMPORARY - 128)) | (1 << (ClickHouseParser.TEST - 128)) | (1 << (ClickHouseParser.THEN - 128)) | (1 << (ClickHouseParser.TIES - 128)) | (1 << (ClickHouseParser.TIMEOUT - 128)) | (1 << (ClickHouseParser.TIMESTAMP - 128)) | (1 << (ClickHouseParser.TO - 128)) | (1 << (ClickHouseParser.TOP - 128)) | (1 << (ClickHouseParser.TOTALS - 128)) | (1 << (ClickHouseParser.TRAILING - 128)) | (1 << (ClickHouseParser.TRIM - 128)) | (1 << (ClickHouseParser.TRUNCATE - 128)) | (1 << (ClickHouseParser.TTL - 128)) | (1 << (ClickHouseParser.TYPE - 128)) | (1 << (ClickHouseParser.UNION - 128)) | (1 << (ClickHouseParser.UPDATE - 128)) | (1 << (ClickHouseParser.USE - 128)) | (1 << (ClickHouseParser.USING - 128)) | (1 << (ClickHouseParser.UUID - 128)) | (1 << (ClickHouseParser.VALUES - 128)) | (1 << (ClickHouseParser.VIEW - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (ClickHouseParser.VOLUME - 192)) | (1 << (ClickHouseParser.WATCH - 192)) | (1 << (ClickHouseParser.WEEK - 192)) | (1 << (ClickHouseParser.WHEN - 192)) | (1 << (ClickHouseParser.WHERE - 192)) | (1 << (ClickHouseParser.WITH - 192)) | (1 << (ClickHouseParser.YEAR - 192)) | (1 << (ClickHouseParser.JSON_FALSE - 192)) | (1 << (ClickHouseParser.JSON_TRUE - 192)) | (1 << (ClickHouseParser.IDENTIFIER - 192)))) != 0):
                    self.state = 631
                    self.tableIdentifier()
                    self.state = 632
                    self.match(ClickHouseParser.DOT)


                self.state = 636
                self.match(ClickHouseParser.ASTERISK)
                pass

            elif la_ == 20:
                localctx = ClickHouseParser.ColumnExprSubqueryContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 637
                self.match(ClickHouseParser.LPAREN)
                self.state = 638
                self.selectUnionStmt()
                self.state = 639
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 21:
                localctx = ClickHouseParser.ColumnExprParensContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 641
                self.match(ClickHouseParser.LPAREN)
                self.state = 642
                self.columnExpr(0)
                self.state = 643
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 22:
                localctx = ClickHouseParser.ColumnExprTupleContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 645
                self.match(ClickHouseParser.LPAREN)
                self.state = 646
                self.columnExprList()
                self.state = 647
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 23:
                localctx = ClickHouseParser.ColumnExprArrayContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 649
                self.match(ClickHouseParser.LBRACKET)
                self.state = 651
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.AFTER) | (1 << ClickHouseParser.ALIAS) | (1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ALTER) | (1 << ClickHouseParser.AND) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ARRAY) | (1 << ClickHouseParser.AS) | (1 << ClickHouseParser.ASCENDING) | (1 << ClickHouseParser.ASOF) | (1 << ClickHouseParser.ASYNC) | (1 << ClickHouseParser.ATTACH) | (1 << ClickHouseParser.AVG) | (1 << ClickHouseParser.BETWEEN) | (1 << ClickHouseParser.BOTH) | (1 << ClickHouseParser.BY) | (1 << ClickHouseParser.CASE) | (1 << ClickHouseParser.CAST) | (1 << ClickHouseParser.CHECK) | (1 << ClickHouseParser.CLEAR) | (1 << ClickHouseParser.CLUSTER) | (1 << ClickHouseParser.CODEC) | (1 << ClickHouseParser.COLLATE) | (1 << ClickHouseParser.COLUMN) | (1 << ClickHouseParser.COMMENT) | (1 << ClickHouseParser.CONSTRAINT) | (1 << ClickHouseParser.COUNT) | (1 << ClickHouseParser.CREATE) | (1 << ClickHouseParser.CROSS) | (1 << ClickHouseParser.CUBE) | (1 << ClickHouseParser.DATABASE) | (1 << ClickHouseParser.DATABASES) | (1 << ClickHouseParser.DATE) | (1 << ClickHouseParser.DAY) | (1 << ClickHouseParser.DEDUPLICATE) | (1 << ClickHouseParser.DEFAULT) | (1 << ClickHouseParser.DELAY) | (1 << ClickHouseParser.DELETE) | (1 << ClickHouseParser.DESC) | (1 << ClickHouseParser.DESCENDING) | (1 << ClickHouseParser.DESCRIBE) | (1 << ClickHouseParser.DETACH) | (1 << ClickHouseParser.DICTIONARIES) | (1 << ClickHouseParser.DICTIONARY) | (1 << ClickHouseParser.DISK) | (1 << ClickHouseParser.DISTINCT) | (1 << ClickHouseParser.DISTRIBUTED) | (1 << ClickHouseParser.DROP) | (1 << ClickHouseParser.ELSE) | (1 << ClickHouseParser.END) | (1 << ClickHouseParser.ENGINE) | (1 << ClickHouseParser.EVENTS) | (1 << ClickHouseParser.EXISTS) | (1 << ClickHouseParser.EXPLAIN) | (1 << ClickHouseParser.EXPRESSION) | (1 << ClickHouseParser.EXTRACT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ClickHouseParser.FETCHES - 64)) | (1 << (ClickHouseParser.FINAL - 64)) | (1 << (ClickHouseParser.FIRST - 64)) | (1 << (ClickHouseParser.FLUSH - 64)) | (1 << (ClickHouseParser.FOR - 64)) | (1 << (ClickHouseParser.FORMAT - 64)) | (1 << (ClickHouseParser.FREEZE - 64)) | (1 << (ClickHouseParser.FROM - 64)) | (1 << (ClickHouseParser.FULL - 64)) | (1 << (ClickHouseParser.FUNCTION - 64)) | (1 << (ClickHouseParser.GLOBAL - 64)) | (1 << (ClickHouseParser.GRANULARITY - 64)) | (1 << (ClickHouseParser.GROUP - 64)) | (1 << (ClickHouseParser.HAVING - 64)) | (1 << (ClickHouseParser.HIERARCHICAL - 64)) | (1 << (ClickHouseParser.HOUR - 64)) | (1 << (ClickHouseParser.ID - 64)) | (1 << (ClickHouseParser.IF - 64)) | (1 << (ClickHouseParser.IIF - 64)) | (1 << (ClickHouseParser.ILIKE - 64)) | (1 << (ClickHouseParser.IN - 64)) | (1 << (ClickHouseParser.INDEX - 64)) | (1 << (ClickHouseParser.INF - 64)) | (1 << (ClickHouseParser.INJECTIVE - 64)) | (1 << (ClickHouseParser.INNER - 64)) | (1 << (ClickHouseParser.INSERT - 64)) | (1 << (ClickHouseParser.INTERVAL - 64)) | (1 << (ClickHouseParser.INTO - 64)) | (1 << (ClickHouseParser.IS - 64)) | (1 << (ClickHouseParser.IS_OBJECT_ID - 64)) | (1 << (ClickHouseParser.JOIN - 64)) | (1 << (ClickHouseParser.KEY - 64)) | (1 << (ClickHouseParser.KILL - 64)) | (1 << (ClickHouseParser.LAST - 64)) | (1 << (ClickHouseParser.LAYOUT - 64)) | (1 << (ClickHouseParser.LEADING - 64)) | (1 << (ClickHouseParser.LEFT - 64)) | (1 << (ClickHouseParser.LIFETIME - 64)) | (1 << (ClickHouseParser.LIKE - 64)) | (1 << (ClickHouseParser.LIMIT - 64)) | (1 << (ClickHouseParser.LIVE - 64)) | (1 << (ClickHouseParser.LOCAL - 64)) | (1 << (ClickHouseParser.LOGS - 64)) | (1 << (ClickHouseParser.MATERIALIZED - 64)) | (1 << (ClickHouseParser.MAX - 64)) | (1 << (ClickHouseParser.MERGES - 64)) | (1 << (ClickHouseParser.MIN - 64)) | (1 << (ClickHouseParser.MINUTE - 64)) | (1 << (ClickHouseParser.MODIFY - 64)) | (1 << (ClickHouseParser.MONTH - 64)) | (1 << (ClickHouseParser.MOVE - 64)) | (1 << (ClickHouseParser.MUTATION - 64)) | (1 << (ClickHouseParser.MULTIIF - 64)) | (1 << (ClickHouseParser.NAN_SQL - 64)) | (1 << (ClickHouseParser.NO - 64)) | (1 << (ClickHouseParser.NOT - 64)) | (1 << (ClickHouseParser.NULL_SQL - 64)) | (1 << (ClickHouseParser.NULLS - 64)) | (1 << (ClickHouseParser.OFFSET - 64)) | (1 << (ClickHouseParser.ON - 64)) | (1 << (ClickHouseParser.OPTIMIZE - 64)) | (1 << (ClickHouseParser.OR - 64)) | (1 << (ClickHouseParser.ORDER - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (ClickHouseParser.OUTER - 128)) | (1 << (ClickHouseParser.OUTFILE - 128)) | (1 << (ClickHouseParser.PARTITION - 128)) | (1 << (ClickHouseParser.PERCENTILE_CONT - 128)) | (1 << (ClickHouseParser.PERCENTILE_DISC - 128)) | (1 << (ClickHouseParser.POPULATE - 128)) | (1 << (ClickHouseParser.POW - 128)) | (1 << (ClickHouseParser.POWER - 128)) | (1 << (ClickHouseParser.PREWHERE - 128)) | (1 << (ClickHouseParser.PRIMARY - 128)) | (1 << (ClickHouseParser.QUARTER - 128)) | (1 << (ClickHouseParser.RANGE - 128)) | (1 << (ClickHouseParser.RELOAD - 128)) | (1 << (ClickHouseParser.REMOVE - 128)) | (1 << (ClickHouseParser.RENAME - 128)) | (1 << (ClickHouseParser.REPLACE - 128)) | (1 << (ClickHouseParser.REPLICA - 128)) | (1 << (ClickHouseParser.REPLICATED - 128)) | (1 << (ClickHouseParser.RIGHT - 128)) | (1 << (ClickHouseParser.ROLLUP - 128)) | (1 << (ClickHouseParser.SAMPLE - 128)) | (1 << (ClickHouseParser.SECOND - 128)) | (1 << (ClickHouseParser.SELECT - 128)) | (1 << (ClickHouseParser.SEMI - 128)) | (1 << (ClickHouseParser.SENDS - 128)) | (1 << (ClickHouseParser.SET - 128)) | (1 << (ClickHouseParser.SETTINGS - 128)) | (1 << (ClickHouseParser.SHOW - 128)) | (1 << (ClickHouseParser.SOURCE - 128)) | (1 << (ClickHouseParser.START - 128)) | (1 << (ClickHouseParser.STD - 128)) | (1 << (ClickHouseParser.STDDEV - 128)) | (1 << (ClickHouseParser.STDDEVPOP - 128)) | (1 << (ClickHouseParser.STOP - 128)) | (1 << (ClickHouseParser.SUBSTRING - 128)) | (1 << (ClickHouseParser.SUM - 128)) | (1 << (ClickHouseParser.SYNC - 128)) | (1 << (ClickHouseParser.SYNTAX - 128)) | (1 << (ClickHouseParser.SYSTEM - 128)) | (1 << (ClickHouseParser.TABLE - 128)) | (1 << (ClickHouseParser.TABLES - 128)) | (1 << (ClickHouseParser.TEMPORARY - 128)) | (1 << (ClickHouseParser.TEST - 128)) | (1 << (ClickHouseParser.THEN - 128)) | (1 << (ClickHouseParser.TIES - 128)) | (1 << (ClickHouseParser.TIMEOUT - 128)) | (1 << (ClickHouseParser.TIMESTAMP - 128)) | (1 << (ClickHouseParser.TO - 128)) | (1 << (ClickHouseParser.TOP - 128)) | (1 << (ClickHouseParser.TOTALS - 128)) | (1 << (ClickHouseParser.TRAILING - 128)) | (1 << (ClickHouseParser.TRIM - 128)) | (1 << (ClickHouseParser.TRUNCATE - 128)) | (1 << (ClickHouseParser.TTL - 128)) | (1 << (ClickHouseParser.TYPE - 128)) | (1 << (ClickHouseParser.UNION - 128)) | (1 << (ClickHouseParser.UPDATE - 128)) | (1 << (ClickHouseParser.USE - 128)) | (1 << (ClickHouseParser.USING - 128)) | (1 << (ClickHouseParser.UUID - 128)) | (1 << (ClickHouseParser.VALUES - 128)) | (1 << (ClickHouseParser.VIEW - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (ClickHouseParser.VOLUME - 192)) | (1 << (ClickHouseParser.WATCH - 192)) | (1 << (ClickHouseParser.WEEK - 192)) | (1 << (ClickHouseParser.VAR - 192)) | (1 << (ClickHouseParser.VARPOP - 192)) | (1 << (ClickHouseParser.VARIANCE - 192)) | (1 << (ClickHouseParser.WHEN - 192)) | (1 << (ClickHouseParser.WHERE - 192)) | (1 << (ClickHouseParser.WITH - 192)) | (1 << (ClickHouseParser.YEAR - 192)) | (1 << (ClickHouseParser.JSON_FALSE - 192)) | (1 << (ClickHouseParser.JSON_TRUE - 192)) | (1 << (ClickHouseParser.IDENTIFIER - 192)) | (1 << (ClickHouseParser.FLOATING_LITERAL - 192)) | (1 << (ClickHouseParser.OCTAL_LITERAL - 192)) | (1 << (ClickHouseParser.DECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.HEXADECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.STRING_LITERAL - 192)) | (1 << (ClickHouseParser.ASTERISK - 192)) | (1 << (ClickHouseParser.DASH - 192)) | (1 << (ClickHouseParser.DOT - 192)) | (1 << (ClickHouseParser.LBRACKET - 192)) | (1 << (ClickHouseParser.LPAREN - 192)) | (1 << (ClickHouseParser.PLUS - 192)))) != 0):
                    self.state = 650
                    self.columnExprList()


                self.state = 653
                self.match(ClickHouseParser.RBRACKET)
                pass

            elif la_ == 24:
                localctx = ClickHouseParser.ColumnExprIdentifierContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 654
                self.columnIdentifier()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 735
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,87,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 733
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,86,self._ctx)
                    if la_ == 1:
                        localctx = ClickHouseParser.ColumnExprPrecedence1Context(self, ClickHouseParser.ColumnExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_columnExpr)
                        self.state = 657
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 658
                        _la = self._input.LA(1)
                        if not(((((_la - 211)) & ~0x3f) == 0 and ((1 << (_la - 211)) & ((1 << (ClickHouseParser.ASTERISK - 211)) | (1 << (ClickHouseParser.PERCENT - 211)) | (1 << (ClickHouseParser.SLASH - 211)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 659
                        self.columnExpr(19)
                        pass

                    elif la_ == 2:
                        localctx = ClickHouseParser.ColumnExprPrecedence2Context(self, ClickHouseParser.ColumnExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_columnExpr)
                        self.state = 660
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 661
                        _la = self._input.LA(1)
                        if not(((((_la - 217)) & ~0x3f) == 0 and ((1 << (_la - 217)) & ((1 << (ClickHouseParser.CONCAT - 217)) | (1 << (ClickHouseParser.DASH - 217)) | (1 << (ClickHouseParser.PLUS - 217)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 662
                        self.columnExpr(18)
                        pass

                    elif la_ == 3:
                        localctx = ClickHouseParser.ColumnExprPrecedence3Context(self, ClickHouseParser.ColumnExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_columnExpr)
                        self.state = 663
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 682
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
                        if la_ == 1:
                            self.state = 664
                            self.match(ClickHouseParser.EQ_DOUBLE)
                            pass

                        elif la_ == 2:
                            self.state = 665
                            self.match(ClickHouseParser.EQ_SINGLE)
                            pass

                        elif la_ == 3:
                            self.state = 666
                            self.match(ClickHouseParser.NOT_EQ)
                            pass

                        elif la_ == 4:
                            self.state = 667
                            self.match(ClickHouseParser.LE)
                            pass

                        elif la_ == 5:
                            self.state = 668
                            self.match(ClickHouseParser.GE)
                            pass

                        elif la_ == 6:
                            self.state = 669
                            self.match(ClickHouseParser.LT)
                            pass

                        elif la_ == 7:
                            self.state = 670
                            self.match(ClickHouseParser.GT)
                            pass

                        elif la_ == 8:
                            self.state = 672
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==ClickHouseParser.GLOBAL:
                                self.state = 671
                                self.match(ClickHouseParser.GLOBAL)


                            self.state = 675
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==ClickHouseParser.NOT:
                                self.state = 674
                                self.match(ClickHouseParser.NOT)


                            self.state = 677
                            self.match(ClickHouseParser.IN)
                            pass

                        elif la_ == 9:
                            self.state = 679
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==ClickHouseParser.NOT:
                                self.state = 678
                                self.match(ClickHouseParser.NOT)


                            self.state = 681
                            _la = self._input.LA(1)
                            if not(_la==ClickHouseParser.ILIKE or _la==ClickHouseParser.LIKE):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()
                            pass


                        self.state = 684
                        self.columnExpr(17)
                        pass

                    elif la_ == 4:
                        localctx = ClickHouseParser.ColumnExprAndContext(self, ClickHouseParser.ColumnExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_columnExpr)
                        self.state = 685
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 686
                        self.match(ClickHouseParser.AND)
                        self.state = 687
                        self.columnExpr(14)
                        pass

                    elif la_ == 5:
                        localctx = ClickHouseParser.ColumnExprOrContext(self, ClickHouseParser.ColumnExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_columnExpr)
                        self.state = 688
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 689
                        self.match(ClickHouseParser.OR)
                        self.state = 690
                        self.columnExpr(13)
                        pass

                    elif la_ == 6:
                        localctx = ClickHouseParser.ColumnExprBetweenContext(self, ClickHouseParser.ColumnExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_columnExpr)
                        self.state = 691
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 693
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==ClickHouseParser.NOT:
                            self.state = 692
                            self.match(ClickHouseParser.NOT)


                        self.state = 695
                        self.match(ClickHouseParser.BETWEEN)
                        self.state = 696
                        self.columnExpr(0)
                        self.state = 697
                        self.match(ClickHouseParser.AND)
                        self.state = 698
                        self.columnExpr(12)
                        pass

                    elif la_ == 7:
                        localctx = ClickHouseParser.ColumnExprTernaryOpContext(self, ClickHouseParser.ColumnExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_columnExpr)
                        self.state = 700
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 701
                        self.match(ClickHouseParser.QUERY)
                        self.state = 702
                        self.columnExpr(0)
                        self.state = 703
                        self.match(ClickHouseParser.COLON)
                        self.state = 704
                        self.columnExpr(10)
                        pass

                    elif la_ == 8:
                        localctx = ClickHouseParser.ColumnQuoteExprContext(self, ClickHouseParser.ColumnExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_columnExpr)
                        self.state = 706
                        if not self.precpred(self._ctx, 23):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 23)")
                        self.state = 707
                        self.match(ClickHouseParser.LBRACE)
                        self.state = 708
                        self.match(ClickHouseParser.STRING_LITERAL)
                        self.state = 709
                        self.match(ClickHouseParser.RBRACE)
                        pass

                    elif la_ == 9:
                        localctx = ClickHouseParser.ColumnExprArrayAccessContext(self, ClickHouseParser.ColumnExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_columnExpr)
                        self.state = 710
                        if not self.precpred(self._ctx, 21):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 21)")
                        self.state = 711
                        self.match(ClickHouseParser.LBRACKET)
                        self.state = 712
                        self.columnExpr(0)
                        self.state = 713
                        self.match(ClickHouseParser.RBRACKET)
                        pass

                    elif la_ == 10:
                        localctx = ClickHouseParser.ColumnExprTupleAccessContext(self, ClickHouseParser.ColumnExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_columnExpr)
                        self.state = 715
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 716
                        self.match(ClickHouseParser.DOT)
                        self.state = 717
                        self.match(ClickHouseParser.DECIMAL_LITERAL)
                        pass

                    elif la_ == 11:
                        localctx = ClickHouseParser.ColumnExprIsNullContext(self, ClickHouseParser.ColumnExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_columnExpr)
                        self.state = 718
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 719
                        self.match(ClickHouseParser.IS)
                        self.state = 721
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==ClickHouseParser.NOT:
                            self.state = 720
                            self.match(ClickHouseParser.NOT)


                        self.state = 723
                        self.match(ClickHouseParser.NULL_SQL)
                        pass

                    elif la_ == 12:
                        localctx = ClickHouseParser.ColumnExprAliasContext(self, ClickHouseParser.ColumnExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_columnExpr)
                        self.state = 724
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 728
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [ClickHouseParser.DATE, ClickHouseParser.FIRST, ClickHouseParser.ID, ClickHouseParser.KEY, ClickHouseParser.IDENTIFIER]:
                            self.state = 725
                            self.alias()
                            pass
                        elif token in [ClickHouseParser.AS]:
                            self.state = 726
                            self.match(ClickHouseParser.AS)
                            self.state = 727
                            self.identifier()
                            pass
                        else:
                            raise NoViableAltException(self)

                        pass

                    elif la_ == 13:
                        localctx = ClickHouseParser.ColumnTypeDefinitionContext(self, ClickHouseParser.ColumnExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_columnExpr)
                        self.state = 730
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 731
                        self.match(ClickHouseParser.DOUBLECOLON)
                        self.state = 732
                        self.columnTypeExpr()
                        pass

             
                self.state = 737
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,87,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ColumnArgListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnArgExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnArgExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnArgExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_columnArgList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnArgList" ):
                listener.enterColumnArgList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnArgList" ):
                listener.exitColumnArgList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnArgList" ):
                return visitor.visitColumnArgList(self)
            else:
                return visitor.visitChildren(self)




    def columnArgList(self):

        localctx = ClickHouseParser.ColumnArgListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_columnArgList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 738
            self.columnArgExpr()
            self.state = 743
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==ClickHouseParser.COMMA:
                self.state = 739
                self.match(ClickHouseParser.COMMA)
                self.state = 740
                self.columnArgExpr()
                self.state = 745
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnArgExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnLambdaExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnLambdaExprContext,0)


        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_columnArgExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnArgExpr" ):
                listener.enterColumnArgExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnArgExpr" ):
                listener.exitColumnArgExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnArgExpr" ):
                return visitor.visitColumnArgExpr(self)
            else:
                return visitor.visitChildren(self)




    def columnArgExpr(self):

        localctx = ClickHouseParser.ColumnArgExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_columnArgExpr)
        try:
            self.state = 748
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 746
                self.columnLambdaExpr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 747
                self.columnExpr(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnLambdaExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARROW(self):
            return self.getToken(ClickHouseParser.ARROW, 0)

        def columnExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,0)


        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,i)


        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_columnLambdaExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnLambdaExpr" ):
                listener.enterColumnLambdaExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnLambdaExpr" ):
                listener.exitColumnLambdaExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnLambdaExpr" ):
                return visitor.visitColumnLambdaExpr(self)
            else:
                return visitor.visitChildren(self)




    def columnLambdaExpr(self):

        localctx = ClickHouseParser.ColumnLambdaExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_columnLambdaExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 769
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.LPAREN]:
                self.state = 750
                self.match(ClickHouseParser.LPAREN)
                self.state = 751
                self.identifier()
                self.state = 756
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==ClickHouseParser.COMMA:
                    self.state = 752
                    self.match(ClickHouseParser.COMMA)
                    self.state = 753
                    self.identifier()
                    self.state = 758
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 759
                self.match(ClickHouseParser.RPAREN)
                pass
            elif token in [ClickHouseParser.AFTER, ClickHouseParser.ALIAS, ClickHouseParser.ALL, ClickHouseParser.ALTER, ClickHouseParser.AND, ClickHouseParser.ANTI, ClickHouseParser.ANY, ClickHouseParser.ARRAY, ClickHouseParser.AS, ClickHouseParser.ASCENDING, ClickHouseParser.ASOF, ClickHouseParser.ASYNC, ClickHouseParser.ATTACH, ClickHouseParser.BETWEEN, ClickHouseParser.BOTH, ClickHouseParser.BY, ClickHouseParser.CASE, ClickHouseParser.CAST, ClickHouseParser.CHECK, ClickHouseParser.CLEAR, ClickHouseParser.CLUSTER, ClickHouseParser.CODEC, ClickHouseParser.COLLATE, ClickHouseParser.COLUMN, ClickHouseParser.COMMENT, ClickHouseParser.CONSTRAINT, ClickHouseParser.CREATE, ClickHouseParser.CROSS, ClickHouseParser.CUBE, ClickHouseParser.DATABASE, ClickHouseParser.DATABASES, ClickHouseParser.DATE, ClickHouseParser.DAY, ClickHouseParser.DEDUPLICATE, ClickHouseParser.DEFAULT, ClickHouseParser.DELAY, ClickHouseParser.DELETE, ClickHouseParser.DESC, ClickHouseParser.DESCENDING, ClickHouseParser.DESCRIBE, ClickHouseParser.DETACH, ClickHouseParser.DICTIONARIES, ClickHouseParser.DICTIONARY, ClickHouseParser.DISK, ClickHouseParser.DISTINCT, ClickHouseParser.DISTRIBUTED, ClickHouseParser.DROP, ClickHouseParser.ELSE, ClickHouseParser.END, ClickHouseParser.ENGINE, ClickHouseParser.EVENTS, ClickHouseParser.EXISTS, ClickHouseParser.EXPLAIN, ClickHouseParser.EXPRESSION, ClickHouseParser.EXTRACT, ClickHouseParser.FETCHES, ClickHouseParser.FINAL, ClickHouseParser.FIRST, ClickHouseParser.FLUSH, ClickHouseParser.FOR, ClickHouseParser.FORMAT, ClickHouseParser.FREEZE, ClickHouseParser.FROM, ClickHouseParser.FULL, ClickHouseParser.FUNCTION, ClickHouseParser.GLOBAL, ClickHouseParser.GRANULARITY, ClickHouseParser.GROUP, ClickHouseParser.HAVING, ClickHouseParser.HIERARCHICAL, ClickHouseParser.HOUR, ClickHouseParser.ID, ClickHouseParser.IF, ClickHouseParser.ILIKE, ClickHouseParser.IN, ClickHouseParser.INDEX, ClickHouseParser.INJECTIVE, ClickHouseParser.INNER, ClickHouseParser.INSERT, ClickHouseParser.INTERVAL, ClickHouseParser.INTO, ClickHouseParser.IS, ClickHouseParser.IS_OBJECT_ID, ClickHouseParser.JOIN, ClickHouseParser.KEY, ClickHouseParser.KILL, ClickHouseParser.LAST, ClickHouseParser.LAYOUT, ClickHouseParser.LEADING, ClickHouseParser.LEFT, ClickHouseParser.LIFETIME, ClickHouseParser.LIKE, ClickHouseParser.LIMIT, ClickHouseParser.LIVE, ClickHouseParser.LOCAL, ClickHouseParser.LOGS, ClickHouseParser.MATERIALIZED, ClickHouseParser.MAX, ClickHouseParser.MERGES, ClickHouseParser.MIN, ClickHouseParser.MINUTE, ClickHouseParser.MODIFY, ClickHouseParser.MONTH, ClickHouseParser.MOVE, ClickHouseParser.MUTATION, ClickHouseParser.NO, ClickHouseParser.NOT, ClickHouseParser.NULLS, ClickHouseParser.OFFSET, ClickHouseParser.ON, ClickHouseParser.OPTIMIZE, ClickHouseParser.OR, ClickHouseParser.ORDER, ClickHouseParser.OUTER, ClickHouseParser.OUTFILE, ClickHouseParser.PARTITION, ClickHouseParser.POPULATE, ClickHouseParser.PREWHERE, ClickHouseParser.PRIMARY, ClickHouseParser.QUARTER, ClickHouseParser.RANGE, ClickHouseParser.RELOAD, ClickHouseParser.REMOVE, ClickHouseParser.RENAME, ClickHouseParser.REPLACE, ClickHouseParser.REPLICA, ClickHouseParser.REPLICATED, ClickHouseParser.RIGHT, ClickHouseParser.ROLLUP, ClickHouseParser.SAMPLE, ClickHouseParser.SECOND, ClickHouseParser.SELECT, ClickHouseParser.SEMI, ClickHouseParser.SENDS, ClickHouseParser.SET, ClickHouseParser.SETTINGS, ClickHouseParser.SHOW, ClickHouseParser.SOURCE, ClickHouseParser.START, ClickHouseParser.STOP, ClickHouseParser.SUBSTRING, ClickHouseParser.SYNC, ClickHouseParser.SYNTAX, ClickHouseParser.SYSTEM, ClickHouseParser.TABLE, ClickHouseParser.TABLES, ClickHouseParser.TEMPORARY, ClickHouseParser.TEST, ClickHouseParser.THEN, ClickHouseParser.TIES, ClickHouseParser.TIMEOUT, ClickHouseParser.TIMESTAMP, ClickHouseParser.TO, ClickHouseParser.TOP, ClickHouseParser.TOTALS, ClickHouseParser.TRAILING, ClickHouseParser.TRIM, ClickHouseParser.TRUNCATE, ClickHouseParser.TTL, ClickHouseParser.TYPE, ClickHouseParser.UNION, ClickHouseParser.UPDATE, ClickHouseParser.USE, ClickHouseParser.USING, ClickHouseParser.UUID, ClickHouseParser.VALUES, ClickHouseParser.VIEW, ClickHouseParser.VOLUME, ClickHouseParser.WATCH, ClickHouseParser.WEEK, ClickHouseParser.WHEN, ClickHouseParser.WHERE, ClickHouseParser.WITH, ClickHouseParser.YEAR, ClickHouseParser.JSON_FALSE, ClickHouseParser.JSON_TRUE, ClickHouseParser.IDENTIFIER]:
                self.state = 761
                self.identifier()
                self.state = 766
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==ClickHouseParser.COMMA:
                    self.state = 762
                    self.match(ClickHouseParser.COMMA)
                    self.state = 763
                    self.identifier()
                    self.state = 768
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

            self.state = 771
            self.match(ClickHouseParser.ARROW)
            self.state = 772
            self.columnExpr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedIdentifier(self):
            return self.getTypedRuleContext(ClickHouseParser.NestedIdentifierContext,0)


        def tableIdentifier(self):
            return self.getTypedRuleContext(ClickHouseParser.TableIdentifierContext,0)


        def DOT(self):
            return self.getToken(ClickHouseParser.DOT, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_columnIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnIdentifier" ):
                listener.enterColumnIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnIdentifier" ):
                listener.exitColumnIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnIdentifier" ):
                return visitor.visitColumnIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def columnIdentifier(self):

        localctx = ClickHouseParser.ColumnIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_columnIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 777
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
            if la_ == 1:
                self.state = 774
                self.tableIdentifier()
                self.state = 775
                self.match(ClickHouseParser.DOT)


            self.state = 779
            self.nestedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,i)


        def DOT(self):
            return self.getToken(ClickHouseParser.DOT, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_nestedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedIdentifier" ):
                listener.enterNestedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedIdentifier" ):
                listener.exitNestedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNestedIdentifier" ):
                return visitor.visitNestedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def nestedIdentifier(self):

        localctx = ClickHouseParser.NestedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_nestedIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 781
            self.identifier()
            self.state = 784
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                self.state = 782
                self.match(ClickHouseParser.DOT)
                self.state = 783
                self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ClickHouseParser.RULE_tableExpr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class TableExprIdentifierContext(TableExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.TableExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def tableIdentifier(self):
            return self.getTypedRuleContext(ClickHouseParser.TableIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableExprIdentifier" ):
                listener.enterTableExprIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableExprIdentifier" ):
                listener.exitTableExprIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableExprIdentifier" ):
                return visitor.visitTableExprIdentifier(self)
            else:
                return visitor.visitChildren(self)


    class TableExprSubqueryContext(TableExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.TableExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)
        def selectUnionStmt(self):
            return self.getTypedRuleContext(ClickHouseParser.SelectUnionStmtContext,0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableExprSubquery" ):
                listener.enterTableExprSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableExprSubquery" ):
                listener.exitTableExprSubquery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableExprSubquery" ):
                return visitor.visitTableExprSubquery(self)
            else:
                return visitor.visitChildren(self)


    class TableExprAliasContext(TableExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.TableExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def tableExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.TableExprContext,0)

        def alias(self):
            return self.getTypedRuleContext(ClickHouseParser.AliasContext,0)

        def AS(self):
            return self.getToken(ClickHouseParser.AS, 0)
        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableExprAlias" ):
                listener.enterTableExprAlias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableExprAlias" ):
                listener.exitTableExprAlias(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableExprAlias" ):
                return visitor.visitTableExprAlias(self)
            else:
                return visitor.visitChildren(self)


    class TableFushionMergeContext(TableExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.TableExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def fushionMerge(self):
            return self.getTypedRuleContext(ClickHouseParser.FushionMergeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableFushionMerge" ):
                listener.enterTableFushionMerge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableFushionMerge" ):
                listener.exitTableFushionMerge(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableFushionMerge" ):
                return visitor.visitTableFushionMerge(self)
            else:
                return visitor.visitChildren(self)


    class TableExprFunctionContext(TableExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.TableExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def tableFunctionExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.TableFunctionExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableExprFunction" ):
                listener.enterTableExprFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableExprFunction" ):
                listener.exitTableExprFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableExprFunction" ):
                return visitor.visitTableExprFunction(self)
            else:
                return visitor.visitChildren(self)



    def tableExpr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ClickHouseParser.TableExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 88
        self.enterRecursionRule(localctx, 88, self.RULE_tableExpr, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 794
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
            if la_ == 1:
                localctx = ClickHouseParser.TableExprIdentifierContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 787
                self.tableIdentifier()
                pass

            elif la_ == 2:
                localctx = ClickHouseParser.TableExprFunctionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 788
                self.tableFunctionExpr()
                pass

            elif la_ == 3:
                localctx = ClickHouseParser.TableExprSubqueryContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 789
                self.match(ClickHouseParser.LPAREN)
                self.state = 790
                self.selectUnionStmt()
                self.state = 791
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 4:
                localctx = ClickHouseParser.TableFushionMergeContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 793
                self.fushionMerge()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 804
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,97,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = ClickHouseParser.TableExprAliasContext(self, ClickHouseParser.TableExprContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_tableExpr)
                    self.state = 796
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 800
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [ClickHouseParser.DATE, ClickHouseParser.FIRST, ClickHouseParser.ID, ClickHouseParser.KEY, ClickHouseParser.IDENTIFIER]:
                        self.state = 797
                        self.alias()
                        pass
                    elif token in [ClickHouseParser.AS]:
                        self.state = 798
                        self.match(ClickHouseParser.AS)
                        self.state = 799
                        self.identifier()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 806
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,97,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class FushionMergeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.db = None # DatabaseIdentifierContext
            self.table1 = None # TableIdentifierContext
            self.table2 = None # TableIdentifierContext
            self.splitcolumn = None # ColumnExprContext
            self.splitinfo = None # ColumnExprContext
            self.frange = None # ColumnExprContext
            self.srange = None # ColumnExprContext

        def FUSIONMERGE(self):
            return self.getToken(ClickHouseParser.FUSIONMERGE, 0)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def databaseIdentifier(self):
            return self.getTypedRuleContext(ClickHouseParser.DatabaseIdentifierContext,0)


        def tableIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.TableIdentifierContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.TableIdentifierContext,i)


        def columnExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ColumnExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ColumnExprContext,i)


        def alias(self):
            return self.getTypedRuleContext(ClickHouseParser.AliasContext,0)


        def AS(self):
            return self.getToken(ClickHouseParser.AS, 0)

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_fushionMerge

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFushionMerge" ):
                listener.enterFushionMerge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFushionMerge" ):
                listener.exitFushionMerge(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFushionMerge" ):
                return visitor.visitFushionMerge(self)
            else:
                return visitor.visitChildren(self)




    def fushionMerge(self):

        localctx = ClickHouseParser.FushionMergeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_fushionMerge)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 807
            self.match(ClickHouseParser.FUSIONMERGE)
            self.state = 808
            self.match(ClickHouseParser.LPAREN)
            self.state = 809
            localctx.db = self.databaseIdentifier()
            self.state = 810
            self.match(ClickHouseParser.COMMA)
            self.state = 811
            localctx.table1 = self.tableIdentifier()
            self.state = 812
            self.match(ClickHouseParser.COMMA)
            self.state = 813
            localctx.table2 = self.tableIdentifier()
            self.state = 814
            self.match(ClickHouseParser.COMMA)
            self.state = 815
            localctx.splitcolumn = self.columnExpr(0)
            self.state = 816
            self.match(ClickHouseParser.COMMA)
            self.state = 817
            localctx.splitinfo = self.columnExpr(0)
            self.state = 818
            self.match(ClickHouseParser.COMMA)
            self.state = 819
            localctx.frange = self.columnExpr(0)
            self.state = 820
            self.match(ClickHouseParser.COMMA)
            self.state = 821
            localctx.srange = self.columnExpr(0)
            self.state = 822
            self.match(ClickHouseParser.RPAREN)
            self.state = 826
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
            if la_ == 1:
                self.state = 823
                self.alias()

            elif la_ == 2:
                self.state = 824
                self.match(ClickHouseParser.AS)
                self.state = 825
                self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableFunctionExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)


        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def tableArgList(self):
            return self.getTypedRuleContext(ClickHouseParser.TableArgListContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_tableFunctionExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableFunctionExpr" ):
                listener.enterTableFunctionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableFunctionExpr" ):
                listener.exitTableFunctionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableFunctionExpr" ):
                return visitor.visitTableFunctionExpr(self)
            else:
                return visitor.visitChildren(self)




    def tableFunctionExpr(self):

        localctx = ClickHouseParser.TableFunctionExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_tableFunctionExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 828
            self.identifier()
            self.state = 829
            self.match(ClickHouseParser.LPAREN)
            self.state = 831
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.AFTER) | (1 << ClickHouseParser.ALIAS) | (1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ALTER) | (1 << ClickHouseParser.AND) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ARRAY) | (1 << ClickHouseParser.AS) | (1 << ClickHouseParser.ASCENDING) | (1 << ClickHouseParser.ASOF) | (1 << ClickHouseParser.ASYNC) | (1 << ClickHouseParser.ATTACH) | (1 << ClickHouseParser.BETWEEN) | (1 << ClickHouseParser.BOTH) | (1 << ClickHouseParser.BY) | (1 << ClickHouseParser.CASE) | (1 << ClickHouseParser.CAST) | (1 << ClickHouseParser.CHECK) | (1 << ClickHouseParser.CLEAR) | (1 << ClickHouseParser.CLUSTER) | (1 << ClickHouseParser.CODEC) | (1 << ClickHouseParser.COLLATE) | (1 << ClickHouseParser.COLUMN) | (1 << ClickHouseParser.COMMENT) | (1 << ClickHouseParser.CONSTRAINT) | (1 << ClickHouseParser.CREATE) | (1 << ClickHouseParser.CROSS) | (1 << ClickHouseParser.CUBE) | (1 << ClickHouseParser.DATABASE) | (1 << ClickHouseParser.DATABASES) | (1 << ClickHouseParser.DATE) | (1 << ClickHouseParser.DAY) | (1 << ClickHouseParser.DEDUPLICATE) | (1 << ClickHouseParser.DEFAULT) | (1 << ClickHouseParser.DELAY) | (1 << ClickHouseParser.DELETE) | (1 << ClickHouseParser.DESC) | (1 << ClickHouseParser.DESCENDING) | (1 << ClickHouseParser.DESCRIBE) | (1 << ClickHouseParser.DETACH) | (1 << ClickHouseParser.DICTIONARIES) | (1 << ClickHouseParser.DICTIONARY) | (1 << ClickHouseParser.DISK) | (1 << ClickHouseParser.DISTINCT) | (1 << ClickHouseParser.DISTRIBUTED) | (1 << ClickHouseParser.DROP) | (1 << ClickHouseParser.ELSE) | (1 << ClickHouseParser.END) | (1 << ClickHouseParser.ENGINE) | (1 << ClickHouseParser.EVENTS) | (1 << ClickHouseParser.EXISTS) | (1 << ClickHouseParser.EXPLAIN) | (1 << ClickHouseParser.EXPRESSION) | (1 << ClickHouseParser.EXTRACT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ClickHouseParser.FETCHES - 64)) | (1 << (ClickHouseParser.FINAL - 64)) | (1 << (ClickHouseParser.FIRST - 64)) | (1 << (ClickHouseParser.FLUSH - 64)) | (1 << (ClickHouseParser.FOR - 64)) | (1 << (ClickHouseParser.FORMAT - 64)) | (1 << (ClickHouseParser.FREEZE - 64)) | (1 << (ClickHouseParser.FROM - 64)) | (1 << (ClickHouseParser.FULL - 64)) | (1 << (ClickHouseParser.FUNCTION - 64)) | (1 << (ClickHouseParser.GLOBAL - 64)) | (1 << (ClickHouseParser.GRANULARITY - 64)) | (1 << (ClickHouseParser.GROUP - 64)) | (1 << (ClickHouseParser.HAVING - 64)) | (1 << (ClickHouseParser.HIERARCHICAL - 64)) | (1 << (ClickHouseParser.HOUR - 64)) | (1 << (ClickHouseParser.ID - 64)) | (1 << (ClickHouseParser.IF - 64)) | (1 << (ClickHouseParser.ILIKE - 64)) | (1 << (ClickHouseParser.IN - 64)) | (1 << (ClickHouseParser.INDEX - 64)) | (1 << (ClickHouseParser.INF - 64)) | (1 << (ClickHouseParser.INJECTIVE - 64)) | (1 << (ClickHouseParser.INNER - 64)) | (1 << (ClickHouseParser.INSERT - 64)) | (1 << (ClickHouseParser.INTERVAL - 64)) | (1 << (ClickHouseParser.INTO - 64)) | (1 << (ClickHouseParser.IS - 64)) | (1 << (ClickHouseParser.IS_OBJECT_ID - 64)) | (1 << (ClickHouseParser.JOIN - 64)) | (1 << (ClickHouseParser.KEY - 64)) | (1 << (ClickHouseParser.KILL - 64)) | (1 << (ClickHouseParser.LAST - 64)) | (1 << (ClickHouseParser.LAYOUT - 64)) | (1 << (ClickHouseParser.LEADING - 64)) | (1 << (ClickHouseParser.LEFT - 64)) | (1 << (ClickHouseParser.LIFETIME - 64)) | (1 << (ClickHouseParser.LIKE - 64)) | (1 << (ClickHouseParser.LIMIT - 64)) | (1 << (ClickHouseParser.LIVE - 64)) | (1 << (ClickHouseParser.LOCAL - 64)) | (1 << (ClickHouseParser.LOGS - 64)) | (1 << (ClickHouseParser.MATERIALIZED - 64)) | (1 << (ClickHouseParser.MAX - 64)) | (1 << (ClickHouseParser.MERGES - 64)) | (1 << (ClickHouseParser.MIN - 64)) | (1 << (ClickHouseParser.MINUTE - 64)) | (1 << (ClickHouseParser.MODIFY - 64)) | (1 << (ClickHouseParser.MONTH - 64)) | (1 << (ClickHouseParser.MOVE - 64)) | (1 << (ClickHouseParser.MUTATION - 64)) | (1 << (ClickHouseParser.NAN_SQL - 64)) | (1 << (ClickHouseParser.NO - 64)) | (1 << (ClickHouseParser.NOT - 64)) | (1 << (ClickHouseParser.NULL_SQL - 64)) | (1 << (ClickHouseParser.NULLS - 64)) | (1 << (ClickHouseParser.OFFSET - 64)) | (1 << (ClickHouseParser.ON - 64)) | (1 << (ClickHouseParser.OPTIMIZE - 64)) | (1 << (ClickHouseParser.OR - 64)) | (1 << (ClickHouseParser.ORDER - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (ClickHouseParser.OUTER - 128)) | (1 << (ClickHouseParser.OUTFILE - 128)) | (1 << (ClickHouseParser.PARTITION - 128)) | (1 << (ClickHouseParser.POPULATE - 128)) | (1 << (ClickHouseParser.PREWHERE - 128)) | (1 << (ClickHouseParser.PRIMARY - 128)) | (1 << (ClickHouseParser.QUARTER - 128)) | (1 << (ClickHouseParser.RANGE - 128)) | (1 << (ClickHouseParser.RELOAD - 128)) | (1 << (ClickHouseParser.REMOVE - 128)) | (1 << (ClickHouseParser.RENAME - 128)) | (1 << (ClickHouseParser.REPLACE - 128)) | (1 << (ClickHouseParser.REPLICA - 128)) | (1 << (ClickHouseParser.REPLICATED - 128)) | (1 << (ClickHouseParser.RIGHT - 128)) | (1 << (ClickHouseParser.ROLLUP - 128)) | (1 << (ClickHouseParser.SAMPLE - 128)) | (1 << (ClickHouseParser.SECOND - 128)) | (1 << (ClickHouseParser.SELECT - 128)) | (1 << (ClickHouseParser.SEMI - 128)) | (1 << (ClickHouseParser.SENDS - 128)) | (1 << (ClickHouseParser.SET - 128)) | (1 << (ClickHouseParser.SETTINGS - 128)) | (1 << (ClickHouseParser.SHOW - 128)) | (1 << (ClickHouseParser.SOURCE - 128)) | (1 << (ClickHouseParser.START - 128)) | (1 << (ClickHouseParser.STOP - 128)) | (1 << (ClickHouseParser.SUBSTRING - 128)) | (1 << (ClickHouseParser.SYNC - 128)) | (1 << (ClickHouseParser.SYNTAX - 128)) | (1 << (ClickHouseParser.SYSTEM - 128)) | (1 << (ClickHouseParser.TABLE - 128)) | (1 << (ClickHouseParser.TABLES - 128)) | (1 << (ClickHouseParser.TEMPORARY - 128)) | (1 << (ClickHouseParser.TEST - 128)) | (1 << (ClickHouseParser.THEN - 128)) | (1 << (ClickHouseParser.TIES - 128)) | (1 << (ClickHouseParser.TIMEOUT - 128)) | (1 << (ClickHouseParser.TIMESTAMP - 128)) | (1 << (ClickHouseParser.TO - 128)) | (1 << (ClickHouseParser.TOP - 128)) | (1 << (ClickHouseParser.TOTALS - 128)) | (1 << (ClickHouseParser.TRAILING - 128)) | (1 << (ClickHouseParser.TRIM - 128)) | (1 << (ClickHouseParser.TRUNCATE - 128)) | (1 << (ClickHouseParser.TTL - 128)) | (1 << (ClickHouseParser.TYPE - 128)) | (1 << (ClickHouseParser.UNION - 128)) | (1 << (ClickHouseParser.UPDATE - 128)) | (1 << (ClickHouseParser.USE - 128)) | (1 << (ClickHouseParser.USING - 128)) | (1 << (ClickHouseParser.UUID - 128)) | (1 << (ClickHouseParser.VALUES - 128)) | (1 << (ClickHouseParser.VIEW - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (ClickHouseParser.VOLUME - 192)) | (1 << (ClickHouseParser.WATCH - 192)) | (1 << (ClickHouseParser.WEEK - 192)) | (1 << (ClickHouseParser.WHEN - 192)) | (1 << (ClickHouseParser.WHERE - 192)) | (1 << (ClickHouseParser.WITH - 192)) | (1 << (ClickHouseParser.YEAR - 192)) | (1 << (ClickHouseParser.JSON_FALSE - 192)) | (1 << (ClickHouseParser.JSON_TRUE - 192)) | (1 << (ClickHouseParser.IDENTIFIER - 192)) | (1 << (ClickHouseParser.FLOATING_LITERAL - 192)) | (1 << (ClickHouseParser.OCTAL_LITERAL - 192)) | (1 << (ClickHouseParser.DECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.HEXADECIMAL_LITERAL - 192)) | (1 << (ClickHouseParser.STRING_LITERAL - 192)) | (1 << (ClickHouseParser.DASH - 192)) | (1 << (ClickHouseParser.DOT - 192)) | (1 << (ClickHouseParser.PLUS - 192)))) != 0):
                self.state = 830
                self.tableArgList()


            self.state = 833
            self.match(ClickHouseParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)


        def databaseIdentifier(self):
            return self.getTypedRuleContext(ClickHouseParser.DatabaseIdentifierContext,0)


        def DOT(self):
            return self.getToken(ClickHouseParser.DOT, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_tableIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableIdentifier" ):
                listener.enterTableIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableIdentifier" ):
                listener.exitTableIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableIdentifier" ):
                return visitor.visitTableIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def tableIdentifier(self):

        localctx = ClickHouseParser.TableIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_tableIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 838
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.state = 835
                self.databaseIdentifier()
                self.state = 836
                self.match(ClickHouseParser.DOT)


            self.state = 840
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableArgListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableArgExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.TableArgExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.TableArgExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_tableArgList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableArgList" ):
                listener.enterTableArgList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableArgList" ):
                listener.exitTableArgList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableArgList" ):
                return visitor.visitTableArgList(self)
            else:
                return visitor.visitChildren(self)




    def tableArgList(self):

        localctx = ClickHouseParser.TableArgListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_tableArgList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 842
            self.tableArgExpr()
            self.state = 847
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==ClickHouseParser.COMMA:
                self.state = 843
                self.match(ClickHouseParser.COMMA)
                self.state = 844
                self.tableArgExpr()
                self.state = 849
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableArgExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableIdentifier(self):
            return self.getTypedRuleContext(ClickHouseParser.TableIdentifierContext,0)


        def tableFunctionExpr(self):
            return self.getTypedRuleContext(ClickHouseParser.TableFunctionExprContext,0)


        def literal(self):
            return self.getTypedRuleContext(ClickHouseParser.LiteralContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_tableArgExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableArgExpr" ):
                listener.enterTableArgExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableArgExpr" ):
                listener.exitTableArgExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableArgExpr" ):
                return visitor.visitTableArgExpr(self)
            else:
                return visitor.visitChildren(self)




    def tableArgExpr(self):

        localctx = ClickHouseParser.TableArgExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_tableArgExpr)
        try:
            self.state = 853
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 850
                self.tableIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 851
                self.tableFunctionExpr()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 852
                self.literal()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatabaseIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_databaseIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatabaseIdentifier" ):
                listener.enterDatabaseIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatabaseIdentifier" ):
                listener.exitDatabaseIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatabaseIdentifier" ):
                return visitor.visitDatabaseIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def databaseIdentifier(self):

        localctx = ClickHouseParser.DatabaseIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_databaseIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 855
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FloatingLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOATING_LITERAL(self):
            return self.getToken(ClickHouseParser.FLOATING_LITERAL, 0)

        def DOT(self):
            return self.getToken(ClickHouseParser.DOT, 0)

        def DECIMAL_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(ClickHouseParser.DECIMAL_LITERAL)
            else:
                return self.getToken(ClickHouseParser.DECIMAL_LITERAL, i)

        def OCTAL_LITERAL(self):
            return self.getToken(ClickHouseParser.OCTAL_LITERAL, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_floatingLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFloatingLiteral" ):
                listener.enterFloatingLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFloatingLiteral" ):
                listener.exitFloatingLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFloatingLiteral" ):
                return visitor.visitFloatingLiteral(self)
            else:
                return visitor.visitChildren(self)




    def floatingLiteral(self):

        localctx = ClickHouseParser.FloatingLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_floatingLiteral)
        self._la = 0 # Token type
        try:
            self.state = 865
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.FLOATING_LITERAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 857
                self.match(ClickHouseParser.FLOATING_LITERAL)
                pass
            elif token in [ClickHouseParser.DOT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 858
                self.match(ClickHouseParser.DOT)
                self.state = 859
                _la = self._input.LA(1)
                if not(_la==ClickHouseParser.OCTAL_LITERAL or _la==ClickHouseParser.DECIMAL_LITERAL):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [ClickHouseParser.DECIMAL_LITERAL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 860
                self.match(ClickHouseParser.DECIMAL_LITERAL)
                self.state = 861
                self.match(ClickHouseParser.DOT)
                self.state = 863
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
                if la_ == 1:
                    self.state = 862
                    _la = self._input.LA(1)
                    if not(_la==ClickHouseParser.OCTAL_LITERAL or _la==ClickHouseParser.DECIMAL_LITERAL):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def floatingLiteral(self):
            return self.getTypedRuleContext(ClickHouseParser.FloatingLiteralContext,0)


        def OCTAL_LITERAL(self):
            return self.getToken(ClickHouseParser.OCTAL_LITERAL, 0)

        def DECIMAL_LITERAL(self):
            return self.getToken(ClickHouseParser.DECIMAL_LITERAL, 0)

        def HEXADECIMAL_LITERAL(self):
            return self.getToken(ClickHouseParser.HEXADECIMAL_LITERAL, 0)

        def INF(self):
            return self.getToken(ClickHouseParser.INF, 0)

        def NAN_SQL(self):
            return self.getToken(ClickHouseParser.NAN_SQL, 0)

        def PLUS(self):
            return self.getToken(ClickHouseParser.PLUS, 0)

        def DASH(self):
            return self.getToken(ClickHouseParser.DASH, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_numberLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberLiteral" ):
                listener.enterNumberLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberLiteral" ):
                listener.exitNumberLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberLiteral" ):
                return visitor.visitNumberLiteral(self)
            else:
                return visitor.visitChildren(self)




    def numberLiteral(self):

        localctx = ClickHouseParser.NumberLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_numberLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 868
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ClickHouseParser.DASH or _la==ClickHouseParser.PLUS:
                self.state = 867
                _la = self._input.LA(1)
                if not(_la==ClickHouseParser.DASH or _la==ClickHouseParser.PLUS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 876
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,106,self._ctx)
            if la_ == 1:
                self.state = 870
                self.floatingLiteral()
                pass

            elif la_ == 2:
                self.state = 871
                self.match(ClickHouseParser.OCTAL_LITERAL)
                pass

            elif la_ == 3:
                self.state = 872
                self.match(ClickHouseParser.DECIMAL_LITERAL)
                pass

            elif la_ == 4:
                self.state = 873
                self.match(ClickHouseParser.HEXADECIMAL_LITERAL)
                pass

            elif la_ == 5:
                self.state = 874
                self.match(ClickHouseParser.INF)
                pass

            elif la_ == 6:
                self.state = 875
                self.match(ClickHouseParser.NAN_SQL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ClickHouseParser.RULE_literal

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class NullliteralContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NULL_SQL(self):
            return self.getToken(ClickHouseParser.NULL_SQL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNullliteral" ):
                listener.enterNullliteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNullliteral" ):
                listener.exitNullliteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNullliteral" ):
                return visitor.visitNullliteral(self)
            else:
                return visitor.visitChildren(self)


    class NumliteralContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def numberLiteral(self):
            return self.getTypedRuleContext(ClickHouseParser.NumberLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumliteral" ):
                listener.enterNumliteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumliteral" ):
                listener.exitNumliteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumliteral" ):
                return visitor.visitNumliteral(self)
            else:
                return visitor.visitChildren(self)


    class StringliteralContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ClickHouseParser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringliteral" ):
                listener.enterStringliteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringliteral" ):
                listener.exitStringliteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringliteral" ):
                return visitor.visitStringliteral(self)
            else:
                return visitor.visitChildren(self)



    def literal(self):

        localctx = ClickHouseParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_literal)
        try:
            self.state = 881
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.INF, ClickHouseParser.NAN_SQL, ClickHouseParser.FLOATING_LITERAL, ClickHouseParser.OCTAL_LITERAL, ClickHouseParser.DECIMAL_LITERAL, ClickHouseParser.HEXADECIMAL_LITERAL, ClickHouseParser.DASH, ClickHouseParser.DOT, ClickHouseParser.PLUS]:
                localctx = ClickHouseParser.NumliteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 878
                self.numberLiteral()
                pass
            elif token in [ClickHouseParser.STRING_LITERAL]:
                localctx = ClickHouseParser.StringliteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 879
                self.match(ClickHouseParser.STRING_LITERAL)
                pass
            elif token in [ClickHouseParser.NULL_SQL]:
                localctx = ClickHouseParser.NullliteralContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 880
                self.match(ClickHouseParser.NULL_SQL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SECOND(self):
            return self.getToken(ClickHouseParser.SECOND, 0)

        def MINUTE(self):
            return self.getToken(ClickHouseParser.MINUTE, 0)

        def HOUR(self):
            return self.getToken(ClickHouseParser.HOUR, 0)

        def DAY(self):
            return self.getToken(ClickHouseParser.DAY, 0)

        def WEEK(self):
            return self.getToken(ClickHouseParser.WEEK, 0)

        def MONTH(self):
            return self.getToken(ClickHouseParser.MONTH, 0)

        def QUARTER(self):
            return self.getToken(ClickHouseParser.QUARTER, 0)

        def YEAR(self):
            return self.getToken(ClickHouseParser.YEAR, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_interval

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterval" ):
                listener.enterInterval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterval" ):
                listener.exitInterval(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterval" ):
                return visitor.visitInterval(self)
            else:
                return visitor.visitChildren(self)




    def interval(self):

        localctx = ClickHouseParser.IntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_interval)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 883
            _la = self._input.LA(1)
            if not(_la==ClickHouseParser.DAY or ((((_la - 80)) & ~0x3f) == 0 and ((1 << (_la - 80)) & ((1 << (ClickHouseParser.HOUR - 80)) | (1 << (ClickHouseParser.MINUTE - 80)) | (1 << (ClickHouseParser.MONTH - 80)) | (1 << (ClickHouseParser.QUARTER - 80)))) != 0) or ((((_la - 149)) & ~0x3f) == 0 and ((1 << (_la - 149)) & ((1 << (ClickHouseParser.SECOND - 149)) | (1 << (ClickHouseParser.WEEK - 149)) | (1 << (ClickHouseParser.YEAR - 149)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregateFunctionNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COUNT(self):
            return self.getToken(ClickHouseParser.COUNT, 0)

        def SUM(self):
            return self.getToken(ClickHouseParser.SUM, 0)

        def AVG(self):
            return self.getToken(ClickHouseParser.AVG, 0)

        def VAR(self):
            return self.getToken(ClickHouseParser.VAR, 0)

        def VARPOP(self):
            return self.getToken(ClickHouseParser.VARPOP, 0)

        def VARIANCE(self):
            return self.getToken(ClickHouseParser.VARIANCE, 0)

        def STD(self):
            return self.getToken(ClickHouseParser.STD, 0)

        def STDDEV(self):
            return self.getToken(ClickHouseParser.STDDEV, 0)

        def STDDEVPOP(self):
            return self.getToken(ClickHouseParser.STDDEVPOP, 0)

        def MIN(self):
            return self.getToken(ClickHouseParser.MIN, 0)

        def MAX(self):
            return self.getToken(ClickHouseParser.MAX, 0)

        def PERCENTILE_DISC(self):
            return self.getToken(ClickHouseParser.PERCENTILE_DISC, 0)

        def PERCENTILE_CONT(self):
            return self.getToken(ClickHouseParser.PERCENTILE_CONT, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_aggregateFunctionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregateFunctionName" ):
                listener.enterAggregateFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregateFunctionName" ):
                listener.exitAggregateFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregateFunctionName" ):
                return visitor.visitAggregateFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def aggregateFunctionName(self):

        localctx = ClickHouseParser.AggregateFunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_aggregateFunctionName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 885
            _la = self._input.LA(1)
            if not(_la==ClickHouseParser.AVG or _la==ClickHouseParser.COUNT or ((((_la - 109)) & ~0x3f) == 0 and ((1 << (_la - 109)) & ((1 << (ClickHouseParser.MAX - 109)) | (1 << (ClickHouseParser.MIN - 109)) | (1 << (ClickHouseParser.PERCENTILE_CONT - 109)) | (1 << (ClickHouseParser.PERCENTILE_DISC - 109)) | (1 << (ClickHouseParser.STD - 109)) | (1 << (ClickHouseParser.STDDEV - 109)) | (1 << (ClickHouseParser.STDDEVPOP - 109)) | (1 << (ClickHouseParser.SUM - 109)))) != 0) or ((((_la - 195)) & ~0x3f) == 0 and ((1 << (_la - 195)) & ((1 << (ClickHouseParser.VAR - 195)) | (1 << (ClickHouseParser.VARPOP - 195)) | (1 << (ClickHouseParser.VARIANCE - 195)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecimalTypeNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ClickHouseParser.RULE_decimalTypeName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecimalTypeName" ):
                listener.enterDecimalTypeName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecimalTypeName" ):
                listener.exitDecimalTypeName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecimalTypeName" ):
                return visitor.visitDecimalTypeName(self)
            else:
                return visitor.visitChildren(self)




    def decimalTypeName(self):

        localctx = ClickHouseParser.DecimalTypeNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_decimalTypeName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 887
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.T__0) | (1 << ClickHouseParser.T__1) | (1 << ClickHouseParser.T__2) | (1 << ClickHouseParser.T__3) | (1 << ClickHouseParser.T__4))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TupleOrArrayNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TUPLE(self):
            return self.getToken(ClickHouseParser.TUPLE, 0)

        def ARRAY(self):
            return self.getToken(ClickHouseParser.ARRAY, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_tupleOrArrayName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTupleOrArrayName" ):
                listener.enterTupleOrArrayName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTupleOrArrayName" ):
                listener.exitTupleOrArrayName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTupleOrArrayName" ):
                return visitor.visitTupleOrArrayName(self)
            else:
                return visitor.visitChildren(self)




    def tupleOrArrayName(self):

        localctx = ClickHouseParser.TupleOrArrayNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_tupleOrArrayName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 889
            _la = self._input.LA(1)
            if not(_la==ClickHouseParser.ARRAY or _la==ClickHouseParser.TUPLE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AFTER(self):
            return self.getToken(ClickHouseParser.AFTER, 0)

        def ALIAS(self):
            return self.getToken(ClickHouseParser.ALIAS, 0)

        def ALL(self):
            return self.getToken(ClickHouseParser.ALL, 0)

        def ALTER(self):
            return self.getToken(ClickHouseParser.ALTER, 0)

        def AND(self):
            return self.getToken(ClickHouseParser.AND, 0)

        def ANTI(self):
            return self.getToken(ClickHouseParser.ANTI, 0)

        def ANY(self):
            return self.getToken(ClickHouseParser.ANY, 0)

        def ARRAY(self):
            return self.getToken(ClickHouseParser.ARRAY, 0)

        def AS(self):
            return self.getToken(ClickHouseParser.AS, 0)

        def ASCENDING(self):
            return self.getToken(ClickHouseParser.ASCENDING, 0)

        def ASOF(self):
            return self.getToken(ClickHouseParser.ASOF, 0)

        def ASYNC(self):
            return self.getToken(ClickHouseParser.ASYNC, 0)

        def ATTACH(self):
            return self.getToken(ClickHouseParser.ATTACH, 0)

        def BETWEEN(self):
            return self.getToken(ClickHouseParser.BETWEEN, 0)

        def BOTH(self):
            return self.getToken(ClickHouseParser.BOTH, 0)

        def BY(self):
            return self.getToken(ClickHouseParser.BY, 0)

        def CASE(self):
            return self.getToken(ClickHouseParser.CASE, 0)

        def CAST(self):
            return self.getToken(ClickHouseParser.CAST, 0)

        def CHECK(self):
            return self.getToken(ClickHouseParser.CHECK, 0)

        def CLEAR(self):
            return self.getToken(ClickHouseParser.CLEAR, 0)

        def CLUSTER(self):
            return self.getToken(ClickHouseParser.CLUSTER, 0)

        def CODEC(self):
            return self.getToken(ClickHouseParser.CODEC, 0)

        def COLLATE(self):
            return self.getToken(ClickHouseParser.COLLATE, 0)

        def COLUMN(self):
            return self.getToken(ClickHouseParser.COLUMN, 0)

        def COMMENT(self):
            return self.getToken(ClickHouseParser.COMMENT, 0)

        def CONSTRAINT(self):
            return self.getToken(ClickHouseParser.CONSTRAINT, 0)

        def CREATE(self):
            return self.getToken(ClickHouseParser.CREATE, 0)

        def CROSS(self):
            return self.getToken(ClickHouseParser.CROSS, 0)

        def CUBE(self):
            return self.getToken(ClickHouseParser.CUBE, 0)

        def DATABASE(self):
            return self.getToken(ClickHouseParser.DATABASE, 0)

        def DATABASES(self):
            return self.getToken(ClickHouseParser.DATABASES, 0)

        def DATE(self):
            return self.getToken(ClickHouseParser.DATE, 0)

        def DEDUPLICATE(self):
            return self.getToken(ClickHouseParser.DEDUPLICATE, 0)

        def DEFAULT(self):
            return self.getToken(ClickHouseParser.DEFAULT, 0)

        def DELAY(self):
            return self.getToken(ClickHouseParser.DELAY, 0)

        def DELETE(self):
            return self.getToken(ClickHouseParser.DELETE, 0)

        def DESCRIBE(self):
            return self.getToken(ClickHouseParser.DESCRIBE, 0)

        def DESC(self):
            return self.getToken(ClickHouseParser.DESC, 0)

        def DESCENDING(self):
            return self.getToken(ClickHouseParser.DESCENDING, 0)

        def DETACH(self):
            return self.getToken(ClickHouseParser.DETACH, 0)

        def DICTIONARIES(self):
            return self.getToken(ClickHouseParser.DICTIONARIES, 0)

        def DICTIONARY(self):
            return self.getToken(ClickHouseParser.DICTIONARY, 0)

        def DISK(self):
            return self.getToken(ClickHouseParser.DISK, 0)

        def DISTINCT(self):
            return self.getToken(ClickHouseParser.DISTINCT, 0)

        def DISTRIBUTED(self):
            return self.getToken(ClickHouseParser.DISTRIBUTED, 0)

        def DROP(self):
            return self.getToken(ClickHouseParser.DROP, 0)

        def ELSE(self):
            return self.getToken(ClickHouseParser.ELSE, 0)

        def END(self):
            return self.getToken(ClickHouseParser.END, 0)

        def ENGINE(self):
            return self.getToken(ClickHouseParser.ENGINE, 0)

        def EVENTS(self):
            return self.getToken(ClickHouseParser.EVENTS, 0)

        def EXISTS(self):
            return self.getToken(ClickHouseParser.EXISTS, 0)

        def EXPLAIN(self):
            return self.getToken(ClickHouseParser.EXPLAIN, 0)

        def EXPRESSION(self):
            return self.getToken(ClickHouseParser.EXPRESSION, 0)

        def EXTRACT(self):
            return self.getToken(ClickHouseParser.EXTRACT, 0)

        def FETCHES(self):
            return self.getToken(ClickHouseParser.FETCHES, 0)

        def FINAL(self):
            return self.getToken(ClickHouseParser.FINAL, 0)

        def FIRST(self):
            return self.getToken(ClickHouseParser.FIRST, 0)

        def FLUSH(self):
            return self.getToken(ClickHouseParser.FLUSH, 0)

        def FOR(self):
            return self.getToken(ClickHouseParser.FOR, 0)

        def FORMAT(self):
            return self.getToken(ClickHouseParser.FORMAT, 0)

        def FREEZE(self):
            return self.getToken(ClickHouseParser.FREEZE, 0)

        def FROM(self):
            return self.getToken(ClickHouseParser.FROM, 0)

        def FULL(self):
            return self.getToken(ClickHouseParser.FULL, 0)

        def FUNCTION(self):
            return self.getToken(ClickHouseParser.FUNCTION, 0)

        def GLOBAL(self):
            return self.getToken(ClickHouseParser.GLOBAL, 0)

        def GRANULARITY(self):
            return self.getToken(ClickHouseParser.GRANULARITY, 0)

        def GROUP(self):
            return self.getToken(ClickHouseParser.GROUP, 0)

        def HAVING(self):
            return self.getToken(ClickHouseParser.HAVING, 0)

        def HIERARCHICAL(self):
            return self.getToken(ClickHouseParser.HIERARCHICAL, 0)

        def ID(self):
            return self.getToken(ClickHouseParser.ID, 0)

        def IF(self):
            return self.getToken(ClickHouseParser.IF, 0)

        def ILIKE(self):
            return self.getToken(ClickHouseParser.ILIKE, 0)

        def IN(self):
            return self.getToken(ClickHouseParser.IN, 0)

        def INDEX(self):
            return self.getToken(ClickHouseParser.INDEX, 0)

        def INJECTIVE(self):
            return self.getToken(ClickHouseParser.INJECTIVE, 0)

        def INNER(self):
            return self.getToken(ClickHouseParser.INNER, 0)

        def INSERT(self):
            return self.getToken(ClickHouseParser.INSERT, 0)

        def INTERVAL(self):
            return self.getToken(ClickHouseParser.INTERVAL, 0)

        def INTO(self):
            return self.getToken(ClickHouseParser.INTO, 0)

        def IS(self):
            return self.getToken(ClickHouseParser.IS, 0)

        def IS_OBJECT_ID(self):
            return self.getToken(ClickHouseParser.IS_OBJECT_ID, 0)

        def JOIN(self):
            return self.getToken(ClickHouseParser.JOIN, 0)

        def JSON_FALSE(self):
            return self.getToken(ClickHouseParser.JSON_FALSE, 0)

        def JSON_TRUE(self):
            return self.getToken(ClickHouseParser.JSON_TRUE, 0)

        def KEY(self):
            return self.getToken(ClickHouseParser.KEY, 0)

        def KILL(self):
            return self.getToken(ClickHouseParser.KILL, 0)

        def LAST(self):
            return self.getToken(ClickHouseParser.LAST, 0)

        def LAYOUT(self):
            return self.getToken(ClickHouseParser.LAYOUT, 0)

        def LEADING(self):
            return self.getToken(ClickHouseParser.LEADING, 0)

        def LEFT(self):
            return self.getToken(ClickHouseParser.LEFT, 0)

        def LIFETIME(self):
            return self.getToken(ClickHouseParser.LIFETIME, 0)

        def LIKE(self):
            return self.getToken(ClickHouseParser.LIKE, 0)

        def LIMIT(self):
            return self.getToken(ClickHouseParser.LIMIT, 0)

        def LIVE(self):
            return self.getToken(ClickHouseParser.LIVE, 0)

        def LOCAL(self):
            return self.getToken(ClickHouseParser.LOCAL, 0)

        def LOGS(self):
            return self.getToken(ClickHouseParser.LOGS, 0)

        def MATERIALIZED(self):
            return self.getToken(ClickHouseParser.MATERIALIZED, 0)

        def MAX(self):
            return self.getToken(ClickHouseParser.MAX, 0)

        def MERGES(self):
            return self.getToken(ClickHouseParser.MERGES, 0)

        def MIN(self):
            return self.getToken(ClickHouseParser.MIN, 0)

        def MODIFY(self):
            return self.getToken(ClickHouseParser.MODIFY, 0)

        def MOVE(self):
            return self.getToken(ClickHouseParser.MOVE, 0)

        def MUTATION(self):
            return self.getToken(ClickHouseParser.MUTATION, 0)

        def NO(self):
            return self.getToken(ClickHouseParser.NO, 0)

        def NOT(self):
            return self.getToken(ClickHouseParser.NOT, 0)

        def NULLS(self):
            return self.getToken(ClickHouseParser.NULLS, 0)

        def OFFSET(self):
            return self.getToken(ClickHouseParser.OFFSET, 0)

        def ON(self):
            return self.getToken(ClickHouseParser.ON, 0)

        def OPTIMIZE(self):
            return self.getToken(ClickHouseParser.OPTIMIZE, 0)

        def OR(self):
            return self.getToken(ClickHouseParser.OR, 0)

        def ORDER(self):
            return self.getToken(ClickHouseParser.ORDER, 0)

        def OUTER(self):
            return self.getToken(ClickHouseParser.OUTER, 0)

        def OUTFILE(self):
            return self.getToken(ClickHouseParser.OUTFILE, 0)

        def PARTITION(self):
            return self.getToken(ClickHouseParser.PARTITION, 0)

        def POPULATE(self):
            return self.getToken(ClickHouseParser.POPULATE, 0)

        def PREWHERE(self):
            return self.getToken(ClickHouseParser.PREWHERE, 0)

        def PRIMARY(self):
            return self.getToken(ClickHouseParser.PRIMARY, 0)

        def RANGE(self):
            return self.getToken(ClickHouseParser.RANGE, 0)

        def RELOAD(self):
            return self.getToken(ClickHouseParser.RELOAD, 0)

        def REMOVE(self):
            return self.getToken(ClickHouseParser.REMOVE, 0)

        def RENAME(self):
            return self.getToken(ClickHouseParser.RENAME, 0)

        def REPLACE(self):
            return self.getToken(ClickHouseParser.REPLACE, 0)

        def REPLICA(self):
            return self.getToken(ClickHouseParser.REPLICA, 0)

        def REPLICATED(self):
            return self.getToken(ClickHouseParser.REPLICATED, 0)

        def RIGHT(self):
            return self.getToken(ClickHouseParser.RIGHT, 0)

        def ROLLUP(self):
            return self.getToken(ClickHouseParser.ROLLUP, 0)

        def SAMPLE(self):
            return self.getToken(ClickHouseParser.SAMPLE, 0)

        def SELECT(self):
            return self.getToken(ClickHouseParser.SELECT, 0)

        def SEMI(self):
            return self.getToken(ClickHouseParser.SEMI, 0)

        def SENDS(self):
            return self.getToken(ClickHouseParser.SENDS, 0)

        def SET(self):
            return self.getToken(ClickHouseParser.SET, 0)

        def SETTINGS(self):
            return self.getToken(ClickHouseParser.SETTINGS, 0)

        def SHOW(self):
            return self.getToken(ClickHouseParser.SHOW, 0)

        def SOURCE(self):
            return self.getToken(ClickHouseParser.SOURCE, 0)

        def START(self):
            return self.getToken(ClickHouseParser.START, 0)

        def STOP(self):
            return self.getToken(ClickHouseParser.STOP, 0)

        def SUBSTRING(self):
            return self.getToken(ClickHouseParser.SUBSTRING, 0)

        def SYNC(self):
            return self.getToken(ClickHouseParser.SYNC, 0)

        def SYNTAX(self):
            return self.getToken(ClickHouseParser.SYNTAX, 0)

        def SYSTEM(self):
            return self.getToken(ClickHouseParser.SYSTEM, 0)

        def TABLE(self):
            return self.getToken(ClickHouseParser.TABLE, 0)

        def TABLES(self):
            return self.getToken(ClickHouseParser.TABLES, 0)

        def TEMPORARY(self):
            return self.getToken(ClickHouseParser.TEMPORARY, 0)

        def TEST(self):
            return self.getToken(ClickHouseParser.TEST, 0)

        def THEN(self):
            return self.getToken(ClickHouseParser.THEN, 0)

        def TIES(self):
            return self.getToken(ClickHouseParser.TIES, 0)

        def TIMEOUT(self):
            return self.getToken(ClickHouseParser.TIMEOUT, 0)

        def TIMESTAMP(self):
            return self.getToken(ClickHouseParser.TIMESTAMP, 0)

        def TOTALS(self):
            return self.getToken(ClickHouseParser.TOTALS, 0)

        def TRAILING(self):
            return self.getToken(ClickHouseParser.TRAILING, 0)

        def TRIM(self):
            return self.getToken(ClickHouseParser.TRIM, 0)

        def TRUNCATE(self):
            return self.getToken(ClickHouseParser.TRUNCATE, 0)

        def TO(self):
            return self.getToken(ClickHouseParser.TO, 0)

        def TOP(self):
            return self.getToken(ClickHouseParser.TOP, 0)

        def TTL(self):
            return self.getToken(ClickHouseParser.TTL, 0)

        def TYPE(self):
            return self.getToken(ClickHouseParser.TYPE, 0)

        def UNION(self):
            return self.getToken(ClickHouseParser.UNION, 0)

        def UPDATE(self):
            return self.getToken(ClickHouseParser.UPDATE, 0)

        def USE(self):
            return self.getToken(ClickHouseParser.USE, 0)

        def USING(self):
            return self.getToken(ClickHouseParser.USING, 0)

        def UUID(self):
            return self.getToken(ClickHouseParser.UUID, 0)

        def VALUES(self):
            return self.getToken(ClickHouseParser.VALUES, 0)

        def VIEW(self):
            return self.getToken(ClickHouseParser.VIEW, 0)

        def VOLUME(self):
            return self.getToken(ClickHouseParser.VOLUME, 0)

        def WATCH(self):
            return self.getToken(ClickHouseParser.WATCH, 0)

        def WHEN(self):
            return self.getToken(ClickHouseParser.WHEN, 0)

        def WHERE(self):
            return self.getToken(ClickHouseParser.WHERE, 0)

        def WITH(self):
            return self.getToken(ClickHouseParser.WITH, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_keyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyword" ):
                listener.enterKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyword" ):
                listener.exitKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyword" ):
                return visitor.visitKeyword(self)
            else:
                return visitor.visitChildren(self)




    def keyword(self):

        localctx = ClickHouseParser.KeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_keyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 891
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ClickHouseParser.AFTER) | (1 << ClickHouseParser.ALIAS) | (1 << ClickHouseParser.ALL) | (1 << ClickHouseParser.ALTER) | (1 << ClickHouseParser.AND) | (1 << ClickHouseParser.ANTI) | (1 << ClickHouseParser.ANY) | (1 << ClickHouseParser.ARRAY) | (1 << ClickHouseParser.AS) | (1 << ClickHouseParser.ASCENDING) | (1 << ClickHouseParser.ASOF) | (1 << ClickHouseParser.ASYNC) | (1 << ClickHouseParser.ATTACH) | (1 << ClickHouseParser.BETWEEN) | (1 << ClickHouseParser.BOTH) | (1 << ClickHouseParser.BY) | (1 << ClickHouseParser.CASE) | (1 << ClickHouseParser.CAST) | (1 << ClickHouseParser.CHECK) | (1 << ClickHouseParser.CLEAR) | (1 << ClickHouseParser.CLUSTER) | (1 << ClickHouseParser.CODEC) | (1 << ClickHouseParser.COLLATE) | (1 << ClickHouseParser.COLUMN) | (1 << ClickHouseParser.COMMENT) | (1 << ClickHouseParser.CONSTRAINT) | (1 << ClickHouseParser.CREATE) | (1 << ClickHouseParser.CROSS) | (1 << ClickHouseParser.CUBE) | (1 << ClickHouseParser.DATABASE) | (1 << ClickHouseParser.DATABASES) | (1 << ClickHouseParser.DATE) | (1 << ClickHouseParser.DEDUPLICATE) | (1 << ClickHouseParser.DEFAULT) | (1 << ClickHouseParser.DELAY) | (1 << ClickHouseParser.DELETE) | (1 << ClickHouseParser.DESC) | (1 << ClickHouseParser.DESCENDING) | (1 << ClickHouseParser.DESCRIBE) | (1 << ClickHouseParser.DETACH) | (1 << ClickHouseParser.DICTIONARIES) | (1 << ClickHouseParser.DICTIONARY) | (1 << ClickHouseParser.DISK) | (1 << ClickHouseParser.DISTINCT) | (1 << ClickHouseParser.DISTRIBUTED) | (1 << ClickHouseParser.DROP) | (1 << ClickHouseParser.ELSE) | (1 << ClickHouseParser.END) | (1 << ClickHouseParser.ENGINE) | (1 << ClickHouseParser.EVENTS) | (1 << ClickHouseParser.EXISTS) | (1 << ClickHouseParser.EXPLAIN) | (1 << ClickHouseParser.EXPRESSION) | (1 << ClickHouseParser.EXTRACT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (ClickHouseParser.FETCHES - 64)) | (1 << (ClickHouseParser.FINAL - 64)) | (1 << (ClickHouseParser.FIRST - 64)) | (1 << (ClickHouseParser.FLUSH - 64)) | (1 << (ClickHouseParser.FOR - 64)) | (1 << (ClickHouseParser.FORMAT - 64)) | (1 << (ClickHouseParser.FREEZE - 64)) | (1 << (ClickHouseParser.FROM - 64)) | (1 << (ClickHouseParser.FULL - 64)) | (1 << (ClickHouseParser.FUNCTION - 64)) | (1 << (ClickHouseParser.GLOBAL - 64)) | (1 << (ClickHouseParser.GRANULARITY - 64)) | (1 << (ClickHouseParser.GROUP - 64)) | (1 << (ClickHouseParser.HAVING - 64)) | (1 << (ClickHouseParser.HIERARCHICAL - 64)) | (1 << (ClickHouseParser.ID - 64)) | (1 << (ClickHouseParser.IF - 64)) | (1 << (ClickHouseParser.ILIKE - 64)) | (1 << (ClickHouseParser.IN - 64)) | (1 << (ClickHouseParser.INDEX - 64)) | (1 << (ClickHouseParser.INJECTIVE - 64)) | (1 << (ClickHouseParser.INNER - 64)) | (1 << (ClickHouseParser.INSERT - 64)) | (1 << (ClickHouseParser.INTERVAL - 64)) | (1 << (ClickHouseParser.INTO - 64)) | (1 << (ClickHouseParser.IS - 64)) | (1 << (ClickHouseParser.IS_OBJECT_ID - 64)) | (1 << (ClickHouseParser.JOIN - 64)) | (1 << (ClickHouseParser.KEY - 64)) | (1 << (ClickHouseParser.KILL - 64)) | (1 << (ClickHouseParser.LAST - 64)) | (1 << (ClickHouseParser.LAYOUT - 64)) | (1 << (ClickHouseParser.LEADING - 64)) | (1 << (ClickHouseParser.LEFT - 64)) | (1 << (ClickHouseParser.LIFETIME - 64)) | (1 << (ClickHouseParser.LIKE - 64)) | (1 << (ClickHouseParser.LIMIT - 64)) | (1 << (ClickHouseParser.LIVE - 64)) | (1 << (ClickHouseParser.LOCAL - 64)) | (1 << (ClickHouseParser.LOGS - 64)) | (1 << (ClickHouseParser.MATERIALIZED - 64)) | (1 << (ClickHouseParser.MAX - 64)) | (1 << (ClickHouseParser.MERGES - 64)) | (1 << (ClickHouseParser.MIN - 64)) | (1 << (ClickHouseParser.MODIFY - 64)) | (1 << (ClickHouseParser.MOVE - 64)) | (1 << (ClickHouseParser.MUTATION - 64)) | (1 << (ClickHouseParser.NO - 64)) | (1 << (ClickHouseParser.NOT - 64)) | (1 << (ClickHouseParser.NULLS - 64)) | (1 << (ClickHouseParser.OFFSET - 64)) | (1 << (ClickHouseParser.ON - 64)) | (1 << (ClickHouseParser.OPTIMIZE - 64)) | (1 << (ClickHouseParser.OR - 64)) | (1 << (ClickHouseParser.ORDER - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (ClickHouseParser.OUTER - 128)) | (1 << (ClickHouseParser.OUTFILE - 128)) | (1 << (ClickHouseParser.PARTITION - 128)) | (1 << (ClickHouseParser.POPULATE - 128)) | (1 << (ClickHouseParser.PREWHERE - 128)) | (1 << (ClickHouseParser.PRIMARY - 128)) | (1 << (ClickHouseParser.RANGE - 128)) | (1 << (ClickHouseParser.RELOAD - 128)) | (1 << (ClickHouseParser.REMOVE - 128)) | (1 << (ClickHouseParser.RENAME - 128)) | (1 << (ClickHouseParser.REPLACE - 128)) | (1 << (ClickHouseParser.REPLICA - 128)) | (1 << (ClickHouseParser.REPLICATED - 128)) | (1 << (ClickHouseParser.RIGHT - 128)) | (1 << (ClickHouseParser.ROLLUP - 128)) | (1 << (ClickHouseParser.SAMPLE - 128)) | (1 << (ClickHouseParser.SELECT - 128)) | (1 << (ClickHouseParser.SEMI - 128)) | (1 << (ClickHouseParser.SENDS - 128)) | (1 << (ClickHouseParser.SET - 128)) | (1 << (ClickHouseParser.SETTINGS - 128)) | (1 << (ClickHouseParser.SHOW - 128)) | (1 << (ClickHouseParser.SOURCE - 128)) | (1 << (ClickHouseParser.START - 128)) | (1 << (ClickHouseParser.STOP - 128)) | (1 << (ClickHouseParser.SUBSTRING - 128)) | (1 << (ClickHouseParser.SYNC - 128)) | (1 << (ClickHouseParser.SYNTAX - 128)) | (1 << (ClickHouseParser.SYSTEM - 128)) | (1 << (ClickHouseParser.TABLE - 128)) | (1 << (ClickHouseParser.TABLES - 128)) | (1 << (ClickHouseParser.TEMPORARY - 128)) | (1 << (ClickHouseParser.TEST - 128)) | (1 << (ClickHouseParser.THEN - 128)) | (1 << (ClickHouseParser.TIES - 128)) | (1 << (ClickHouseParser.TIMEOUT - 128)) | (1 << (ClickHouseParser.TIMESTAMP - 128)) | (1 << (ClickHouseParser.TO - 128)) | (1 << (ClickHouseParser.TOP - 128)) | (1 << (ClickHouseParser.TOTALS - 128)) | (1 << (ClickHouseParser.TRAILING - 128)) | (1 << (ClickHouseParser.TRIM - 128)) | (1 << (ClickHouseParser.TRUNCATE - 128)) | (1 << (ClickHouseParser.TTL - 128)) | (1 << (ClickHouseParser.TYPE - 128)) | (1 << (ClickHouseParser.UNION - 128)) | (1 << (ClickHouseParser.UPDATE - 128)) | (1 << (ClickHouseParser.USE - 128)) | (1 << (ClickHouseParser.USING - 128)) | (1 << (ClickHouseParser.UUID - 128)) | (1 << (ClickHouseParser.VALUES - 128)) | (1 << (ClickHouseParser.VIEW - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (ClickHouseParser.VOLUME - 192)) | (1 << (ClickHouseParser.WATCH - 192)) | (1 << (ClickHouseParser.WHEN - 192)) | (1 << (ClickHouseParser.WHERE - 192)) | (1 << (ClickHouseParser.WITH - 192)) | (1 << (ClickHouseParser.JSON_FALSE - 192)) | (1 << (ClickHouseParser.JSON_TRUE - 192)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeywordForAliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE(self):
            return self.getToken(ClickHouseParser.DATE, 0)

        def FIRST(self):
            return self.getToken(ClickHouseParser.FIRST, 0)

        def ID(self):
            return self.getToken(ClickHouseParser.ID, 0)

        def KEY(self):
            return self.getToken(ClickHouseParser.KEY, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_keywordForAlias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeywordForAlias" ):
                listener.enterKeywordForAlias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeywordForAlias" ):
                listener.exitKeywordForAlias(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeywordForAlias" ):
                return visitor.visitKeywordForAlias(self)
            else:
                return visitor.visitChildren(self)




    def keywordForAlias(self):

        localctx = ClickHouseParser.KeywordForAliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_keywordForAlias)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 893
            _la = self._input.LA(1)
            if not(((((_la - 40)) & ~0x3f) == 0 and ((1 << (_la - 40)) & ((1 << (ClickHouseParser.DATE - 40)) | (1 << (ClickHouseParser.FIRST - 40)) | (1 << (ClickHouseParser.ID - 40)) | (1 << (ClickHouseParser.KEY - 40)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ClickHouseParser.IDENTIFIER, 0)

        def keywordForAlias(self):
            return self.getTypedRuleContext(ClickHouseParser.KeywordForAliasContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_alias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlias" ):
                listener.enterAlias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlias" ):
                listener.exitAlias(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlias" ):
                return visitor.visitAlias(self)
            else:
                return visitor.visitChildren(self)




    def alias(self):

        localctx = ClickHouseParser.AliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_alias)
        try:
            self.state = 897
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 895
                self.match(ClickHouseParser.IDENTIFIER)
                pass
            elif token in [ClickHouseParser.DATE, ClickHouseParser.FIRST, ClickHouseParser.ID, ClickHouseParser.KEY]:
                self.enterOuterAlt(localctx, 2)
                self.state = 896
                self.keywordForAlias()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ClickHouseParser.IDENTIFIER, 0)

        def interval(self):
            return self.getTypedRuleContext(ClickHouseParser.IntervalContext,0)


        def keyword(self):
            return self.getTypedRuleContext(ClickHouseParser.KeywordContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = ClickHouseParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_identifier)
        try:
            self.state = 902
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 899
                self.match(ClickHouseParser.IDENTIFIER)
                pass
            elif token in [ClickHouseParser.DAY, ClickHouseParser.HOUR, ClickHouseParser.MINUTE, ClickHouseParser.MONTH, ClickHouseParser.QUARTER, ClickHouseParser.SECOND, ClickHouseParser.WEEK, ClickHouseParser.YEAR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 900
                self.interval()
                pass
            elif token in [ClickHouseParser.AFTER, ClickHouseParser.ALIAS, ClickHouseParser.ALL, ClickHouseParser.ALTER, ClickHouseParser.AND, ClickHouseParser.ANTI, ClickHouseParser.ANY, ClickHouseParser.ARRAY, ClickHouseParser.AS, ClickHouseParser.ASCENDING, ClickHouseParser.ASOF, ClickHouseParser.ASYNC, ClickHouseParser.ATTACH, ClickHouseParser.BETWEEN, ClickHouseParser.BOTH, ClickHouseParser.BY, ClickHouseParser.CASE, ClickHouseParser.CAST, ClickHouseParser.CHECK, ClickHouseParser.CLEAR, ClickHouseParser.CLUSTER, ClickHouseParser.CODEC, ClickHouseParser.COLLATE, ClickHouseParser.COLUMN, ClickHouseParser.COMMENT, ClickHouseParser.CONSTRAINT, ClickHouseParser.CREATE, ClickHouseParser.CROSS, ClickHouseParser.CUBE, ClickHouseParser.DATABASE, ClickHouseParser.DATABASES, ClickHouseParser.DATE, ClickHouseParser.DEDUPLICATE, ClickHouseParser.DEFAULT, ClickHouseParser.DELAY, ClickHouseParser.DELETE, ClickHouseParser.DESC, ClickHouseParser.DESCENDING, ClickHouseParser.DESCRIBE, ClickHouseParser.DETACH, ClickHouseParser.DICTIONARIES, ClickHouseParser.DICTIONARY, ClickHouseParser.DISK, ClickHouseParser.DISTINCT, ClickHouseParser.DISTRIBUTED, ClickHouseParser.DROP, ClickHouseParser.ELSE, ClickHouseParser.END, ClickHouseParser.ENGINE, ClickHouseParser.EVENTS, ClickHouseParser.EXISTS, ClickHouseParser.EXPLAIN, ClickHouseParser.EXPRESSION, ClickHouseParser.EXTRACT, ClickHouseParser.FETCHES, ClickHouseParser.FINAL, ClickHouseParser.FIRST, ClickHouseParser.FLUSH, ClickHouseParser.FOR, ClickHouseParser.FORMAT, ClickHouseParser.FREEZE, ClickHouseParser.FROM, ClickHouseParser.FULL, ClickHouseParser.FUNCTION, ClickHouseParser.GLOBAL, ClickHouseParser.GRANULARITY, ClickHouseParser.GROUP, ClickHouseParser.HAVING, ClickHouseParser.HIERARCHICAL, ClickHouseParser.ID, ClickHouseParser.IF, ClickHouseParser.ILIKE, ClickHouseParser.IN, ClickHouseParser.INDEX, ClickHouseParser.INJECTIVE, ClickHouseParser.INNER, ClickHouseParser.INSERT, ClickHouseParser.INTERVAL, ClickHouseParser.INTO, ClickHouseParser.IS, ClickHouseParser.IS_OBJECT_ID, ClickHouseParser.JOIN, ClickHouseParser.KEY, ClickHouseParser.KILL, ClickHouseParser.LAST, ClickHouseParser.LAYOUT, ClickHouseParser.LEADING, ClickHouseParser.LEFT, ClickHouseParser.LIFETIME, ClickHouseParser.LIKE, ClickHouseParser.LIMIT, ClickHouseParser.LIVE, ClickHouseParser.LOCAL, ClickHouseParser.LOGS, ClickHouseParser.MATERIALIZED, ClickHouseParser.MAX, ClickHouseParser.MERGES, ClickHouseParser.MIN, ClickHouseParser.MODIFY, ClickHouseParser.MOVE, ClickHouseParser.MUTATION, ClickHouseParser.NO, ClickHouseParser.NOT, ClickHouseParser.NULLS, ClickHouseParser.OFFSET, ClickHouseParser.ON, ClickHouseParser.OPTIMIZE, ClickHouseParser.OR, ClickHouseParser.ORDER, ClickHouseParser.OUTER, ClickHouseParser.OUTFILE, ClickHouseParser.PARTITION, ClickHouseParser.POPULATE, ClickHouseParser.PREWHERE, ClickHouseParser.PRIMARY, ClickHouseParser.RANGE, ClickHouseParser.RELOAD, ClickHouseParser.REMOVE, ClickHouseParser.RENAME, ClickHouseParser.REPLACE, ClickHouseParser.REPLICA, ClickHouseParser.REPLICATED, ClickHouseParser.RIGHT, ClickHouseParser.ROLLUP, ClickHouseParser.SAMPLE, ClickHouseParser.SELECT, ClickHouseParser.SEMI, ClickHouseParser.SENDS, ClickHouseParser.SET, ClickHouseParser.SETTINGS, ClickHouseParser.SHOW, ClickHouseParser.SOURCE, ClickHouseParser.START, ClickHouseParser.STOP, ClickHouseParser.SUBSTRING, ClickHouseParser.SYNC, ClickHouseParser.SYNTAX, ClickHouseParser.SYSTEM, ClickHouseParser.TABLE, ClickHouseParser.TABLES, ClickHouseParser.TEMPORARY, ClickHouseParser.TEST, ClickHouseParser.THEN, ClickHouseParser.TIES, ClickHouseParser.TIMEOUT, ClickHouseParser.TIMESTAMP, ClickHouseParser.TO, ClickHouseParser.TOP, ClickHouseParser.TOTALS, ClickHouseParser.TRAILING, ClickHouseParser.TRIM, ClickHouseParser.TRUNCATE, ClickHouseParser.TTL, ClickHouseParser.TYPE, ClickHouseParser.UNION, ClickHouseParser.UPDATE, ClickHouseParser.USE, ClickHouseParser.USING, ClickHouseParser.UUID, ClickHouseParser.VALUES, ClickHouseParser.VIEW, ClickHouseParser.VOLUME, ClickHouseParser.WATCH, ClickHouseParser.WHEN, ClickHouseParser.WHERE, ClickHouseParser.WITH, ClickHouseParser.JSON_FALSE, ClickHouseParser.JSON_TRUE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 901
                self.keyword()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierOrNullContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext,0)


        def NULL_SQL(self):
            return self.getToken(ClickHouseParser.NULL_SQL, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_identifierOrNull

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierOrNull" ):
                listener.enterIdentifierOrNull(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierOrNull" ):
                listener.exitIdentifierOrNull(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierOrNull" ):
                return visitor.visitIdentifierOrNull(self)
            else:
                return visitor.visitChildren(self)




    def identifierOrNull(self):

        localctx = ClickHouseParser.IdentifierOrNullContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_identifierOrNull)
        try:
            self.state = 906
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.AFTER, ClickHouseParser.ALIAS, ClickHouseParser.ALL, ClickHouseParser.ALTER, ClickHouseParser.AND, ClickHouseParser.ANTI, ClickHouseParser.ANY, ClickHouseParser.ARRAY, ClickHouseParser.AS, ClickHouseParser.ASCENDING, ClickHouseParser.ASOF, ClickHouseParser.ASYNC, ClickHouseParser.ATTACH, ClickHouseParser.BETWEEN, ClickHouseParser.BOTH, ClickHouseParser.BY, ClickHouseParser.CASE, ClickHouseParser.CAST, ClickHouseParser.CHECK, ClickHouseParser.CLEAR, ClickHouseParser.CLUSTER, ClickHouseParser.CODEC, ClickHouseParser.COLLATE, ClickHouseParser.COLUMN, ClickHouseParser.COMMENT, ClickHouseParser.CONSTRAINT, ClickHouseParser.CREATE, ClickHouseParser.CROSS, ClickHouseParser.CUBE, ClickHouseParser.DATABASE, ClickHouseParser.DATABASES, ClickHouseParser.DATE, ClickHouseParser.DAY, ClickHouseParser.DEDUPLICATE, ClickHouseParser.DEFAULT, ClickHouseParser.DELAY, ClickHouseParser.DELETE, ClickHouseParser.DESC, ClickHouseParser.DESCENDING, ClickHouseParser.DESCRIBE, ClickHouseParser.DETACH, ClickHouseParser.DICTIONARIES, ClickHouseParser.DICTIONARY, ClickHouseParser.DISK, ClickHouseParser.DISTINCT, ClickHouseParser.DISTRIBUTED, ClickHouseParser.DROP, ClickHouseParser.ELSE, ClickHouseParser.END, ClickHouseParser.ENGINE, ClickHouseParser.EVENTS, ClickHouseParser.EXISTS, ClickHouseParser.EXPLAIN, ClickHouseParser.EXPRESSION, ClickHouseParser.EXTRACT, ClickHouseParser.FETCHES, ClickHouseParser.FINAL, ClickHouseParser.FIRST, ClickHouseParser.FLUSH, ClickHouseParser.FOR, ClickHouseParser.FORMAT, ClickHouseParser.FREEZE, ClickHouseParser.FROM, ClickHouseParser.FULL, ClickHouseParser.FUNCTION, ClickHouseParser.GLOBAL, ClickHouseParser.GRANULARITY, ClickHouseParser.GROUP, ClickHouseParser.HAVING, ClickHouseParser.HIERARCHICAL, ClickHouseParser.HOUR, ClickHouseParser.ID, ClickHouseParser.IF, ClickHouseParser.ILIKE, ClickHouseParser.IN, ClickHouseParser.INDEX, ClickHouseParser.INJECTIVE, ClickHouseParser.INNER, ClickHouseParser.INSERT, ClickHouseParser.INTERVAL, ClickHouseParser.INTO, ClickHouseParser.IS, ClickHouseParser.IS_OBJECT_ID, ClickHouseParser.JOIN, ClickHouseParser.KEY, ClickHouseParser.KILL, ClickHouseParser.LAST, ClickHouseParser.LAYOUT, ClickHouseParser.LEADING, ClickHouseParser.LEFT, ClickHouseParser.LIFETIME, ClickHouseParser.LIKE, ClickHouseParser.LIMIT, ClickHouseParser.LIVE, ClickHouseParser.LOCAL, ClickHouseParser.LOGS, ClickHouseParser.MATERIALIZED, ClickHouseParser.MAX, ClickHouseParser.MERGES, ClickHouseParser.MIN, ClickHouseParser.MINUTE, ClickHouseParser.MODIFY, ClickHouseParser.MONTH, ClickHouseParser.MOVE, ClickHouseParser.MUTATION, ClickHouseParser.NO, ClickHouseParser.NOT, ClickHouseParser.NULLS, ClickHouseParser.OFFSET, ClickHouseParser.ON, ClickHouseParser.OPTIMIZE, ClickHouseParser.OR, ClickHouseParser.ORDER, ClickHouseParser.OUTER, ClickHouseParser.OUTFILE, ClickHouseParser.PARTITION, ClickHouseParser.POPULATE, ClickHouseParser.PREWHERE, ClickHouseParser.PRIMARY, ClickHouseParser.QUARTER, ClickHouseParser.RANGE, ClickHouseParser.RELOAD, ClickHouseParser.REMOVE, ClickHouseParser.RENAME, ClickHouseParser.REPLACE, ClickHouseParser.REPLICA, ClickHouseParser.REPLICATED, ClickHouseParser.RIGHT, ClickHouseParser.ROLLUP, ClickHouseParser.SAMPLE, ClickHouseParser.SECOND, ClickHouseParser.SELECT, ClickHouseParser.SEMI, ClickHouseParser.SENDS, ClickHouseParser.SET, ClickHouseParser.SETTINGS, ClickHouseParser.SHOW, ClickHouseParser.SOURCE, ClickHouseParser.START, ClickHouseParser.STOP, ClickHouseParser.SUBSTRING, ClickHouseParser.SYNC, ClickHouseParser.SYNTAX, ClickHouseParser.SYSTEM, ClickHouseParser.TABLE, ClickHouseParser.TABLES, ClickHouseParser.TEMPORARY, ClickHouseParser.TEST, ClickHouseParser.THEN, ClickHouseParser.TIES, ClickHouseParser.TIMEOUT, ClickHouseParser.TIMESTAMP, ClickHouseParser.TO, ClickHouseParser.TOP, ClickHouseParser.TOTALS, ClickHouseParser.TRAILING, ClickHouseParser.TRIM, ClickHouseParser.TRUNCATE, ClickHouseParser.TTL, ClickHouseParser.TYPE, ClickHouseParser.UNION, ClickHouseParser.UPDATE, ClickHouseParser.USE, ClickHouseParser.USING, ClickHouseParser.UUID, ClickHouseParser.VALUES, ClickHouseParser.VIEW, ClickHouseParser.VOLUME, ClickHouseParser.WATCH, ClickHouseParser.WEEK, ClickHouseParser.WHEN, ClickHouseParser.WHERE, ClickHouseParser.WITH, ClickHouseParser.YEAR, ClickHouseParser.JSON_FALSE, ClickHouseParser.JSON_TRUE, ClickHouseParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 904
                self.identifier()
                pass
            elif token in [ClickHouseParser.NULL_SQL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 905
                self.match(ClickHouseParser.NULL_SQL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def EQ_SINGLE(self):
            return self.getToken(ClickHouseParser.EQ_SINGLE, 0)

        def numberLiteral(self):
            return self.getTypedRuleContext(ClickHouseParser.NumberLiteralContext,0)


        def getRuleIndex(self):
            return ClickHouseParser.RULE_enumValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumValue" ):
                listener.enterEnumValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumValue" ):
                listener.exitEnumValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumValue" ):
                return visitor.visitEnumValue(self)
            else:
                return visitor.visitChildren(self)




    def enumValue(self):

        localctx = ClickHouseParser.EnumValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_enumValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 908
            self.match(ClickHouseParser.STRING_LITERAL)
            self.state = 909
            self.match(ClickHouseParser.EQ_SINGLE)
            self.state = 910
            self.numberLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[21] = self.joinExpr_sempred
        self._predicates[38] = self.columnExpr_sempred
        self._predicates[44] = self.tableExpr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def joinExpr_sempred(self, localctx:JoinExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 4)
         

    def columnExpr_sempred(self, localctx:ColumnExprContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 18)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 23)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 21)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 20)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 1)
         

    def tableExpr_sempred(self, localctx:TableExprContext, predIndex:int):
            if predIndex == 15:
                return self.precpred(self._ctx, 2)
         




